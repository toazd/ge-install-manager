#!/usr/bin/env bash
# vim: set ft=shell nowrap et sta shiftwidth=4 ts=8 sts=0
# misc-bash/script-sloc ge-install-manager:
# 2037/3118 SLOC (65%) [SLOC/Comment:2.79], 729 comments (23%) [S:94%,I:5%] [Comment/SLOC:0.36], 395 empty (12%)

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

# -e  Exit immediately if a command exits with a non-zero status.
set +e # WARNING: DO NOT set -e

# -h Remember the location of commands as they are looked up. Default is on.
# -u Treat unset variables as an error when substituting. Default is off.
# -o pipefail The return value of a pipeline is the status of the last command
#             to exit with a non-zero status, or zero if no command exited with
#             a non-zero status. Default is off.
set -huo pipefail

###############################################################################
# "Things that would be nice, but aren't required for main features" list
#
# TODO: Find a way to not download releases more often than is necessary
#       (updates to download_count update the mtime of the remote file)
# TODO: Replace getopts with a custom parser
# TODO: support for using jq in addition to sed
#
###############################################################################

# Initialize global variables
# NOTE: Script constants (read only variables) are all upper-case
declare -gr SCRIPT_VERSION="0.7.4"
declare -gr SCRIPT_FULL_NAME=${0##*/}
declare -gr SCRIPT_CODENAME="Cochrane Bonaventure"
declare -gr CURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
declare -gr CURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
declare -gr CURL_HEADER_USER_AGENT="User-Agent: toazd/$SCRIPT_FULL_NAME/$SCRIPT_VERSION"
declare -gr TEMP_PREFIX=$SCRIPT_FULL_NAME.tmp.
# NOTE: Script global variables are all prefixed with g_
declare -g g_command_rm # Configuration file: rm_command
declare -g g_download_version
declare -g g_file_latest_json
declare -g g_file_releases_json
declare -g g_script_config_path=${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME
declare -g g_file_script_config=$g_script_config_path/$SCRIPT_FULL_NAME.conf
declare -g g_file_sed_unminify_script=$g_script_config_path/unminify-JSON.sed
declare -g g_install_path  # Configuration file: install_path
declare -g g_install_version
declare -g g_latest_version
declare -g g_latest_version_url # Configuration file: latest_version_url
declare -g g_override_default_install_path=''
declare -g g_releases_url # Configuration file: releases_url
declare -g g_remove_version
declare -g g_remove_saved_version
declare -g g_report_version
declare -g g_script_cache_path # Configuration file: cache_path
declare -g g_temp_base_path=/tmp # Configuration file: temp_path
declare -g g_verify_version
declare -gi g_check_update=0
declare -gi g_verbose=0
declare -gi g_download=0
declare -gi g_flag_sigint_caught=0
declare -gi g_force=0
declare -gi g_install=0
declare -gi g_integration_testing=0
declare -gi g_list_installed_versions=0
declare -gi g_real_exit_status=0
declare -gi g_remove_all_saved_packages=0
declare -gi g_remove_installed_version=0
declare -gi g_remove_install_path=0
declare -gi g_remove_saved_package=0
declare -gi g_report_install_path_usage=0
declare -gi g_report_version_usage=0
declare -gi g_show_help=0
declare -gi g_show_usage=0
declare -gi g_size_bytes_sed_unminify_script=824
declare -gi g_update=0
declare -gi g_verify=0

###############################################################################
# Purpose: Print the help text to stdout
# Input:   None
# Output:  None
# Return:  Always 0
ShowHelp() {

    cat <<HELP_HEREDOC

    $(basename "$0")  v$SCRIPT_VERSION "$SCRIPT_CODENAME"

    Required:       Bash 3.2+(TBD), curl, sed, tar, gzip, stat, wc
    Optional:       date, du, ps, sort, cmp, envsubst, fallocate, trash

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
    -r <version>  - Remove saved package <version>
    -V            - Verify each installation using its saved package
                      Combined with -v, -V will be skipped
                      Saved packages will be downloaded as needed
    -v <version>  - Verify <version> using its saved package
    -d <version>  - Download and save the package for <version>
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      NOTE: Saved packages are currently stored in the installation path
    -f            - Force install, upgrade, or remove
                      Combined with -U and/or -i, remove saved package and download a new copy
    -z            - Enable verbose output mode (to stderr)
                      Also preserves any temporary files created
                      Format: (calling line)[function trace]: message
HELP_HEREDOC

    return 0
}

###############################################################################
# Purpose: Print the usage text to stdout
# Input:  None
# Output: None
# Return: Always 0
ShowUsage() {

     cat <<USAGE_HEREDOC
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle,
      Report environment info (-fzZ),
      Show help,
      Show usage,
      Debug toggle,
      Check for latest release,
      Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Remove saved package (if remove install path is not active),
      Download,
      Update,
      Install,
      List installed,
      Report install path usage,
      Report specific version usage
      Verify

USAGE_HEREDOC

    return 0
}

###############################################################################
# Purpose: Set the global variable g_latest_version to the latest version
#          which is retrieved from the name member of the assets object in
#          the local file g_file_latest_json.
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = UpdateSavedGELatestRelease returned 1, or a match was not found
#              in g_file_latest_json
#
# TODO: Might want to check releases if latest fails. But, will the first entry
#       always be the latest?
GetLatestGEVersion() {

    g_latest_version=''

    if UpdateSavedGELatestRelease; then
        while IFS= read -r --; do
            # WARNING: Do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST"
            #          for matching. The version extracted from them (eg. 5.9-GE-5-ST) is not
            #          always the same as the version extracted from browser_download_url
            # NOTE: The regex must match all 3 of the following potential formats:
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name": "Proton-5.9-GE-5-ST.tar.gz"
            [[ $REPLY =~ ^[[:blank:]]*\"name\":[[:blank:]]*\"Proton-.*\.tar\.gz\".*$ ]] && {
                g_latest_version=${REPLY#*\"name\":}
                g_latest_version=${g_latest_version#*\"}
                g_latest_version=${g_latest_version%.tar.gz\"*}
                break
            }
        done < "$g_file_latest_json"
        [[ -z $g_latest_version ]] && {
            ((g_verbose)) && vMsg "g_latest_version is NULL (no match or not found)"
            return 1
        }
    else
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Call the RequestURL function to save the (JSON) from the URL
#          g_latest_version_url to the local file g_file_latest_json
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = RequestURL returned 1 or an unknown error occured
#
# TODO: Consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGELatestRelease() {

    ((g_verbose)) && {
        vMsg "g_latest_version_url: \"$g_latest_version_url\""
        vMsg "g_file_latest_json: \"$g_file_latest_json\""
    }

    if RequestURL "$g_latest_version_url" "$g_file_latest_json"; then
        return 0
    else
        return 1
    fi
}

###############################################################################
# Purpose: Call the RequestURL function to save the (JSON) from the URL
#          g_releases_url to the local file g_file_releases_json
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = RequestURL returned 1 or an unknown error occured
#
# TODO: Consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGEReleases() {

    # BUG: updates to download_count in the remote file cause curl -z to download a new version much more often than is needed
    #      Until a workaround is found, latest and releases are kept seperate and not checked at the same time
    ((g_verbose)) && {
        vMsg "g_releases_url: \"$g_releases_url\""
        vMsg "g_file_releases_json: \"$g_file_releases_json\""
    }

    if RequestURL "$g_releases_url" "$g_file_releases_json"; then
        return 0
    else
        return 1
    fi
}

###############################################################################
# Purpose: Using curl, download a proton-ge-custom release package to a
#          temporary path and if the download size matches the expected size
#          copy it to g_install_path
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
DownloadGEPackage() {

    # Declare local variables
    local version
    local temp_path
    local temp_package
    local package_download_url
    local -i temp_base_path_remaining_bytes=0
    local -i install_path_remaining_bytes=0
    local -i expected_size_bytes=0
    local -i downloaded_package_size_bytes=0

    # Set local variables, checking return values and reporting as needed
    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Get the download URL from the saved latest/releases JSON
    package_download_url=$(QueryGEAttribute "$version" "browser_download_url") || {
        ((g_verbose)) && vMsg "QueryGEAttribute browser_download_url returned failure"
        return 1
    }

    # If QueryGEAttribute returned success but the URL is NULL, abort
    [[ -z $package_download_url ]] && { ((g_verbose)) && vMsg "package_download_url is NULL"; return 1; }

    # Get the expected package size in bytes from the saved latest/releases JSON
    expected_size_bytes=$(QueryGEAttribute "$version" "size") || { ((g_verbose)) && vMsg "QueryGEAttribute size returned failure"; return 1; }
    # If QueryGEAttribute returned success but size is not all digits, abort
    [[ $expected_size_bytes =~ ^[[:digit:]]+$ ]] || { ((g_verbose)) && vMsg "size is not all digits: \"$expected_size_bytes\""; return 1; }

    # Create a temporary path for the package
    temp_path=$(MkTempPath)

    # Define the temporary package name
    temp_package=$temp_path/Proton-${version}.tar.gz

    # Get the bytes remaining on the temp path
    temp_base_path_remaining_bytes=$(SpaceRemaining "$g_temp_base_path" "b") || {
        ((g_verbose)) && vMsg "SpaceRemaining returned failure checking $temp_path"
        return 1
    }

    # Get the bytes remaining on the install path
    install_path_remaining_bytes=$(SpaceRemaining "$g_install_path" "b") || {
        ((g_verbose)) && vMsg "SpaceRemaining returned failure checking $g_install_path"
        return 1
    }

    # Check if there is enough free space to copy the package to g_install_path
    if [[ $expected_size_bytes -gt $install_path_remaining_bytes ]]; then
        printf '%s\n%s\n' \
               "WARNING: Not enough free space at \"$g_install_path\"" \
               "Need at least $expected_size_bytes bytes but there is only $install_path_remaining_bytes bytes free"
        return 1
    else
        ((g_verbose)) && {
            vMsg "g_install_path ($g_install_path) remaining bytes: $install_path_remaining_bytes"
            vMsg "temp_path ($temp_path) remaining bytes: $temp_base_path_remaining_bytes"
            vMsg "Expected package size (bytes): $expected_size_bytes"
        }
    fi

    # If there is not enough free space remaining on the temp_path file system
    # TODO: Use a different path as a fallback?
    if [[ $temp_base_path_remaining_bytes -lt $expected_size_bytes ]]; then
        ((g_verbose)) && vMsg "Free space on \"$g_temp_base_path\" is $temp_base_path_remaining_bytes bytes"
        printf '%s\n%s\n%s\n' \
               "WARNING: Not enough free space at \"$g_temp_base_path\"" \
               "Need at least $expected_size_bytes bytes but there is only $temp_base_path_remaining_bytes bytes free" \
               "Free up space or change temp_path in the configuration file"
        return 1
    else
        # If fallocate is found, preallocate the file to be downloaded
        if command -v fallocate &>/dev/null; then
            if fallocate -l "$expected_size_bytes" -- "$temp_package"; then
                ((g_verbose)) && vMsg "fallocate succeeded"
            else
                #echo "Failed to preallocate \"$sTMP_FILE\", download may fail"
                ((g_verbose)) && vMsg "\"fallocate -l $expected_size_bytes -- $temp_package\" returned failure"
                [[ -f $temp_package ]] && rm -f -- "$temp_package"
            fi
        else
            ((g_verbose)) && vMsg "fallocate not found"
        fi
    fi

    # Attempt to retrieve the package with curl
    echo "Downloading \"$package_download_url\""
    if curl -# -L "$package_download_url" -o "$temp_package"; then

        # Get the downloaded file size in bytes
        downloaded_package_size_bytes=$(stat -c '%s' -- "$temp_package")
        ((g_verbose)) && vMsg "Downloaded package size in bytes: \"$downloaded_package_size_bytes\""

        # Not found
        if [[ $downloaded_package_size_bytes -eq 9 ]]; then
            echo "Server responded \"Not Found\" for version \"$version\""
            CleanUp
            return 1
        fi

        # Github API request rate limit exceeded
        if [[ $downloaded_package_size_bytes -eq 248 ]]; then
            echo "Github API request rate limit exceeded. Try again later."
            CleanUp
            return 1
        fi

        # Check if the the package size and expected size are equal
        if [[ $downloaded_package_size_bytes -eq $(QueryGEAttribute "$version" "size") ]]; then
            echo "Downloaded package is the expected size ($expected_size_bytes bytes)"
        else
            printf '%s\n%s\n' \
                   "Downloaded file size and expected size do not match" \
                   "(\"$downloaded_package_size_bytes\" vs \"$expected_size_bytes\")"
           CleanUp
           return 1
        fi

        # Copy the package from the temporary path to g_install path
        ((g_verbose)) && vMsg "Copying package \"$temp_package\" to \"$g_install_path\""
        if cp -- "$temp_package" "$g_install_path"; then
            ((g_verbose)) && vMsg "Package copied successfully"
            echo "Download succeeded"
            CleanUp
        else
            ((g_verbose)) && vMsg "Copy package from \"$temp_package\" to \"$g_install_path\" failed"
            echo "Download failed"
            CleanUp
            return 1
        fi
    else
        # curl returned >0
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: TODO
# Input:   TODO
# Output:  TODO
# Return:  0 = Success
#          1 = Failure
UpdateGEVersion() {

    g_update=1

    if InstallGEVersion; then
        g_update=0
        return 0
    else
        return 1
    fi

    return 1
}


###############################################################################
# Purpose: Install a requested proton-ge-custom release version or install the
#          latest version. If g_force=1 and a saved package exists for the
#          requested version the package will be removed and a new one will be
#          downloaded.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          When called with no parameter/a NULL parameter and $g_update=1, the latest version will be installed.
# Output:  None
# Return:  0 = Success
#          1 = Failure
#
# TODO: Seperate Install and Update
InstallGEVersion() {

    local version

    # Determine the "mode" (install or update)
    ((g_verbose)) && vMsg "Determining mode"

    # Update to the latest version
    if [[ $g_update -eq 1 && $g_install -eq 0 ]]; then
        ((g_verbose)) && vMsg "Update mode active"
        if GetLatestGEVersion; then
            version=$g_latest_version
            CleanUpVersion
        else
            return 1
        fi
    # Install a specific version
    elif [[ $g_install -eq 1 && $g_update -eq 0 ]]; then
        ((g_verbose)) && vMsg "Install mode active"
        version=${1-}
        CleanUpVersion
    else
        ((g_verbose)) && {
            vMsg "Unable to detect install mode"
            vMsg "g_update: \"$g_update\""
            vMsg "g_install: \"$g_install\""
            vMsg "\$1: \"$1\""
            vMsg "version: \"$version\""
            vMsg "g_latest_version: \"$g_latest_version\""
        }
        return 1
    fi

    if [[ -n $version ]]; then
        ((g_verbose)) && vMsg "Requested version is \"$version\""
    else
        ((g_verbose)) && vMsg "version is NULL"
        return 1
    fi

    # Re-install a version that is already installed
    if IsInstalled "$version"; then
        if [[ $g_force -eq 0 ]]; then
            echo "Version \"$version\" is already installed"
            return 0
        elif [[ $g_force -eq 1 ]]; then
            if IsSteamRunning; then
                echo "Please close Steam before re-installing a version"
                return 1
            else
                echo "Forcing re-install of version \"$version\""
            fi
        fi
    fi

    # If a saved package exists and force mode is not active
    if [[ -f $g_install_path/Proton-${version}.tar.gz ]] && [[ $g_force -eq 0 ]]; then
        echo "Using saved package: \"$g_install_path/Proton-${version}.tar.gz\""
        if ExtractGEPackage "$version"; then
            return 0
        else
            return 1
        fi
    # If a saved package exists and force mode is active
    elif [[ -f $g_install_path/Proton-${version}.tar.gz ]] && [[ $g_force -eq 1 ]]; then
        echo "Removing saved package \"$g_install_path/Proton-${version}.tar.gz\""
        if ($g_command_rm -- "$g_install_path/Proton-${version}.tar.gz"); then
            echo "Package removed"
        else
            echo "Removing package failed"
            return 1
        fi
    fi

    # If a saved package for this version doesn't exist or it was removed, download it and install it
    if DownloadGEPackage "$version"; then
        if ExtractGEPackage "$version"; then
            echo "Installation of version \"$version\" was successful"
            return 0
        else
            echo "Installation of version \"$version\" failed"
            return 1
        fi
    else
        echo "Version \"$version\" not found"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove an installed Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
RemoveGEVersion() {

    local version
    local remove_path
    local disk_usage

    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Define the path that will be removed
    remove_path=$g_install_path/Proton-${version}

    ((g_verbose)) && vMsg "Requested version: \"$version\" remove_path: \"$remove_path\""

    # Remove the path if it exists
    if [[ -d $remove_path ]]; then
        if ! IsSteamRunning; then
            # Get the disk usage in human readable format
            disk_usage=$(du -sh -- "$remove_path" 2>/dev/null)
            disk_usage=${disk_usage%[[:space:]]*}
            if ($g_command_rm -rf -- "$remove_path" &>/dev/null); then
                echo "Removed path \"$remove_path\" (${disk_usage:-'error'})"
            else
                echo "Failed to remove \"$remove_path\""
                return 1
            fi
        else
            echo "Please close Steam before removing an install path"
            return 1
        fi
    else
        echo "Install path not found for version \"$version\""
    fi

    return 0
}

###############################################################################
# Purpose: Extract a Proton-ge-custom package (.tar.gz) to g_install path or
#          optionally to a specified path.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (optional) The path to extract the package to (default: g_install_path)
# Output:  None
# Return:  0 = Success
#          1 = Failure
ExtractGEPackage() {

    local version
    local extract_file
    local extract_path

    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Define the package name to extract
    extract_file=$g_install_path/Proton-${version}.tar.gz

    # Define the path to extract the package to
    extract_path=${2:-$g_install_path}
    [[ ! -d $extract_path && -w $extract_path ]] && { ((g_verbose)) && vMsg "Parameter error (not a valid path)"; return 1; }

    # Display "Extracting" with trailing dots indicating the extraction progress
    printf '%s' "Extracting \"$extract_file\" to \"$extract_path\""
    if tar --checkpoint=.10000 -C "$extract_path" -xzf "$extract_file" 2>/dev/null; then

        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extraction failed"

        # If the extraction failed, remove the partially extracted path
        [[ -d $extract_path/Proton-${version} ]] && {
            if ($g_command_rm -- "$extract_path/Proton-${version}"); then
                ((g_verbose)) && vMsg "Removal succeeded"
                echo "Removed failed extraction path at \"$extract_path/Proton-${version}\""
            else
                echo "Failed to remove partial extraction path: \"$extract_path/Proton-${version}\""

                # TODO: update/remove message when install verification is updated
                echo "This script may interpret it as a valid g_install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Print the currently installed Proton-ge-custom versions, saved
#          packages, and their individual disk usage to stdout.
# Input:   None
# Output:  None
# Return:  Always 0
ListInstalledGEVersions() {

    local -i i=0
    local node
    local installed_version_disk_usage
    local saved_package_disk_usage
    local saved_packages_total_disk_usage

    ((g_verbose)) && vMsg "Install path: \"$g_install_path\""

    echo "Installed version(s):"
    for node in "$g_install_path"/Proton-*; do
        [[ -d $node ]] && {
            ((i++))
            # Get the disk usage of the package in human readable format
            IFS=$'\t' read -r -- installed_version_disk_usage path < <(du -sh -- "$node")
            echo "  ${node##*/} ($installed_version_disk_usage)"
        }
    done
    [[ $i -eq 0 ]] && echo "  None found"

    echo "Saved package(s):"
    i=0
    for node in "$g_install_path"/Proton-*.tar.gz; do
        if [[ -f $node ]]; then
            ((i++))
            if [[ $g_verbose -eq 0 ]]; then
                IFS=$'\t' read -r -- saved_package_disk_usage path < <(du -h -- "$node")
                echo "  ${node##*/} ($saved_package_disk_usage)"
            elif [[ $g_verbose -eq 1 ]]; then
                vMsg "${node##*/} (size: $(stat -c '%s' -- "$node"), expected size: $(QueryGEAttribute "${node##*/}" "size"))"
            fi
        fi
    done

    # Report total disk usage for saved packages if one or more were found
    if [[ $i -ge 1 ]]; then
        while IFS=$'\t' read -r -- size path; do
            [[ $path = "total" ]] && saved_packages_total_disk_usage=$size
        done < <(du -csh -- "$g_install_path/"*.tar.gz)
        echo "Saved packages total: $saved_packages_total_disk_usage"
    elif [[ $i -eq 0 ]]; then
        echo "  None found"
    fi

    return 0
}

###############################################################################
# Purpose: Print the disk usage and file count for g_install_path and/or a
#          specified version to stdout.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 A required external command was not found or the version requested was not found
ReportGEDiskUsage() {

    local version
    local file_counter
    local disk_usage="0"
    local -i flag_missing_command=0
    local path

    version=${1-}
    CleanUpVersion

    # NOTE: do not return 1 if version is NULL, functionality below depends on it

    # Optional commands that are required for this function
    if ! command -v du &>/dev/null; then
        echo "Command 'du' not found"
        flag_missing_command=1
    fi

    if ! command -v find &>/dev/null; then
        echo "Command 'find' not found"
        flag_missing_command=1
    fi

    # If all command checks succeeded
    if [[ $flag_missing_command -eq 0 ]]; then

        # Set the path to be reported based on whether a version was provided or not
        if [[ -z $version ]]; then

            # Report the file count and disk usage for g_install_path
            if [[ -d $g_install_path ]]; then
                disk_usage=$(du -sh -- "$g_install_path")
                file_counter=$(find "$g_install_path" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' \
                       "Path: $g_install_path" \
                       "Files: $file_counter" \
                       "Disk usage: ${disk_usage%%[[:blank:]]*}"
            else
                ((g_verbose)) && vMsg "Path: $g_install_path"
                echo "Version \"$version\" not found"
                return 1
            fi
        fi

        # If a version was supplied as a parameter, report only for that version
        if [[ -n $version ]]; then

            # Report the file count and disk usage for a specific version
            path=$g_install_path/Proton-${version}
            if [[ -d $path ]]; then
                disk_usage=$(du -sh -- "$path")
                file_counter=$(find "$path" -type f | wc -l)
                echo "Version \"$version\" report:"
                printf '  %s\n  %s\n  %s\n' \
                       "Path: $path" \
                       "Files: $file_counter" \
                       "Disk usage: ${disk_usage%%[[:blank:]]*}"
            else
                ((g_verbose)) && vMsg "Path: $path"
                echo "Version \"$version\" not found"
                return 1
            fi
        fi

    # If any command check failed
    elif [[ $flag_missing_command -eq 1 ]]; then
        echo "Report not available"
    fi

    return $(( flag_missing_command ? 1 : 0 ))
}

###############################################################################
# Purpose: Remove a saved package for a specified Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 Failure
RemoveSavedPackage() {

    local version
    local package

    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Define the package path and name that will be removed
    package=$g_install_path/Proton-${version}.tar.gz

    if [[ -f $package ]]; then
        if [[ -w $package ]]; then
            if ($g_command_rm -- "$package"); then
                echo "Removed \"$package\""
                return 0
            else
                echo "Failed to remove version \"$version\" ($g_command_rm returned >0)"
                return 1
            fi
        else
            echo "Failed to remove version \"$version\" (no write permission)"
            return 1
        fi
    else
        echo "Failed to remove version \"$version\" (file not found)"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove all saved packages in g_install_path
# Input:   None
# Output:  None
# Return:  0 Success (all packages or 0 packages were removed)
#          1 Failure (any one package removal failed)
RemoveAllSavedPackages() {

    local -i success_counter=0
    local -i failure_counter=0
    local package

    ((g_verbose)) && vMsg "Install path: \"$g_install_path\""

    for package in "$g_install_path"/Proton-*.tar.gz; do
        if [[ -f $package ]]; then
            if ($g_command_rm -- "$package"); then
                echo "Removed \"$package\""
                ((success_counter++))
            else
                echo "Remove \"$package\" failed"
                ((failure_counter++))
            fi
        fi
    done

    if [[ $success_counter -eq 0 ]]; then
        echo "0 packages removed"
    elif [[ $success_counter -gt 0 ]]; then
        echo "$success_counter packages removed"
    fi

    [[ $failure_counter -gt 0 ]] && echo "Failed to remove $failure_counter package(s)"

    return $(( failure_counter ? 1 : 0 ))
}

###############################################################################
# Purpose: Remove g_install_path
# Input:   None
# Output:  None
# Return:  0 Success
#          1 Failure (Remove failed or re-creating g_install_path failed)
RemoveGEInstallPath() {

    local disk_usage="0"

    if command -v du &>/dev/null; then
        disk_usage=$(du -sh -- "$g_install_path")
    else
        ((g_verbose)) && vMsg "Command 'du' not found"
        disk_usage="unknown"
    fi

    if ($g_command_rm -- "$g_install_path"); then
        echo "Remove install path succeeded ( ${disk_usage%%[[:blank:]]*} removed )"
        ((g_verbose)) && vMsg "Recreating install path at \"$g_install_path\""

        # Re-create the g_install_path in case a requested subsequent script function needs it
        if mkdir -p -- "$g_install_path" &>/dev/null; then
            ((g_verbose)) && vMsg "mkdir -p \"$g_install_path\" succeeded"
        else
            if [[ $g_verbose -eq 1 ]]; then
                vMsg "mkdir -p \"$g_install_path\" failed"
            else
                echo "Warning: failed to re-create install path at \"$g_install_path\""
                return 1
            fi
        fi
    else
        echo "Removal of install path \"$g_install_path\" failed"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Verify all installed versions or a specified version by comparing
#          each file from the saved package to the installed file and report
#          the number of files that match, are missing, and don't match to stdout.
# Input:   None
# Output:  None
# Return:  0 Success
#          1 Failure
# NOTE: __pycache__ is created at runtime in an installed version path and will
#       not be present in the saved packages.
VerifyGEInstall() {

    local node
    local path
    local temp_path
    local version
    local file_extracted
    local file_installed
    local saved_cmp_alias='' # NOTE: Must be initialized to NULL
    local -a files_extracted
    local -a files_installed
    local -i expected_size_bytes=0
    local -i temp_base_path_remaining_bytes=0
    local -i match_counter=0
    local -i missing_counter=0
    local -i mismatch_counter=0
    local -i files_arrays_count_match=0
    local -i total_files=0
    local -i counter_extracted=0
    local -i counter_installed=0
    local -i start_time_seconds=0 # NOTE: bash 5+ is required for EPOCHSECONDS
    local -i end_time_seconds=0   # NOTE: bash 4.2+ is required for printf $()T
    local -i progress_percent=0
    local -i prev_progress=1
    local -i flag_missing_command=0

    version=${1-}
    CleanUpVersion

    # If g_temp_base_path = g_install_path
    # WARNING: Setting g_temp_base_path and g_install_path to the same path would cause
    #          this function to overwrite installed versions and then attempt
    #          to compare those extracted files (and any others already there) to themselves.
    [[ $g_temp_base_path -ef $g_install_path ]] && {
        vMsg "Setting tmp_path and install_path to the same path is not supported"
        return 1
    }

    # Required external commands
    if ! command -v cmp &>/dev/null; then
        echo "Command 'cmp' is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v sort &>/dev/null; then
        echo "Command 'sort' is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v date &>/dev/null; then
        echo "Command 'date' is required to use this function"
        flag_missing_command=1
    fi

    # If any one required command is missing
    [[ $flag_missing_command -eq 1 ]] && return 1

    # Check for install paths that don't have a saved package, download if missing
    for node in "$g_install_path/Proton-"*; do
        [[ -d $node ]] && {

            # Verify that it is installed
            IsInstalled "${node##*/}" && {

                # If no saved package exists for this version
                [[ ! -f $g_install_path/${node##*/}.tar.gz ]] && {
                    echo "Package not found for installed version \"${node##*/}\""
                    if ! DownloadGEPackage "${node##*/Proton-}"; then
                        return 1
                    fi
                }
            }
        }
    done

    # For each saved package available, check each file in the package against the installed file
    for node in "$g_install_path"/Proton-${version:-*}.tar.gz; do
        [[ -f $node ]] && {
            version=${node##*/}
            CleanUpVersion
            echo "Found a package for version \"$version\""
            if ! IsInstalled "$version"; then
                echo "Version \"$version\" is not installed"
                continue
            else
                echo "Version \"$version\" is installed"

                # Check for enough free space on the filesystem that contains tmp_path
                IFS=$'\t' read -r -- expected_size_bytes path < <(du -bs -- "$g_install_path/Proton-${version}")
                temp_base_path_remaining_bytes=$(SpaceRemaining "$g_temp_base_path" "b")

                ((g_verbose)) && {
                    vMsg "$version extracted size: $expected_size_bytes bytes"
                    vMsg "$temp_base_path_remaining_bytes remaining bytes: $temp_base_path_remaining_bytes"
                }

                [[ $expected_size_bytes -gt $temp_base_path_remaining_bytes ]] && {
                    echo "WARNING: Not enough free space at \"$g_temp_base_path\" to continue"
                    CleanUp
                    return 1
                }

                # Reset for each package to check
                CleanUp
                temp_path=$(MkTempPath)
                match_counter=0
                mismatch_counter=0
                missing_counter=0
                progress_percent=0
                prev_progress=1

                # Extract the package to a temporary path
                if ! ExtractGEPackage "$version" "$temp_path"; then
                    return 1
                fi

                # Create two indexed arrays, each containing a seperate list of files,
                # one from the extracted path and the other from the installed path
                echo "Indexing files to compare"

                # Array of extracted files
                while IFS= read -r -- file_extracted; do
                    files_extracted+=("$file_extracted")
                done < <(find "$temp_path/Proton-${version}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)

                # Array of installed files
                while IFS= read -r -- file_installed; do
                    files_installed+=("$file_installed")
                done < <(find "$g_install_path/Proton-${version}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)

                # Report the number of files found in each path
                echo "Found ${#files_extracted[@]} (extracted) and ${#files_installed[@]} (installed) files"

                # Based on array element sizes, decide on a method to compare files
                # The faster method is a one-to-one comparison of each array element.
                # The slower method takes each element of the extracted array and then searches through
                # the entire installed array until it finds a matching file name.
                if [[ ${#files_extracted[@]} -ne ${#files_installed[@]} ]]; then
                    echo "Using slower method for comparing"
                    files_arrays_count_match=0
                else
                    echo "Using faster method for comparing"
                    files_arrays_count_match=1
                fi

                # If an alias exists for cmp (much faster than executing cmp in a subshell)
                # NOTE: This isn't necessary by default. It is included in the event that
                #       the shebang is changed and a custom alias exists for cmp.
                if alias cmp &>/dev/null; then
                    echo "Saving existing alias for command cmp"
                    saved_cmp_alias=$(alias cmp)
                    unalias cmp
                fi

                # NOTE: save_cursor and restore_cursor using the kitty terminal does
                #       not behave like other terminals so the following progress output
                #       will be mangled on that terminal.
                #       This is intentional according to the author:
                #       https://github.com/kovidgoyal/kitty/issues/2945
                #       https://github.com/kovidgoyal/kitty/issues/1264
                printf '%s\033[s' "Comparing files" #printf '%s\E7' "Comparing files"

                # Begin comparing, using the faster method
                # If the number of elements match
                if [[ $files_arrays_count_match -eq 1 ]]; then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"; do
                        cmp -s -- "${files_extracted[counter_extracted]}" "${files_installed[counter_extracted]}"
                        case $? in
                            (0) ((match_counter++)) ;;
                            (1) ((mismatch_counter++)) ;;
                            (2) ((missing_counter++)) ;;
                        esac
                        # Some test results - this method is already
                        # reasonably fast so not much testing was done
                        # 1 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 2 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 3 - do nothing - 5.9-GE-3-ST - 6 seconds

                        # 1 - 5.9-GE-3-ST - 6 seconds
                        # 2 - 5.9-GE-3-ST - 7 seconds
                        # 3 - 5.9-GE-3-ST - 7 seconds
                        #unset 'files_installed[counter_extracted]'
                        #unset 'files_extracted[counter_extracted]'

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))
                        [[ $progress_percent -ne $prev_progress ]] && printf '\033[u%s' "... ${progress_percent}%" # Only update the progress_percent when it actually changes
                        #[[ $progress_percent -ne $prev_progress ]] && printf '\E8%s' "... ${progress_percent}%" # Only update the progress_percent when it actually changes
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)

                # Begin comparing, using the slower method
                elif [[ $files_arrays_count_match -eq 0 ]]; then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"; do

                        # Strip away the part of the path that is different for the current file
                        sCOMPARE_EXTRACTED=${files_extracted[counter_extracted]/#$temp_path\/}
                        for counter_installed in "${!files_installed[@]}"; do

                            # Strip away the part of the path that is different for the current file
                            sCOMPARE_INSTALLED=${files_installed[counter_installed]/#$g_install_path\/}

                            if [[ $sCOMPARE_INSTALLED = "$sCOMPARE_EXTRACTED" ]]; then
                                cmp -s -- "${files_installed[counter_installed]}" "${files_extracted[counter_extracted]}"
                                case $? in
                                    (0) ((match_counter++)) ;;
                                    (1) ((mismatch_counter++)) ;;
                                    (2) ((missing_counter++)) ;;
                                esac
                                # Some test results - fastest is what remains
                                # fastest - 5.9-GE-3-ST - 246 seconds
                                unset 'files_installed[counter_installed]'

                                # do nothing1 - 5.9-GE-3-ST - 376 seconds
                                # do nothing2 - 5.9-GE-3-ST - 484 seconds

                                # 5.9-GE-3-ST - 486 seconds
                                #files_installed=(${files_installed[@]:0:$counter_installed} ${files_installed[@]:$((counter_installed+1))})

                                # 5.9-GE-3-ST - 398 seconds
                                #files_installed=("${files_installed[@]:0:$counter_installed}" "${files_installed[@]:$((counter_installed+1))}")

                                #unset 'files_extracted[counter_extracted]'
                                #files_extracted=(${files_extracted[@]:0:$counter_extracted} ${files_extracted[@]:$((counter_extracted+1))})
                                #total_files=${#files_extracted[@]}
                            fi
                        done

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))
                        [[ $progress_percent -ne $prev_progress ]] && printf '\033[u%s' "... ${progress_percent}%" # Only update the progress_percent when it actually changes
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)
                fi

                # Restore saved cmp alias
                # TODO: do other shells alias command output in a reusable format?
                [[ -n $saved_cmp_alias ]] && {
                    echo "Restoring saved alias for command cmp"
                    if ! $saved_cmp_alias; then
                        echo "Failed to restore alias for 'cmp'"
                    fi
                }

                printf "\033[u\033[0K%s\n" ". Finished in $(( end_time_seconds - start_time_seconds )) seconds."

                # Report
                echo "$match_counter files match. $missing_counter files are missing. $mismatch_counter do not match."

                if [[ $match_counter -gt 0 && $missing_counter -eq 0 && $mismatch_counter -eq 0 ]]; then
                    echo "Installation for version \"$version\" appears ok"
                elif [[ $missing_counter -gt 0 || $mismatch_counter -gt 0 ]]; then
                    printf '%s\n%s\n' \
                           "WARNING: Version \"$version\" has missing or potentially corrupt files." \
                           "If you did not manually modify your installation you may want to force reinstall it (-fi $version)"
                fi
            fi
        }
    done

    return 0
}

###############################################################################
# Purpose: A wrapper for QueryJSONAttribute that provides a single function call
#          to retrieve values from keys/attributes in both g_file_latest_json and
#          g_file_releases_json.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (required) A supported attribute name (refer to QueryJSONAttribute)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 Failure (a value was not found for the requested attribute or an error occured)
# TODO Seperate return values for not found and error
QueryGEAttribute() {

    [[ -z $1 || -z $2 || $# -ne 2 ]] && { ((g_verbose)) && vMsg "Parameter error 1: \"$1\" 2: \"$2\" \$#: \"$#\""; return 1; }

    local version
    local value
    local key=${2-}

    version=${1-}
    CleanUpVersion

    UpdateSavedGELatestRelease # NOTE: Do not abort on failure

    ((g_verbose)) && vMsg "Checking $g_file_latest_json"

    # Search g_file_latest_json
    value=$(QueryJSONAttribute "$g_file_latest_json" "$version" "$key") # NOTE: DO NOT return 1 on failure

    # If the returned value from QueryJSONAttribute was NULL and the return status
    # was 0 (success), try g_file_releases_json
    if [[ -z $value ]]; then
        UpdateSavedGEReleases # NOTE: Do not abort on failure
        ((g_verbose)) && vMsg "Checking $g_file_releases_json"
        ((g_verbose)) && vMsg "For $key of version $version"
        if value=$(QueryJSONAttribute "$g_file_releases_json" "$version" "$key"); then
            ((g_verbose)) && vMsg "QueryJSONAttribute returned success"
        else
            ((g_verbose)) && vMsg "QueryJSONAttribute returned failure. value: \"$value\""
        fi
    fi

    if [[ -n $value ]]; then
        printf '%s' "$value"
        return 0
    else
        printf '' # TODO: is it really necessary to return NULL?
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Retrieve a supported attribute value from a specified JSON file
# Input:   1 (required) JSON file
#          2 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          3 (required) A supported attribute name (size or browser_download_url)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 Failure (a value was not found for the requested attribute or an error occured)
#
# NOTE This function relies on the JSON being structured in a precise, predictable order
# Example order of attributes expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE: The default media-type requested is "application/vnd.github.v3.text+json" and
#       the current sed script also reformats the body_text section to plain text. Those
#       choices were made to more easily support (eventually) showing release notes.
QueryJSONAttribute() {

    # If the number of parameters is not exactly three, the second parameter is not a regular file, or any of the three parameters are empty
    if [[ $# -ne 3 ]] || [[ ! -f $1 ]] || [[ -z $1 || -z $2 || -z $3 ]]; then
        ((g_verbose)) && vMsg "Parameter error 1: \"$1\" 2: \"$2\" 3: \"$3\" \$#: \"$#\""
        return 1
    fi

    # Check if the attribute requested is currently supported
    [[ ${3,,} != @(size|browser_download_url) ]] && { ((g_verbose)) && vMsg "Parameter error (unsupported attribute requested) \"$2\""; return 1; }

    local version
    local file_json=${1-}
    local value_browser_url=''
    local key
    local value_size_bytes='' # NOTE: DO NOT set -i
    local -i counter_lines=0
    local -i line_version_found=0
    local -i line_size_found=0
    local -i line_browserurl_found=0
    local -i flag_version_found=0
    local -i flag_size_found=0
    #local flag_browserurl_found=0

    version=$2
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "version is NULL"; return 1; }

    key=${3,,}

    ((g_verbose)) && vMsg "Searching in \"$file_json\""

    # WARNING: Do not output to stdout or stderr inside the following loop
    while IFS= read -r --; do
        ((counter_lines++))
        # version match
        # version example: 5.9-GE-5-ST
        # NOTE: must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        [[ $REPLY =~ ^.*\"name\":.*\"Proton-${version}\.tar\.gz\".*$ ]] && {
            flag_version_found=1
            line_version_found=$counter_lines
            continue
        }

        # NOTE: must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        [[ $flag_version_found -eq 1 ]] && {
            [[ ${REPLY,,} =~ ^.*\"size\":.*[[:digit:]]+.*$ ]] && {
                flag_size_found=1
                line_size_found=$counter_lines
                value_size_bytes=${REPLY//[[:space:]]}
                value_size_bytes=${value_size_bytes/#\"size\":}
                value_size_bytes=${value_size_bytes%%[[:punct:]]*} # value_size_bytes=${value_size_bytes%,*}
                continue
            }
        }

        # NOTE: must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        [[ $flag_version_found -eq 1 && $flag_size_found -eq 1 ]] && {
            [[ $REPLY =~ ^.*\"browser_download_url\":.*\".*Proton-${version}\.tar\.gz\".*$ ]] && {
                #flag_browserurl_found=1
                line_browserurl_found=$counter_lines
                value_browser_url=${REPLY/#*\"browser_download_url\":}
                value_browser_url=${value_browser_url//[[:space:]]}
                value_browser_url=${value_browser_url/#\"}
                value_browser_url=${value_browser_url%%\"*}
                break
            }
        }
    done < "$file_json"

    # Debug messages
    [[ $g_verbose -eq 1 ]] && {
        if [[ $flag_version_found -eq 0 ]]; then
            vMsg "Version match not found"
        elif [[ $flag_version_found -eq 1 ]]; then
            vMsg "Version match found at line $line_version_found"
        fi
        if [[ -z $value_size_bytes ]]; then
            vMsg "value_size_bytes is NULL"
        else
            vMsg "value_size_bytes: \"$value_size_bytes\""
        fi
        if [[ -z $value_browser_url ]]; then
            vMsg "value_browser_url is NULL"
        else
            vMsg "value_browser_url: \"$value_browser_url\""
        fi
        vMsg "line_version_found: $line_version_found line_size_found: $line_size_found line_browserurl_found: $line_browserurl_found"
    }

    # Print the value of the requested attribute to stdout
    if [[ -n $value_size_bytes && -n $value_browser_url ]]; then
        case $key in
            (size)
                printf '%s' "$value_size_bytes"
            ;;
            (browser_download_url)
                printf '%s' "$value_browser_url"
            ;;
            (*)
                # NOTE: NULL response indicates error OR not found. This is NOT ideal
                printf '' # TODO: is it really necessary to return NULL?
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Run sed using the script g_file_sed_unminify_script (generated by the
#          function CreateSedUnminifyJSONscript) on a specified file.
# Input:   1 (required) A JSON file (minified and not minified are both supported)
# Output:  None
# Return:  0 Success
#          1 Failure
ReformatJSONUsingSed() {

    local file_json=${1-}

    [[ -z $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }
    [[ -f $file_json ]] || { ((g_verbose)) && vMsg "Parameter error (not a file)"; return 1; }

    ((g_verbose)) && vMsg "file_json: \"$file_json\""
    ((g_verbose)) && vMsg "g_file_sed_unminify_script: \"$g_file_sed_unminify_script\""

    if [[ -w $file_json ]]; then
        if sed -i --file="$g_file_sed_unminify_script" "$file_json"; then
            ((g_verbose)) && vMsg "'sed' returned success"
            return 0
        else
            ((g_verbose)) && vMsg "'sed' returned failure"
            return 1
        fi
    else
        ((g_verbose)) && vMsg "No write access: \"$file_json\""
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Detect if a specified JSON file is minified or not. Used for debug
#          reporting only because the unminify script is run on the JSON
#          regardless of the result of this function.
# Input:   1 (required) A JSON file
# Output:  None
# Return:  0 Yes/True
#          1 No/False
IsJSONminified() {

    local file_json=${1-}
    local -i counter_lines=0

    [[ -z $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }
    [[ ! -f $file_json || ! -r $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (not a file and/or not readable)"; return 1; }

    # Get the number of newlines in the file
    counter_lines=$(wc -l -- < "$file_json")
    ((g_verbose)) && vMsg "counter_lines: \"$counter_lines\""

    # 0 is the actual value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added or if in the future
    # minified JSON is returned that has 1 newline.
    ((g_verbose)) && {
        if [[ $counter_lines -le 1 ]]; then
            vMsg "JSON is minified"
        else
            vMsg "JSON is not minified"
        fi
    }

    return $(( (counter_lines <= 1) ? 0 : 1 ))
}

###############################################################################
# Purpose: If the sed script g_file_sed_unminify_script is not found or it's size
#          in bytes does not match an expected value, create/overwrite it
# Input:   None
# Output:  None
# Return:  Always 0
CreateSedUnminifyJSONscript() {

    if [[ ! -f $g_file_sed_unminify_script ]] || [[ $(stat -c '%s' -- "$g_file_sed_unminify_script") -ne $g_size_bytes_sed_unminify_script ]]; then
        ((g_verbose)) && vMsg "'sed' script at \"$g_file_sed_unminify_script\" does not exist or is not the expected size ($g_size_bytes_sed_unminify_script)"
        cat <<"END_OF_SED_SCRIPT" > "$g_file_sed_unminify_script"
#### begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s|","|"\n"|g
#### end minimum required for ge-install-manager

# replace:  "assets": [
# with:     "assets":newline
s|"assets":\[|"assets":\n|g

# replace:  :{"
# with:     :newline"
s|:{"|:\n"|g

# replace:  "},"
# with:     "newline"
s|"},"|"\n"|g

# replace:  },"
# with:     newline"
s|},"|\n"|g

# replace:  {"
# with:     "
s|{"|"|g

#### Re-format text intended for formating ('\n') in "body_text" when media type
#### "application/vnd.github.v3.text+json" is requested
# replace:  \n
# with:     newline
s|\\n|\n|g

# replace:  ,"
# with:     newline"
s|,"|\n"|g

#### one per release listed
# replace:  "}]
# with:     "
s|"}\]|"|g

# replace:  "}
# with:     "
s|"}|"|g

#### very minor
# replace:  ["
# with:     "
s|\["|"|g
END_OF_SED_SCRIPT
    else
        ((g_verbose)) && vMsg "'sed' script already exists at g_file_sed_unminify_script and is the expected size ($g_size_bytes_sed_unminify_script)"
    fi

    return 0
}

###############################################################################
# Purpose: Check if a version is installed
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Yes/True
#          1 No/False
# NOTE: Currently only checks if a path for the version exists
# TODO: Find a better way that is reliable
IsInstalled() {

    local version

    [[ -z $1 ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    version=${1-}
    CleanUpVersion

    ((g_verbose)) && vMsg "Checking for version \"$version\" at \"$g_install_path/Proton-${version}\""

    if [[ -d $g_install_path/Proton-${version} ]]; then
        ((g_verbose)) && vMsg "Version \"$version\" found"
        return 0
    else
        ((g_verbose)) && vMsg "Version \"$version\" not found"
        return 1
    fi

    # NOTE: Do not return 0 here
}

###############################################################################
# Purpose: Check if Steam is running by checking the output of ps
# Input:   None
# Output:  None
# Return:  0 Yes/True
#          1 No/False (ps not found or Steam is not running but steamwebhelper is or unknown error)
IsSteamRunning() {

    local -i found_steam=0
    local -i found_steamwebhelper=0

    while IFS= read -r --; do
        [[ ${REPLY,,} =~ ^.*steam$ ]] && {
            found_steam=1
            ((g_verbose)) && vMsg "'steam' match: \"$REPLY\""
        }
        [[ ${REPLY,,} =~ ^.*steamwebhelper.*$ ]] && {
            found_steamwebhelper=1
            ((g_verbose)) && vMsg "'steamwebhelper' match: \"$REPLY\""
        }
    done < <(ps -e 2>/dev/null)
    #return $(( found_steam ? 1 : 0 ))

    if [[ $found_steam -eq 1 ]]; then
        return 0
    elif [[ $found_steam -eq 0 && $found_steamwebhelper -eq 1 ]]; then
        echo "Warning: at least one steamwebhelper process is still running but Steam is not"
        # TODO: report their PIDs?
        return 1
    elif [[ $found_steam -eq 0 && $found_steamwebhelper -eq 0 ]]; then
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Use curl -z to request a specified URL. If the remote URL has an mtime
#          newer than the specified file, write the response to a temporary file.
#          Check the temporary file for basic response errors and if none are found
#          copy the temporary file to the specified file. Used to update
#          g_file_latest_json and g_file_releases_json only if the remote file is newer.
# Input:   1 (required) A URL (g_latest_version_url or g_releases_url)
#          2 (required) A file (does not have to exist)
# Output:  None
# Return:  0 Success
#          1 Failure
RequestURL() {

    local requested_url=${1-}
    local file_local=${2-}
    local file_temp
    local -i downloaded_package_size_bytes=0

    file_temp=$(MkTempFile)

    [[ -z $requested_url || -z $file_local || $# -ne 2 ]] && ((g_verbose)) && vMsg "Parameter error (NULL or not exactly two)"
    [[ ! -f $file_temp || ! -w $file_temp ]] && ((g_verbose)) && vMsg "Parameter error (temp file not a file or not writeable)"

    if curl -sz "$file_local" \
            -H "$CURL_HEADER_USER_AGENT" \
            -H "$CURL_HEADER_CONTENT_TYPE" \
            -H "$CURL_HEADER_GITHUB_MEDIATYPE" \
            -L "$requested_url" \
            -o "$file_temp" 2>/dev/null; then

        ((g_verbose)) && vMsg "'curl' returned success"
        if [[ $(stat -c '%s' -- "$file_temp") -gt 0 ]]; then
            if [[ -f $file_temp && -r $file_temp ]]; then

                # Check the temporary file contents for some basic error responses
                # Not found
                downloaded_package_size_bytes=$(stat -c '%s' -- "$file_temp")
                if [[ $downloaded_package_size_bytes -eq 9 ]]; then
                    ((g_verbose)) && vMsg "RequestURL: Server responded \"Not Found\""
                    CleanUp
                    return 1
                fi

                # Github API request rate limit exceeded
                if [[ $downloaded_package_size_bytes -eq 248 ]]; then
                    ((g_verbose)) && vMsg "Github API request rate limit exceeded. Unable to retrieve remote file."
                    CleanUp
                    return 1
                fi

                # NOTE: Only the status is checked, unminify is run regardless of the result
                IsJSONminified "$file_temp"

                if ReformatJSONUsingSed "$file_temp"; then
                    ((g_verbose)) && vMsg "ReformatJSONUsingSed returned success"

                    # If the local file already exists, create a backup first
                    [[ -f $file_local ]] && CreateBackup "$file_local"
                    if cp -f -- "$file_temp" "$file_local"; then
                        ((g_verbose)) && vMsg "Copied \"$file_temp\" to \"$file_local\""
                        return 0
                    else
                        ((g_verbose)) && vMsg "Failed to copy \"$file_temp\" to \"$file_local\""
                        return 1
                    fi
                else
                    ((g_verbose)) && vMsg "ReformatJSONUsingSed returned failure"
                    return 1
                fi
            else
                ((g_verbose)) && vMsg "file_temp not found or not readable: \"$file_temp\""
                return 1
            fi
        else
            # remote file is not newer if curl returns success and the response is NULL
            ((g_verbose)) && vMsg "file_temp is size 0: \"$file_temp\""
            return 0
        fi
    else
        ((g_verbose)) && vMsg "'curl' returned failure"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Backup a file/path in tar.gz format supporting upto a configurable
#          number (n) of backups with a basename (sans extension) suffix of _n.
#          The newest backup is the lowest index (n) and the oldest backup is
#          the highest index (n). The backups are stored in the parent path of
#          the file/path to be backed up.
# Input:   1 (required) The file or path to backup
# Output:  None
# Return:  0 Success
#          1 Failure
CreateBackup() {

    local backup_target=${1-}
    local backup_target_basename
    local backup_target_path
    local file
    local -i max_backups=3
    local -i backups_counter=0
    local backup_index
    local -i flag_rename_backups=0
    local -a files_existing_backups
    shopt -s nullglob dotglob

    [[ -z $backup_target ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    ((g_verbose)) && vMsg "Backup requested for: \"$backup_target\""

    if [[ -f $backup_target ]]; then
        ((g_verbose)) && vMsg "backup_target is a file"
    else
        ((g_verbose)) && vMsg "backup_target is not a file"
        if [[ -d $backup_target ]]; then
            ((g_verbose)) && vMsg "backup_target is a path"
        else
            ((g_verbose)) && vMsg "Parameter error (not a file or a path)"
            return 1
        fi
    fi

    # If a relative file/path was given
    [[ ${backup_target:0:1} != "/" || ${backup_target:0:2} == "./" ]] && {
        ((g_verbose)) && vMsg "Resolving relative path"
        backup_target=$(realpath -- "$backup_target" 2>/dev/null)
    }

    # If backup_target is a file, get the path to it
    if [[ -f $backup_target && ! -d $backup_target ]]; then
        backup_target_path=${backup_target%/*}
    else
        # Get the parent path of the backup_target
        backup_target_path=$(realpath -- "$(dirname -- "$backup_target" 2>/dev/null)" 2>/dev/null)
    fi

    backup_target_basename=${backup_target##*/}

    # Determine the basename suffix to use {1..$max_backups}
    for file in "$backup_target_path/$backup_target_basename"_?.tar.gz; do
        if [[ $file =~ ^.*[^_]_[[:digit:]]{1}\.tar\.gz$ ]]; then
            backup_index=${file##*_}
            backup_index=${backup_index/%.tar.gz}
            ((g_verbose)) && vMsg "backup_index is $backup_index"
            [[ $backup_index =~ ^[[:digit:]]+$ ]] && {
                ((backups_counter++))
                files_existing_backups+=("$file")
                ((g_verbose)) && vMsg "Valid backup file found at \"$file\""
                if [[ $backup_index = "1" ]]; then
                    ((g_verbose)) && vMsg "backup_index 1 found, existing backups will be renamed"
                    flag_rename_backups=1
                fi
            }
        fi
    done
    ((g_verbose)) && vMsg "Found $backups_counter backups"

    if [[ $flag_rename_backups -eq 1 ]]; then
        backup_index=$backups_counter
        if [[ $backup_index -ge $max_backups ]]; then

            # Remove the oldest (highest index) backup until max_backups is reached
            while [[ $backup_index -ge $max_backups ]]; do
                if ($g_command_rm -- "${files_existing_backups[backup_index-1]}"); then
                    ((g_verbose)) && vMsg "Removed highest index greater than $max_backups: \"${files_existing_backups[backup_index-1]}\""
                    backup_index=$((backup_index-1))
                else
                    vMsg "Failed to remove backup file ${files_existing_backups[backup_index-1]}"
                    return 1
                fi
            done
        fi

        # Rename existing backups, leaving room for a new index 1 (increment each existing index by +1)
        for ((backup_index; backup_index>=1; backup_index--)); do
            if mv -- "${files_existing_backups[backup_index-1]}" "${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"; then
                ((g_verbose)) && vMsg "${files_existing_backups[backup_index-1]} renamed to ${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"
            else
                vMsg "Failed to rename backup file: \"${files_existing_backups[backup_index-1]}\""
                return 1
            fi
        done
    else
        ((g_verbose)) && vMsg "backup_index not found, not renaming backups"
    fi

    if tar -C "$backup_target_path" -cf "$backup_target_path/${backup_target_basename}_1.tar.gz" -z "$backup_target_basename"; then
        ((g_verbose)) && vMsg "Created new backup at: \"$backup_target_path/${backup_target_basename}_1.tar.gz\""
        return 0
    else
        ((g_verbose)) && vMsg "Backup failed: \"$backup_target_path/${backup_target_basename}_1.tar.gz\""
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Given a file/path (filesystem) and a unit (binary prefix), use stat
#          to calculate the remaining space on a filesystem by multiplying
#          the filesystem block size by the number of remaining blocks and
#          return the value in the unit requested.
# Input:   1 (required) File/path on the filesystem to check
#          1 (required) Binary prefix (see case below for supported formats)
# Output:  Integer value representing the space remaining in the unit requested
#          NOTE: Bash arithmatic is used because this script does not require
#                   the precision afforded by bc/etc.
# Return:  0 Success
#          1 Failure
# NOTE: bash arithmatic supports upto 1024^6/1024**6 (exbibyte)
# TODO: Add a third, optional parameter to request calculations using bc
SpaceRemaining() {

    local file_system=${1-}
    local binary_prefix=${2-}
    local -i power_of=0

    [[ -z $file_system || -z $binary_prefix ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    [[ ! -d $file_system ]] && { ((g_verbose)) && vMsg "Parameter error (not a directory)"; return 1; }

    case ${binary_prefix,,} in
        (b|byte|bytes) power_of=0 ;;
        (k|kibi|kibibyte) power_of=1 ;;
        (m|mebi|mebibyte) power_of=2 ;;
        (g|gibi|gibibyte) power_of=3 ;;
        (t|tebi|tebibyte) power_of=4 ;;
        (p|pebi|pebibyte) power_of=5 ;;
        (e|exbi|exbibyte) power_of=6 ;;
    esac

    ((g_verbose)) && vMsg "Checking \"$file_system\""

    printf '%s' "$(( ($(stat -L --cached=never -c '%s' -f -- "$file_system") * $(stat -L --cached=never -c '%a' -f -- "$file_system")) / ( 1024 ** power_of ) ))"

    return $(( $? ? 1 : 0 )) # TODO: Does builtin printf have return values other than 0 or 1?
}

###############################################################################
# Purpose: If g_file_script_config is not found, create a default
# Input:   None
# Output:  None
# Return:  Always 0
CreateDefaultConfigFile() {

    cat <<DEFAULT_CONFIG > "$g_file_script_config" # This section is subject to expansion, etc.
#
# $SCRIPT_FULL_NAME v$SCRIPT_VERSION Default configuration file
#
# Quick start format:
# #comment
# key=value #comment
#
# Lines begining with an octothorpe "#" are considered comment lines and are ignored.
# Any characters that follow a space and an octothorpe " #" are considered comments.
# Empty lines and lines that begin with space/tab are ignored.
# Lines that contain one or more semi-colon(s) ";" will be ignored.
# Lines that contain potential escape sequences are ignored.
# A key with a null value and a value with a null key are ignored (eg. "key=" and "=value").
#
# Paths (install, cache, and tmp) do not have to exist but
# the script will need write permission to create them for you.
#
# When install_path is set to the special value "auto", the script will
# attempt to auto-detect the Steam installation path.
#
# Environment variables and script global variables will be expanded.
# \$SCRIPT_FULL_NAME is a script global variable that is always set to the basename of the script.
# Setting tmp_path to the same path as install_path is currently not supported (eg. tmp_path=\$g_install_path).
#
# Do not quote variables outside parameter expansions (:+, :-, :=, or :?) unless
# you want the quotes included in the value.
#
DEFAULT_CONFIG

    cat <<"DEFAULT_CONFIG" >> "$g_file_script_config" # This section is not subject to expansion, etc.

# Default install path
install_path=auto

# Default cache path
cache_path=${XDG_CACHE_HOME:-"$HOME"/.cache}/$SCRIPT_FULL_NAME

# Default command used instead of rm (for removing all but temporary files)
# NOTE: Any command and its parameters that support the last parameter being either a file or a path is supported
rm_command=trash

# Default URL used to retrieve 'latest' JSON
latest_version_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest

# Default URL used to retrieve 'releases' JSON
releases_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases

# Default temporary file path
tmp_path=/tmp
DEFAULT_CONFIG

    return 0
}


###############################################################################
# Purpose: Parse the config file set in the global variable g_file_script_config,
#          validate recognized key/value pairs and then set/reset global
#          variables accordingly.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Runs DetectSteamInstallPath if g_install_path is set to the special value "auto"
ParseConfigFile() {

    local -i existing_config_file_lines=0
    local -i counter_config_line=0
    local -i flag_failed=0
    local -i flag_update_install_path=0
    local config_key
    local config_value

    existing_config_file_lines=$(wc -l 2>/dev/null < "$g_file_script_config") # NOTE: do not || return 1 here

    # If existing_config_file_lines is empty, create a default config file
    [[ -z $existing_config_file_lines ]] && {
        ((g_verbose)) && vMsg "Generating a default config file at: \"$g_file_script_config\""
        if CreateDefaultConfigFile; then
            ((g_verbose)) && vMsg "CreateDefaultConfigFile returned success"
            echo "Default configuration created at \"$g_file_script_config\""
            if [[ -n ${EDITOR-} ]]; then
                ((g_verbose)) && vMsg "EDITOR is set to: \"$EDITOR\""
                while :; do
                    read -rp "Would you like to open it with ${EDITOR}? " </dev/tty
                    case ${REPLY,,} in
                        ("y"|"yes") ($EDITOR "$g_file_script_config"); exit 0 ;;
                        ("n"|"no") exit 0 ;;
                        ("*") echo "Enter (y)es or (n)o" ;;
                    esac
                done
            else
                echo "EDITOR not set, default configuration created at \"$g_file_script_config\""
            fi
            exit 0
        else
            # NOTE: CreateDefaultConfigFile currently always returns 0
            ((g_verbose)) && vMsg "CreateDefaultConfigFile returned failure status"
            return 1
        fi
    }

    ((g_verbose)) && vMsg "g_file_script_config \"$g_file_script_config\" contains $existing_config_file_lines newlines"

    # Sanity checks
    [[ -z $g_file_script_config || ! -f $g_file_script_config || ! -w $g_file_script_config ]] && {
        ((g_verbose)) && vMsg "g_file_script_config error (NULL, not a file, or not writeable)"
        return 1
    }

    # Begin parsing g_file_script_config
    while IFS= read -r --; do

        # Increment the line counter
        ((counter_config_line++))

        # Ignore lines that begin with a # (comments)
        [[ $REPLY =~ ^#.*$ ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (begins with a \"#\")"; continue; }

        # Ignore lines that contain one or more semi-colon ";". Anti-exploit measure.
        [[ $REPLY =~ ^.*\;+.*$ ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (contains one or more \";\")"; continue; }

        # Ignore lines containing potential escape sequences. Anti-exploit measure.
        [[ $REPLY =~ ^.*\\[[:digit:]]+\[.*$ ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (contains potential escape code)"; continue; }

        # Trim away inline comments
        if [[ $REPLY =~ ^.*#.*$ ]]; then
            ((g_verbose)) && vMsg "Partially commented line $counter_config_line: \"$REPLY\""
            # remove the ' #' and everything to the right of it
            # NOTE: valid comments are preceded by at least one [[:blank:]]
            # BUG: this will mangle herestrings that contain comments
            REPLY=${REPLY%%[[:blank:]]#*}
        fi

        # Ignore lines that are empty
        [[ -z $REPLY ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (empty)"; continue; }

        # Ignore lines that don't contain exactly one = and also don't have characters on either side of the = sign. If there are characters on either
        # side of the = sign, they may not be spaces or tabs
        [[ $REPLY =~ ^[^=[:blank:]]+=[^=[:blank:]]+$ ]] || { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (improperly formatted)"; continue; }

        ((g_verbose)) && vMsg "Potentially valid config line ($counter_config_line): \"$REPLY\""

        # Get the key (the characters to the left of the equals "=" sign)
        config_key=${REPLY%%=*}

        # Get the value (the characters to the right of the equals "=" sign)
        config_value=${REPLY#*=}

        ((g_verbose)) && vMsg "config line $counter_config_line - Key: \"$config_key\" Value: \"$config_value\""

        # Expand any variables in the config using envsubst or eval
        # Skip expansion if the value doesn't contain one or more $
        if [[ $config_value =~ ^.+[$]+.+$ ]]; then
            if [[ $config_value =~ ^.+:[+-=?]{1}.+$ ]]; then
                ((g_verbose)) && vMsg "Using 'eval' to expand config_value: \"$config_value\""
                config_value=$(eval printf '%s' "$config_value")
                ((g_verbose)) && vMsg "config_value expanded to: \"$config_value\""
            else
                if command -v envsubst &>/dev/null; then
                    ((g_verbose)) && vMsg "Using 'envsubst' to expand config_value: \"$config_value\""
                    config_value=$(envsubst <<< "$config_value")

                    # If there is still a $ in config_value it contained a variable envsubst couldn't expand
                    [[ $config_value =~ ^.*\$+.*$ ]] && {
                        ((g_verbose)) && vMsg "config_value still contains one or more $ after envsubst"
                        config_value=$(eval printf '%s' "$config_value")
                        ((g_verbose)) && vMsg "config_value expanded again with 'eval' to: \"$config_value\""
                    }
                    ((g_verbose)) && vMsg "config_value expanded to: \"$config_value\""
                else
                    ((g_verbose)) && vMsg "Command 'envsubst' not available, using 'eval' to expand config_value: \"$config_value\""
                    config_value=$(eval printf '%s' "$config_value")
                    ((g_verbose)) && vMsg "config_value expanded to: \"$config_value\""
                fi
            fi
        else
            # No $ were found, no expansion necessary
            ((g_verbose)) && vMsg "Skipping expansion of config_value: \"$config_value\""
        fi

        # Validate values for recognized keys and set global variables accordingly
        case $config_key in
            (install_path)
                # If the value for install_path is the special value "auto", attempt to auto detect the steam install path
                # NOTE: If one is found/chosen the global variable g_override_default_install_path will be set accordingly.
                #       A value of NULL indicates a problem, error, or user chose manual configuration in which case
                #       the value will remain auto.
                [[ ${config_value,,} = "auto" ]] && {
                    ((g_verbose)) && vMsg "$config_key is set to $config_value, Running DetectSteamInstallPath"
                    DetectSteamInstallPath
                    if [[ -n $g_override_default_install_path && ${g_override_default_install_path,,} != "auto" ]]; then
                        config_value=$g_override_default_install_path/compatibilitytools.d
                        flag_update_install_path=1
                    else
                        return 1
                    fi
                }
                if [[ -d $config_value && -w $config_value ]]; then
                    ((g_verbose)) && vMsg "$config_value is a directory and the script has write permission to it"
                    g_install_path=$config_value
                    flag_update_install_path=1
                else
                    ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((g_verbose)) && vMsg "script has write permission to config_value"
                            g_install_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                            flag_failed=1
                            flag_update_install_path=0
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                        flag_failed=1
                        flag_update_install_path=0
                    fi
                fi
            ;;
            # Changing the config_path is currently not supported
            #(config_path)
            #    ## If config_path would = g_install_path
            #    if [[ $config_value -ef $g_install_path ]]; then
            #        vMsg "config_path is the same as g_install_path"
            #    fi
            #    if [[ -d $config_value && -w $config_value ]]; then
            #        ((g_verbose)) && vMsg "$config_value is a directory and the script has write permission to it"
            #        g_script_config_path=$config_value
            #    else
            #        ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
            #        if mkdir -p -- "$config_value" &>/dev/null; then
            #            if [[ -w $config_value ]]; then
            #                ((g_verbose)) && vMsg "script has write permission to config_value"
            #                g_script_config_path=$config_value
            #            else
            #                vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
            #                flag_failed=1
            #            fi
            #        else
            #            vMsg "ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
            #            flag_failed=1
            #        fi
            #    fi
            #;;
            (cache_path)
                if [[ -d $config_value && -w $config_value ]]; then
                    ((g_verbose)) && {
                        # If cache_path would = g_install_path
                        if [[ $config_value -ef $g_install_path ]]; then
                            vMsg "cache_path is the same as g_install_path"
                        else
                            vMsg "$config_value is a directory and the script has write permission to it"
                        fi
                    }
                    g_script_cache_path=$config_value
                else
                    ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((g_verbose)) && vMsg "script has write permission to config_value"
                            g_script_cache_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                            flag_failed=1
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                        flag_failed=1
                    fi
                fi
            ;;
            (tmp_path) # g_temp_base_path
                # If tmp_path would = g_install_path (would cause issues with VerifyGEInstall)
                [[ $config_value -ef $g_install_path ]] && {
                    vMsg "Setting tmp_path and g_install_path to the same path is not supported"
                    flag_failed=1
                }
                if [[ -d $config_value && -w $config_value ]]; then
                    ((g_verbose)) && vMsg "$config_value is a directory and the script has write permission to it"
                    g_temp_base_path=$config_value
                else
                    ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((g_verbose)) && vMsg "script has write permission to config_value"
                            g_temp_base_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                            flag_failed=1
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                        flag_failed=1
                    fi
                fi
            ;;
            (rm_command)
                if (command -v -- "$config_value" &>/dev/null); then
                    g_command_rm=$config_value
                    ((g_verbose)) && vMsg "g_command_rm set to: \"$g_command_rm\""
                else
                    ((g_verbose)) && vMsg "command -v \"$config_value\" failed"
                    vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\"" \
                    vMsg "If you don't want the script to use 'rm' then fix it"
                    g_command_rm='rm'
                fi
            ;;
            (latest_version_url)
                if curl -sLI -- "$config_value" &>/dev/null; then
                    g_latest_version_url=$config_value
                    ((g_verbose)) && vMsg "g_latest_version_url set to: \"$g_latest_version_url\""
                else
                    vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                    flag_failed=1
                fi
            ;;
            (releases_url)
                if curl -sLI -- "$config_value" &>/dev/null; then
                    g_releases_url=$config_value
                    ((g_verbose)) && vMsg "g_releases_url set to: \"$g_releases_url\""
                else
                    vMsg "Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                    flag_failed=1
                fi
            ;;
            (*)
                ((g_verbose)) && vMsg "No key match for valid config ($counter_config_line): \"$REPLY\""
            ;;
        esac
    done < "$g_file_script_config"

    # Update install_path in the configuration file if necessary
    [[ $flag_update_install_path -eq 1 ]] && {
        [[ -n ${g_override_default_install_path-} ]] && {
            g_install_path=$g_override_default_install_path/compatibilitytools.d
            [[ -f $g_file_script_config ]] && CreateBackup "$g_file_script_config"
            sed -i "s|install_path=auto|install_path=$g_install_path|" -- "$g_file_script_config"
        }
    }

    # If any crucial config options are empty (missing from config, except g_script_config_path)
    [[ -z ${g_install_path-} ]] && {
        vMsg "Invalid/missing g_install_path ($g_file_script_config)"
        return 1
    }

    [[ -z ${g_temp_base_path-} ]] && {
        vMsg "Invalid/missing g_temp_base_path ($g_file_script_config)"
        return 1
    }

    # A warning in case the default global variable is manually changed
    [[ -z ${g_script_config_path-} ]] && {
        vMsg "Invalid/missing g_script_config_path"
        return 1
    }

    [[ -z ${g_script_cache_path-} ]] && {
        vMsg "Invalid/missing g_script_cache_path ($g_file_script_config)"
        return 1
    }

    # Debug report
    ((g_verbose)) && vMsg "Install path set to: \"$g_install_path\""
    ((g_verbose)) && vMsg "Temp path set to: \"$g_temp_base_path\""
    ((g_verbose)) && vMsg "Config path set to: \"$g_script_config_path\"" # NOTE: config_path is currently not configurable
    # update global variables that depend on this one
    #g_file_script_config=$g_script_config_path/$SCRIPT_FULL_NAME.conf
    #((g_verbose)) && vMsg "g_file_script_config set to: \"$g_file_script_config\""
    #((g_verbose)) && vMsg "g_file_sed_unminify_script set to: \"$g_file_sed_unminify_script\""

    ((g_verbose)) && vMsg "Cache path set to: \"$g_script_cache_path\""
    # update global variables that depend on this one
    g_file_latest_json="$g_script_cache_path"/latest.json
    ((g_verbose)) && vMsg "g_file_latest_json set to: \"$g_file_latest_json\""

    g_file_releases_json="$g_script_cache_path"/releases.json
    ((g_verbose)) && vMsg "g_file_releases_json set to: \"$g_file_releases_json\""

    return $(( flag_failed ? 1 : 0 ))
}

###############################################################################
# Purpose: When invoked, "clean" a version string stored in the variable version.
# Input:   None
# Output:  None
# Return:  Always 0
CleanUpVersion() {

    local -i length_characters=0

    [[ -z $version ]] && { ((g_verbose)) && vMsg "version is NULL"; printf ''; return 1; }

    [[ $g_verbose -eq 1 ]] && {
        length_characters=${#version}
        vMsg "Before: \"$version\""
    }

    # global upper case
    version=${version^^}

    # anchored left, remove a single "PROTON-" and anything to the left of it
    version=${version#*'PROTON-'}

    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    version=${version%'.TAR.GZ'*}

    [[ $g_verbose -eq 1 ]] && {
        vMsg "After: \"$version\""
        [[ $length_characters -ne ${#version} ]] && vMsg "Removed $(( length_characters - ${#version} )) characters"
    }

    return 0
}

###############################################################################
# Purpose: Bash only primitive replacement for mktemp (file version)
# Input:   None
# Output:  A string containing a path and file with no trailing newline (stdout)
# Return:  0 (Success)
#          1 (Failure)
MkTempFile() {

    local create_temp_file

    [[ -d $g_temp_base_path && -w $g_temp_base_path ]] || {
        ((g_verbose)) && vMsg "g_temp_base_path is not a valid path or no write access: \"$g_temp_base_path\""
        return 1
    }

    create_temp_file=$g_temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16)

    ((g_verbose)) && vMsg "Created temp file at: \"$create_temp_file\""

    # Create the empty temp file
    printf '' > "$create_temp_file" || return 1

    # "Return" the path and filename,
    printf '%s' "$create_temp_file"

    return 0
}

###############################################################################
# Purpose: Bash only primitive replacement for mktemp (path version)
# Input:   None
# Output:  A string containing a path with no trailing newline (stdout)
# Return:  0 (Success)
#          1 (Failure)
MkTempPath() {

    local create_temp_path

    [[ -d $g_temp_base_path && -w $g_temp_base_path ]] || {
        ((g_verbose)) && vMsg "g_temp_base_path is not a valid path or no write access: \"$g_temp_base_path\""
        return 1
    }

    create_temp_path=$g_temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16) || return 1

    ((g_verbose)) && vMsg "Created temp path at: \"$create_temp_path\""

    # Create the path
    mkdir -p "$create_temp_path" &>/dev/null || return 1

    # "Return" the path and filename,
    printf '%s' "$create_temp_path"

    return 0
}

###############################################################################
# Purpose: Generate a pseudo-random alphanumeric string using only Bash
# Input:   1 (optional) An integer indicating the length of the sequence to generate
# Output:  A string containing the generated alphanumeric sequence (stdout)
# Return:  0 (Success)
#          1 (Failure)
# NOTE: Valid input length range 1-32767 (default: 10)
GenerateRandomAlphaNumericString() {

    local list
    local -i length=${1:-10}
    local result='' # NOTE: Must be initialized as NULL
    local character
    local -i i

    list=$(printf '%s' {a..z}{0..9}{A..Z}) || return 1

    # If the length requested is outside sane upper and lower bounds, reset it
    [[ $length -lt 1 ]] && length=1
    [[ $length -gt 32767 ]] && length=32767

    # Loop length times
    for (( i=1; i<=length; i++ )); do

        # Randomly choose one offset of length one from list
        character=${list:$RANDOM%${#list}:1}

        # Randomly invert the case
        (( RANDOM % 2 )) && character=${character~}

        # Concatenate result and character
        result=${result}${character}

    done

    # "Return" the resulting string,
    # meant to be captured using command substitution
    # eg. sSTRING_OF_LENGTH_TEN=$(GenerateRandomAlphaNumericString 10)
    printf '%s' "$result"

    return 0
}

###############################################################################
# Purpose: Attempt to auto-detect the Steam installation path and set the
#          global variable g_override_default_install_path to it. That variable
#          is then read by ParseConfigFile to set g_install_path in the config
#          file. If multiple potential install paths are detected the user will
#          be prompted to choose one of them. If none/exit is chosen or an abort
#          occurs install_path will remain set to auto.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: ~/.steam/root/compatibilitytools.d                                   # proton-ge-custom install notes
#       /usr/share/steam/compatibilitytools.d
#       /usr/local/share/steam/compatibilitytools.d
# flatpak
#       ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/  # proton-ge-custom install notes
#       ~/.var/app/com.valvesoftware.Steam/.local/share/Steam
#       ~/.var/app/com.valvesoftware.Steam/.steam
#       ~/.steam/root/compatibilitytools.d (steam install folder symlink) || ~/.local/share/Steam/compatibilitytools.d
# TODO: Colon-separated global paths in $STEAM_EXTRA_COMPAT_TOOLS_PATHS
DetectSteamInstallPath () {

    local -i i=0
    local check_path
    local -a valid_paths
    local -a search_paths=("$HOME/.steam/root" \
                           "${XDG_DATA_HOME:-$HOME/.local/share/Steam}" \
                           "/usr/share/steam" \
                           "/usr/local/share/steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/data/Steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/.local/share/Steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/.steam")

    #sSTEAMSH=$(find / -xdev -type f -name "steam.sh" ! -path "/dev/*" ! -path "/proc/*" 2>/dev/null)
    #sSTEAMCOMPATTOOLSD=$(find / -xdev -type d -name "compatibilitytools.d" ! -path "/dev/*" ! -path "/proc/*" 2>/dev/null)

    # Report the set status of XDG vars
    # XDG_DATA_HOME
    if [[ ${XDG_DATA_HOME-unset} != 'unset' ]]; then
        if [[ ${XDG_DATA_HOME-} != "$HOME"/.local/share ]]; then
            ((g_verbose)) && vMsg "XDG_DATA_HOME is not set to the default: \"$XDG_DATA_HOME\""
        else
            ((g_verbose)) && vMsg "XDG_DATA_HOME is set to: \"$XDG_DATA_HOME\""
        fi
    else
        ((g_verbose)) && vMsg "XDG_DATA_HOME is unset"
    fi

    # XDG_CONFIG_HOME
    if [[ ${XDG_CONFIG_HOME-unset} != 'unset' ]]; then
        if [[ ${XDG_CONFIG_HOME-} != "$HOME"/.config ]]; then
            ((g_verbose)) && vMsg "XDG_CONFIG_HOME is not set to the default: \"$XDG_CONFIG_HOME\""
        else
            ((g_verbose)) && vMsg "XDG_CONFIG_HOME is set to: \"$XDG_CONFIG_HOME\""
        fi
    else
        ((g_verbose)) && vMsg "XDG_CONFIG_HOME is unset"
    fi

    # XDG_CACHE_HOME
    if [[ ${XDG_CACHE_HOME-unset} != 'unset' ]]; then
        if [[ ${XDG_CACHE_HOME-} != "$HOME"/.cache ]]; then
            ((g_verbose)) && vMsg "XDG_CACHE_HOME is not set to the default: \"$XDG_CACHE_HOME\""
        else
            ((g_verbose)) && vMsg "XDG_CACHE_HOME is set to: \"$XDG_CACHE_HOME\""
        fi
    else
        ((g_verbose)) && vMsg "XDG_CACHE_HOME is unset"
    fi

    # Search each known possible, existing Steam g_install path path for steam.sh
    #
    # ~/.steam/root/compatibilitytools.d
    ((g_verbose)) && vMsg "search_paths: ${#search_paths[@]}"
    for check_path in "${search_paths[@]}"; do
        ((g_verbose)) && vMsg "Checking \"$check_path\""
        if [[ -f $check_path/steam.sh ]]; then
            ((g_verbose)) && vMsg "steam.sh found in $check_path"
            valid_paths+=("$check_path")
        else
            ((g_verbose)) && vMsg "steam.sh not found in $check_path"
        fi
    done

    ((g_verbose)) && vMsg "#valid_paths: ${#valid_paths[@]}"
    ((g_verbose)) && vMsg "valid_paths[*]: ${valid_paths[*]}"

    if [[ ${#valid_paths[@]} -eq 0 ]]; then
        printf '%s\n%s\n%s\n' \
               "ERROR: Unable to detect Steam installation path" \
               "You will need to configure g_install_path manually in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        g_override_default_install_path=''

    # Prefer to use the symlink if two paths were found and one is a link to the other
    elif [[ ${#valid_paths[@]} -eq 1 ]] || [[ ${#valid_paths[@]} -eq 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]; then
        printf '%s\n%s\n%s\n' \
               "Steam g_install path detected as \"${valid_paths[0]}\"" \
               "If that path is incorrect, manually adjust g_install_path in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        g_override_default_install_path=${valid_paths[0]}

    # Multiple paths detected with or without the Steam home link pointing to one of them
    elif [[ ${#valid_paths[@]} -gt 1 && ! ${valid_paths[0]} -ef ${valid_paths[1]} ]] || [[ ${#valid_paths[@]} -gt 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]; then
        echo "Multiple Steam g_install paths detected:"
        for (( i=0; i < ${#valid_paths[@]}; i++ )); do
            echo "($(( i + 1 ))) ${valid_paths[i]}"
        done

        echo "Choose a path from above or enter exit/quit"
        while :; do
            read -rp "Enter a number from 1-${#valid_paths[@]}: " </dev/tty
            [[ $REPLY = @(exit|quit) ]] && {
                g_override_default_install_path=''
                break
            }
            REPLY=${REPLY//[!0-9]/} # Remove characters that are not {0..9}
            case $REPLY in
                (*[[:digit:]]*) # TODO: Make this case test more precise
                    if [[ $REPLY -lt 1 || $REPLY -ge $(( ${#valid_paths[@]} + 1 )) ]]; then
                        echo "Invalid choice"
                    else
                        ((g_verbose)) && vMsg "Setting g_override_default_install_path to \"${valid_paths[$((REPLY-1))]}\""
                        g_override_default_install_path=${valid_paths[$((REPLY-1))]}
                        printf '%s\n%s\n%s\n' \
                               "You have chosen the path \"$g_override_default_install_path\"" \
                               "If that is not correct adjust g_install_path in the configuration file accordingly" \
                               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
                        ((g_verbose)) && vMsg "g_override_default_install_path set to \"$g_override_default_install_path\""
                        break
                    fi
                ;;
                (*) echo "Invalid choice" ;;
            esac
        done

        [[ -z $g_override_default_install_path ]] && {
            printf '%s\n%s\n' \
                   "You will need to manually set g_install_path in the configuration file" \
                   "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
            g_override_default_install_path="auto"
        }
    fi

    return 0
}

###############################################################################
# Purpose: Ensure critical paths exist and that the script has the required
#          permissions to each of them. Additionally, in case the shebang is
#          changed from /usr/bin/env bash, aliases for commands used by the
#          script are checked and unset if needed to avoid potential undefined
#          behavior.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
SetupEnvironment() {

    local -i flag_failed=0
    local -i count_success=0
    local -i count_failed=0
    local -a check_alias_commands=(curl sed tar gzip stat wc date du ps sort cmp envsubst fallocate trash)

    # Check for and unset existing aliases for commands used in the script
    # that could cause undefined behavior
    # NOTE: This is not needed so long as the shebang remains /usr/bin/env bash
    for check_alias in "${check_alias_commands[@]}"; do
        result=$(alias "$check_alias" 2>&1)
        [[ $result == *"${check_alias}="* && $result != *'not found'* ]] && {
            ((g_verbose)) && vMsg "Found alias for $check_alias: \"$result\""
            echo "WARNING: Alias detected for $check_alias (it will be unset to avoid undefined behavior)"
            if ! unalias "$check_alias"; then
                ((g_verbose)) && vMsg "unalias \"$check_alias\" failed"
                flag_failed=1
            fi
            count_failed=$(( count_failed + 1 ))
            continue
        }
        ((g_verbose)) && vMsg "No alias found for \"$check_alias\""
        count_success=$(( count_success + 1 ))
    done
    ((g_verbose)) && vMsg "$(( count_success + count_failed )) aliases checked"

    # g_install_path
    if [[ -d $g_install_path ]]; then
        ((g_verbose)) && vMsg "Found existing install path at \"$g_install_path\""
        if [[ -w $g_install_path ]]; then
            ((g_verbose)) && vMsg "Script has write access to g_install_path"
        else
            ((g_verbose)) && vMsg "Script does not have write access to g_install_path"
            echo "Invalid install path: \"$g_install_path\""
            flag_failed=1
        fi
    elif [[ ! -d $g_install_path ]]; then
        ((g_verbose)) && vMsg "g_install_path not found. Creating at \"$g_install_path\""
        if mkdir -p -- "$g_install_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create install path succeeded"
        else
            ((g_verbose)) && vMsg "Create install path failed"
            echo "Invalid g_install path: \"$g_install_path\""
            flag_failed=1
        fi
    fi

    # g_script_config_path
    if [[ -d $g_script_config_path ]]; then
        ((g_verbose)) && vMsg "Found existing g_script_config_path at \"$g_script_config_path\""
        if [[ -w $g_script_config_path ]]; then
            ((g_verbose)) && vMsg "Script has write access to g_script_config_path"
        else
            ((g_verbose)) && vMsg "Script does not have write access to g_script_config_path"
            echo "Invalid config path: \"$g_script_config_path\""
            flag_failed=1
        fi
    elif [[ ! -d $g_script_config_path ]]; then
        ((g_verbose)) && vMsg "g_script_config_path not found. Creating at \"$g_script_config_path\""
        if mkdir -p -- "$g_script_config_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create config path succeeded"
        else
            ((g_verbose)) && vMsg "Create config path failed"
            echo "Invalid config path: \"$g_script_config_path\""
            flag_failed=1
        fi
    fi

    # g_script_cache_path
    if [[ -d $g_script_cache_path ]]; then
        ((g_verbose)) && vMsg "Found existing g_script_cache_path at \"$g_script_cache_path\""
        if [[ -w $g_script_cache_path ]]; then
            ((g_verbose)) && vMsg "Script has write access to g_script_cache_path"
        else
            ((g_verbose)) && vMsg "Script does not have write access to g_script_cache_path"
            echo "Invalid cache path: \"$g_script_cache_path\""
            flag_failed=1
        fi
    elif [[ ! -d $g_script_cache_path ]]; then
        ((g_verbose)) && vMsg "g_script_cache_path not found. Creating at \"$g_script_cache_path\""
        if mkdir -p -- "$g_script_cache_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create cache path succeeded"
        else
            ((g_verbose)) && vMsg "Create cache path failed"
            echo "Invalid cache path: \"$g_script_cache_path\""
            flag_failed=1
        fi
    fi

    # g_file_script_config
    if [[ -f $g_file_script_config ]]; then
        ((g_verbose)) && vMsg "Found existing g_file_script_config at \"$g_file_script_config\""
        if [[ -w $g_file_script_config ]]; then
            ((g_verbose)) && vMsg "Script has write access to g_file_script_config"
        else
            ((g_verbose)) && vMsg "Script does not have write access to g_file_script_config"
            echo "No write access to config file: \"$g_file_script_config\""
            flag_failed=1
        fi
        if [[ -r $g_file_script_config ]]; then
            ((g_verbose)) && vMsg "Script has read access to g_file_script_config"
        else
            ((g_verbose)) && vMsg "Script does not have read access to g_file_script_config"
            echo "No read access to config file: \"$g_file_script_config\""
            flag_failed=1
        fi
    elif [[ ! -f $g_file_script_config ]]; then
        ((g_verbose)) && vMsg "g_file_script_config not found. Creating at \"$g_file_script_config\""
        if printf '' > "$g_file_script_config"; then
            ((g_verbose)) && vMsg "Create script config file succeeded"
        else
            ((g_verbose)) && vMsg "Create script config file failed"
            echo "Failed to create config file: \"$g_file_script_config\""
            flag_failed=1
        fi
    fi

    # g_temp_base_path
    if [[ -d $g_temp_base_path ]]; then
        ((g_verbose)) && vMsg "Found existing g_temp_base_path at \"$g_temp_base_path\""
        if [[ -w $g_temp_base_path ]]; then
            ((g_verbose)) && vMsg "Script has write access to g_temp_base_path"
        else
            ((g_verbose)) && vMsg "Script does not have write access to g_temp_base_path"
            echo "Invalid tmp_path path: \"$g_temp_base_path\""
            flag_failed=1
        fi
    elif [[ ! -d $g_temp_base_path ]]; then
        ((g_verbose)) && vMsg "g_temp_base_path not found. Creating at \"$g_temp_base_path\""
        if mkdir -p -- "$g_temp_base_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create cache path succeeded"
        else
            ((g_verbose)) && vMsg "Create cache path failed"
            echo "Invalid tmp_path path: \"$g_temp_base_path\""
            flag_failed=1
        fi
    fi

    # Remove 0 size g_file_latest_json
    [[ -f $g_file_latest_json ]] && {
        [[ $(stat -c '%s' -- "$g_file_latest_json" 2>/dev/null) -eq 0 ]] && {
            ((g_verbose)) && vMsg "g_file_latest_json is size 0, removing"
            if ! rm -f -- "$g_file_latest_json"; then
                flag_failed=1
            fi
        }
    }

    # Remove 0 size g_file_releases_json
    [[ -f $g_file_releases_json ]] && {
        [[ $(stat -c '%s' -- "$g_file_releases_json" 2>/dev/null) -eq 0 ]] && {
            ((g_verbose)) && vMsg "g_file_releases_json is size 0, removing"
            if ! rm -f -- "$g_file_releases_json"; then
                flag_failed=1
            fi
        }
    }

    return $(( flag_failed ? 1 : 0 ))
}

###############################################################################
# Purpose: Check for minimum required external commands for basic functionality
#          and report if any are missing.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
CheckRequirements() {

    local -i flag_failed=0
    local -a required_commands=(curl sed tar gzip stat wc)

    while IFS= read -r --; do
        [[ ${REPLY,,} == *'is'* ]] && { ((g_verbose)) && vMsg "$REPLY"; continue; }
        [[ ${REPLY,,} == *'not found'* ]] && {
            REPLY=${REPLY#*:} # remove script_name:
            REPLY=${REPLY#*:} # remove lineno:
            # Remove a leading space if found
            [[ ${REPLY:0:1} = [[:blank:]] ]] && REPLY=${REPLY/#[[:blank:]]}
            echo "Required $REPLY"
            flag_failed=1
        }
    done < <(command -V -- "${required_commands[@]}" 2>&1)

    if [[ $flag_failed -eq 0 ]]; then
        ((g_verbose)) && vMsg "All required commands found"
    elif [[ $flag_failed -eq 1 ]]; then
        ((g_verbose)) && vMsg "One or more required commands not found"
    fi

    return $(( flag_failed ? 1 : 0 ))
}

###############################################################################
# Purpose: Print a supplied message to stderr and prefix that message with the
#          line number that called this function followed by a function trace
#          that excludes "main". Similar to the caller built-in.
# Input:   1 (required) A string (the message to output)
# Output:  None
# Return:  Always 0
vMsg() {

    # If g_verbose != 1, do nothing
    [[ $g_verbose -eq 1 ]] || { echo "($LINENO) vMsg: Error: g_verbose is not 1 but vMsg was called from line ${BASH_LINENO[0]}"; return 0; }
    [[ -z ${1-} ]] && { echo "($LINENO)[vMsg]: Parameter error (NULL)" 1>&2; return 1; }

    local -i i

    # Calling line number
    printf '%s' "(${BASH_LINENO[0]})[" 1>&2
    for (( i=$(( ${#FUNCNAME[@]} - 2 )); i>1; i-- )); do
        # Function trace (excluding 'main')
        printf '%s' "${FUNCNAME[i]}," 1>&2
    done
    # The last function in the function trace doesn't get a comma suffix
    printf '%s' "${FUNCNAME[i]}]: " 1>&2
    # Message
    printf '%s\n' "$1" 1>&2

    return 0
}

###############################################################################
# Purpose: Provide a basic diagnostic tool that reports environment information.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>&1; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip ps stat sed cmp sort envsubst printf

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: \"$PWD\""
    echo "SHELL: \"$SHELL\""
    echo "SHELLOPTS: \"$SHELLOPTS\""
    echo "SHLVL: \"$SHLVL\""
    echo "BASH_VERSINFO: \"${BASH_VERSINFO[*]}\""
    echo "BASH_VERSION: \"$BASH_VERSION\""
    echo "MACHTYPE: \"$MACHTYPE\""
    echo "OSTYPE: \"$OSTYPE\""
    echo "PROMPT_COMMAND: \"$PROMPT_COMMAND\""
    echo "LANG: \"$LANG\""
    echo "LC_MESSAGES: \"$LC_MESSAGES\""
    echo "LC_ALL: \"$LC_ALL\""
    echo "EUID: \"$EUID\""
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Purpose: Provide a function to test new features and/or changes independent
#          of the rest of the script.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Exactly -fzT invokes this function
# All hope abandon, ye who enter here!
ProvingGrounds() {

    [[ $g_integration_testing -eq 1 ]] || return 1

    exit
}

###############################################################################
# Purpose: Remove any temporary files/paths created by the script if g_verbose mode
#          is not enabled
# Input:   None
# Output:  None
# Return:  Always 0
CleanUp() {

    local node

    # If SIGINT was caught, attempt to prevent the cleanup from being interupted
    [[ $g_flag_sigint_caught -eq 1 ]] && trap '' ABRT CHLD FPE INT QUIT TERM TSTP USR1 USR2 TRAP CONT HUP

    for node in "$g_temp_base_path/$TEMP_PREFIX"*; do
        # Paths
        [[ -d $node ]] && {
            ((g_verbose)) && vMsg "Temporary path found at \"$node\""
            if [[ $g_verbose -eq 1 ]]; then
                ((g_verbose)) && vMsg "Debug enabled. Temporary path not removed."
            else
                if rm -fr -- "$node" &>/dev/null; then
                    ((g_verbose)) && vMsg "Temporary path removed"
                else
                    vMsg "Failed to remove temporary path: \"$node\""
                fi
            fi
        }

        # Files
        [[ -f $node ]] && {
            ((g_verbose)) && vMsg "Temp file found at \"$node\""
            if [[ $g_verbose -eq 1 ]]; then
                ((g_verbose)) && vMsg "Debug enabled. Temporary file not removed."
            else
                if rm -f -- "$node" &>/dev/null; then
                    ((g_verbose)) && vMsg "Temporary file removed"
                else
                    vMsg "Failed to remove temporary file: \"$node\""
                fi
            fi
        }
    done

    # Handle the received SIGINT properly by terminating the script/process group with SIGINT
    [[ $g_flag_sigint_caught -eq 1 ]] && {
        # If the kill fails
        if ! kill -s SIGINT $$; then
            # Try the external command
            if ! $(which --skip-alias --skip-functions -- kill) -2 0; then
                kill -2 0
                exit
            fi
        fi
    }

    return 0
}

###############################################################################
# Purpose: Parse command line parameters using getopts and set global variables
#          according to what was requested.
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  getopts exist status (man getopts):
#          0  (An option, specified or unspecified by optstring, was found.)
#          >0 (The end of options was encountered or an error occurred.)
ParseParameters() {
    OPTERR=1 # make sure it's on
    while getopts 'zZThHflSs:i:d:R:r:NuUXv:V' sOPT; do
        case "$sOPT" in
            (h) g_show_help=1 ;;
            (H) g_show_usage=1 ;;
            (f) g_force=1 ;;
            (z) g_verbose=1 ;;
            (T) if [[ $g_force -eq 1 ]] && [[ $g_verbose -eq 1 ]]; then
                    g_integration_testing=1
                    ProvingGrounds
                fi
            ;;
            (Z)
                if [[ $g_force -eq 1 ]] && [[ $g_verbose -eq 1 ]]; then
                    (ReportEnvironmentInfo)
                fi
            ;;
            (u) g_check_update=1 ;;
            (X) g_remove_install_path=1 ;;
            (N) g_remove_all_saved_packages=1 ;;
            (R)
                g_remove_installed_version=1
                g_remove_version=$OPTARG
            ;;
            (r)
                g_remove_saved_package=1
                g_remove_saved_version=$OPTARG
            ;;
            (l) g_list_installed_versions=1 ;;
            (s)
                g_report_version_usage=1
                g_report_version=$OPTARG
            ;;
            (S) g_report_install_path_usage=1 ;;
            (d)
                g_download=1
                g_download_version=$OPTARG
            ;;
            (i)
                g_install=1
                g_install_version=$OPTARG
            ;;
            (U) g_update=1 ;;
            (V) g_verify=1 ;;
            (v)
                g_verify=1
                g_verify_version=$OPTARG
            ;;
            (":"|"?") return 1 ;;
        esac
    done
}

###############################################################################
# Purpose: Supervise and control the flow of the script depending on how it was invoked
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  0 (Success)
#          1 (An error occured)
Main() {

    # Parse script parameters and arguments, set global variables
    ParseParameters "$@" || exit 1

    # Report if debug mode is enabled
    ((g_verbose)) && vMsg "Debug mode enabled"

    # If no parameters were supplied, show help
    # NOTE: Ignore g_force and g_verbose flags
    if [[ $g_remove_install_path -eq 0 ]] && \
       [[ $g_remove_all_saved_packages -eq 0 ]] && \
       [[ $g_remove_installed_version -eq 0 ]] && \
       [[ $g_remove_saved_package -eq 0 ]] && \
       [[ $g_list_installed_versions -eq 0 ]] && \
       [[ $g_report_version_usage -eq 0 ]] && \
       [[ $g_report_install_path_usage -eq 0 ]] && \
       [[ $g_download -eq 0 ]] && \
       [[ $g_install -eq 0 ]] && \
       [[ $g_check_update -eq 0 ]] && \
       [[ $g_verify -eq 0 ]] && \
       [[ $g_show_help -eq 0 ]] && \
       [[ $g_show_usage -eq 0 ]] && \
       [[ $g_update -eq 0 ]]; then

        [[ $g_verbose -eq 1 ]] && {
            if IsSteamRunning; then
                vMsg "Steam is running"
            else
                vMsg "Steam is not running"
            fi
            vMsg "Nothing to do, showing help"
        }

        # Report latest version installed status
        #if GetLatestGEVersion; then
        #    if IsInstalled "$g_latest_version"; then
        #        echo "The latest version \"$g_latest_version\" is installed"
        #    else
        #        echo "The latest version \"$g_latest_version\" is not installed"
        #    fi
        #else
        #    echo "An error occured while checking for the latest release"
        #fi
        ShowHelp
        exit 0
    fi

    # show help and/or usage
    if [[ $g_show_help -eq 1 ]] && [[ $g_show_usage -eq 0 ]]; then
        ShowHelp
        exit 0
    elif [[ $g_show_help -eq 1 ]] && [[ $g_show_usage -eq 1 ]]; then
        ShowHelp
        ShowUsage
        exit 0
    elif [[ $g_show_help -eq 0 ]] && [[ $g_show_usage -eq 1 ]]; then
        ShowUsage
        exit 0
    fi

    if CheckRequirements; then
        if ParseConfigFile; then
            if ! SetupEnvironment; then
                exit 1
            fi
        else
            exit 1
        fi
    else
        exit 1
    fi

    CreateSedUnminifyJSONscript

    # checkupdate
    if [[ $g_check_update -eq 1 && $g_update -eq 0 ]]; then
        if GetLatestGEVersion; then
            if IsInstalled "$g_latest_version"; then
                echo "The latest version \"$g_latest_version\" is installed"
            else
                echo "The latest version \"$g_latest_version\" is not installed"
            fi
        fi
    fi

    # remove install path
    if [[ $g_remove_install_path -eq 1 ]] && [[ $g_force -eq 1 ]]; then
        if IsSteamRunning; then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    elif [[ $g_remove_install_path -eq 1 ]] && [[ $g_force -eq 0 ]]; then
        echo "-X must be combined with -f to confirm that you are sure"
    fi

    # remove saved packages
    if [[ $g_remove_all_saved_packages -eq 1 ]] && [[ $g_remove_install_path -eq 0 ]]; then
        RemoveAllSavedPackages # TODO: -f required?
    fi

    # Remove an installed version
    if [[ $g_remove_installed_version -eq 1 ]] && [[ $g_remove_install_path -eq 0 ]] && [[ $g_remove_all_saved_packages -eq 0 ]]; then
        RemoveGEVersion "$g_remove_version" # NOTE: g_remove_version is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif [[ $g_remove_installed_version -eq 1 ]] && [[ $g_remove_install_path -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Remove a saved package
    if [[ $g_remove_saved_package -eq 1 ]] && [[ $g_remove_install_path -eq 0 ]] && [[ $g_remove_all_saved_packages -eq 0 ]]; then
        RemoveSavedPackage "$g_remove_saved_version" # NOTE: g_remove_version is set in getops
    # If remove g_install path was requested in the same invocation, skip removing version/package
    elif [[ $g_remove_saved_package -eq 1 ]] && [[ $g_remove_install_path -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Download a package
    [[ $g_download -eq 1 ]] && {
        if ! DownloadGEPackage "$g_download_version"; then # NOTE: g_download_version is set in getops
            echo "Download failed"
        fi
    }

    # Check for new version and if it is not installed install it
    if [[ $g_update -eq 1 ]]; then
        if UpdateSavedGELatestRelease; then
            if GetLatestGEVersion; then # set global variable g_latest_version
                if IsInstalled "$g_latest_version" && [[ $g_force -eq 1 ]]; then # Latest version is installed and -f is supplied
                    if RemoveGEVersion "$g_latest_version"; then
                        # TODO: Replace InstallGEVersion with UpdateGEVersion
                        if InstallGEVersion; then # InstallGEVersion checks $g_update then $g_install_version and/or $g_latest_version
                            echo "Update succeeded"
                        else
                            echo "Update failed"
                        fi
                    fi
                elif IsInstalled "$g_latest_version" && [[ $g_force -eq 0 ]]; then # Latest version is installed and -f was not supplied
                    echo "Latest version is already installed ($g_latest_version)"
                elif ! IsInstalled "$g_latest_version"; then # Latest version is not installed
                    echo "Latest version is not installed"
                    if InstallGEVersion; then
                        echo "Update succeeded"
                        if IsSteamRunning; then
                            echo "Restart Steam to use the new version"
                        fi
                    else
                        echo "Update failed"
                    fi
                fi
            else
                ((g_verbose)) && vMsg "Update: GetLatestGEVersion returned failure status"
            fi
        else
            # GetLatestGEVersionInfo failed
            ((g_verbose)) && vMsg "Update: GetLatestGEVersionInfo returned failure status"
            echo "Update failed"
        fi
        # Like purchasing a tribble, this is probably a bad idea
        [[ $g_install -eq 1 ]] && g_update=0 # Reset g_update to 0 so g_update and g_install can run in the same invocation
    fi

    # Install a package
    if [[ $g_install -eq 1 ]] && [[ $g_update -eq 0 ]]; then
        InstallGEVersion "$g_install_version" # NOTE: g_install_version is set in getops
    fi

    # List installed versions
    [[ $g_list_installed_versions -eq 1 ]] && ListInstalledGEVersions

    # Report entire g_install path disk usage and file count
    [[ $g_report_install_path_usage -eq 1 ]] && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    [[ $g_report_version_usage -eq 1 ]] && ReportGEDiskUsage "$g_report_version"

    # Run verify if remove install path and remove saved packages wasn't requested
    # TODO: add support to verify even if remove saved packages and/or remove install path was invoked
    #       so long as some sort of install was also requested. Additionally, maybe support installing a version
    #       that is not installed when verify is called and force mode is active.
    if [[ $g_verify -eq 1 ]] && [[ $g_remove_install_path -ne 1 && $g_remove_all_saved_packages -ne 1 ]]; then
        VerifyGEInstall "${g_verify_version-}"
    fi

    return 0
}

###############################################################################
# Purpose: Run the function CleanUp on SIGEXIT
#          Save the exit status of the last executed command before invoking
#          the CleanUp function. Report both the saved exit status and the exit
#          status of CleanUp if debug mode is enabled.
trap 'g_real_exit_status=$?; ((g_verbose)) && vMsg "Exit status (before CleanUp): $g_real_exit_status"; CleanUp; ((g_verbose)) && vMsg "Exit status (after CleanUp): $?"; exit $g_real_exit_status' EXIT

###############################################################################
# Purpose: Run the function CleanUp if the process group received SIGINT
#          This needs to be a seperate trap to properly handle SIGINT.
trap 'g_flag_sigint_caught=1; CleanUp' INT

###############################################################################
# Wait...the end is just a new beginning? Always has been.

Main "$@"

