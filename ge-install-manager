#!/usr/bin/env bash
#shellcheck disable=SC2155
# https://github.com/koalaman/shellcheck/wiki/SC2155

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Maybe "geim" would be better?                                         #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

set +e # WARNING DO NOT set -e

###############################################################################
# Global notes
#
#  All non-special variables are written in capital letters, prefixed with a lower-case letter
#  that denotes usage within the scope of that particular variable.
#  This is not a strict requirement by Bash. It's a convenience for reference and readability.
#  When you see a variable prefixed with an 'i' in this script you can be sure that it always contains only integers.
#    eg. iDEBUG will always contain digits and nothing else (integers). Mathematical operator usage involving these variables is always valid.
#    eg. sGE_LATEST_VERSION can and will contain any variety of alphanumeric and/or special/control characters (string).
#    eg. If any indexed or associative arrays are used in the future they will be prefixed with 'ia' and 'aa' respectively.
#
#  All functions have appropriate return values. Currently, only two states are utilized, 1 (failure) and 0 (success).
#    eg. IsSteamRunning => success(0) = yes, failure(1) = no
#    eg. if InstallGEVersion "5.9-GE-5-ST"; then echo "success"; else echo "failure"; fi
#
#  Functions that 'return' values do so in a manner expecting the use of command substitution
#  (or otherwise connecting to/capturing stdout)
#    eg. iSIZE_BYTES=$(QueryGEAttribute "5.9-GE-t-ST" "size")
#        NOTE: Values returned in this manner do not include newlines
#
#  In addition to appropriate return values, functions that are expected to return a value other than an exit status also
#  intentionally return NULL if a non-fatal event occured.
#  (except in the case of GetLatestGEVersion which sets sGE_LATEST_VERSION to NULL instead)
#  This can be leveraged to better determine the type of event that occured, if any, and what to do about it, if anything
#    eg. QueryGEAttribute will return a NULL value (and exit status failure [1]) if the invoking parameters were syntatically valid,
#        but a value for that version was not found or if that version was not found
#
#  Most integer variables (excepting counters) are used simply as boolean values (0 or 1)
#    eg. iDEBUG is either 1 (on) or 0 (off)
#    eg. iINSTALL is either 1 (on, install <version> requested) or 0 (off, install not requested)
#
#  Most of the script logic is written in a "medium" or "long" form so it's easier to quickly grasp what is happening. "Short-hand",
#  "minified", and/or extremely optimized forms are intentionally avoided.
#
#

###############################################################################
# Global variables
sSCRIPT_VERSION="0.7.2"
sSCRIPT_CODENAME="Cochrane Bonaventure"
sGE_INSTALL_PATH="$HOME"/.steam/root/compatibilitytools.d
# JSON data sources TODO optional support for jq in addition to keeping sed as a fallback
sGE_LATEST_VERSION_URL="https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest"
sGE_RELEASES_URL="https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases"
# HTML data sources
# https://github.com/GloriousEggroll/proton-ge-custom/releases
# https://github.com/GloriousEggroll/proton-ge-custom/tags
sFILE_LATEST_JSON="$sGE_INSTALL_PATH/latest.json"
sFILE_RELEASES_JSON="$sGE_INSTALL_PATH/releases.json"
# NOTE JSON is returned minified when a custom User-Agent is used
sCURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
sCURL_HEADER_USER_AGENT="User-Agent: toazd/ge-install-manager/$sSCRIPT_VERSION"
sCURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
sGE_LATEST_VERSION=''
sFILE_SED_UNMINIFY_SCRIPT="$sGE_INSTALL_PATH/unminify-JSON.sed"
sCOMMAND_RM="rm" # command 'trash' replaces 'rm' if it is found
# some script functionality depends on the following being initiaized as 0
iFORCE=0
iDEBUG=0
iDOWNLOAD=0
iINSTALL=0
iREMOVE=0
iUPDATE=0
iFINAL_CLEANUP=0
iREMOVE_INSTALL_PATH=0
iREMOVE_SAVED_PACKAGES=0
iLIST_INSTALLED_GE_VERSIONS=0
iREPORT_VERSION_USAGE=0
iREPORT_INSTALL_PATH_USAGE=0
iSHOW_HELP=0
iSHOW_USAGE=0
iCHECK_UPDATE=0
iINTEGRATION_TESTING=0
OPTERR=1 # make sure it's on

###############################################################################
# TODO
ShowHelp() {
    cat <<END_OF_HELP

    $(basename "$0")  v$sSCRIPT_VERSION "$sSCRIPT_CODENAME"

    Required:       Bash 3.2+(TBD), curl, sed, tar, gzip, stat, wc
    Optional:       du (display disk usage of a path/file)
                    ps (is steam running)
                    trash (used instead of rm)

    Install path:          $sGE_INSTALL_PATH
    Latest version URL:    $sGE_LATEST_VERSION_URL
    Releases URL:          $sGE_RELEASES_URL

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
                      Combine with -f to also remove the saved package or to remove a package
                      if the install path was already removed for <version>
    -d <version>  - Download the package for <version> and save it to the install path
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      -f is also required to confirm that you are sure
    -f            - Force install, upgrade, or remove
                      Combined with -u and/or -i, remove saved package and download a new copy
    -z            - Enable debug mode
                      Enable extra output messages and preserve any temporary files created

END_OF_HELP

    return 0
}

###############################################################################
# TODO
ShowUsage() {
    cat <<END_OF_USAGE
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle, Report environment info (-fzZ), Show help,
      Show usage, Debug toggle, Check for latest release, Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Download, Update, Install, List installed,
      Report install path usage,
      Report specific version usage

END_OF_USAGE

    return 0
}

###############################################################################
# Sets the global variable sGE_LATEST_VERSION to the latest version
# TODO *might* want to check releases if latest fails.
GetLatestGEVersion() {

    # WARNING DO NOT make this local
    sGE_LATEST_VERSION=''

    if UpdateSavedGELatestRelease; then
        while IFS= read -r; do
            # WARNING do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST",
            #         they are not always the same name as the package
            # NOTE must be compatible with all 3 of the following potential formats
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            [[ $REPLY =~ ^.*\"name\":.*\"Proton-.*\.tar\.gz\".*$ ]] && {
                ((iDEBUG)) && echo "($LINENO) GetLatestGEVersion: matched line \"$REPLY\"" 1>&2
                sGE_LATEST_VERSION=${REPLY#*\"name\":}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION#*\"}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION%.tar.gz\"*}
                ((iDEBUG)) && echo "($LINENO) GetLatestGEVersion: sGE_LATEST_VERSION set to \"$sGE_LATEST_VERSION\"" 1>&2
                break
            }
        done < "$sFILE_LATEST_JSON"

        [[ -z $sGE_LATEST_VERSION ]] && {
            ((iDEBUG)) && echo "($LINENO) GetLatestGEVersion: sGE_LATEST_VERSION is NULL (no match or not found)" 1>&2
            return 1
        }
    else
        ((iDEBUG)) && echo "($LINENO) GetLatestGEVersion: UpdateSavedGELatestRelease returned failure status" 1>&2
        return 1
    fi

    return 0
}

###############################################################################
# Retrieve "latest" JSON from sGE_LATEST_VERSION_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGELatestRelease() {

    local sGE_LATEST_RELEASE_JSON=''

    ((iDEBUG)) && echo "($LINENO) UpdateSavedGELatestRelease: Using RequestURL to check if \"$sGE_LATEST_VERSION_URL\" is newer than \"$sFILE_LATEST_JSON\"" 1>&2

    if sGE_LATEST_RELEASE_JSON=$(RequestURL "$sGE_LATEST_VERSION_URL" "$sFILE_LATEST_JSON"); then
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGELatestRelease: RequestURL returned success" 1>&2
    else
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGELatestRelease: RequestURL returned failure" 1>&2
    fi

    # check the response and report and respond accordingly
    if [[ -n $sGE_LATEST_RELEASE_JSON ]]; then
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGELatestRelease: sGE_LATEST_RELEASE_JSON is not empty" 1>&2
        [[ -f $sFILE_LATEST_JSON.ulrbak ]] && $sCOMMAND_RM "$sFILE_LATEST_JSON".ulrbak
        [[ -f $sFILE_LATEST_JSON ]] && mv "$sFILE_LATEST_JSON" "$sFILE_LATEST_JSON".ulrbak
        printf '%s' "$sGE_LATEST_RELEASE_JSON" > "$sFILE_LATEST_JSON"
        return 0
    elif [[ -z $sGE_LATEST_RELEASE_JSON ]]; then
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGELatestRelease: sGE_LATEST_RELEASE_JSON is NULL" 1>&2
        if [[ ! -f $sFILE_LATEST_JSON ]]; then
            echo "($LINENO) UpdateSavedGELatestRelease: Response from RequestURL was NULL and file \"$sFILE_LATEST_JSON\" not found. Is \"$sGE_LATEST_VERSION_URL\" a valid URL?" 1>&2
            return 1
        fi
    fi

    return 0
}

###############################################################################
# Retrieve "releases" JSON from sGE_RELEASES_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGEReleases() {

    local sGE_RELEASES_JSON=''

    # BUG updates to download_count in remote releases cause curl -z to download a new version much more often than is needed
    ((iDEBUG)) && echo "($LINENO) UpdateSavedGEReleases: Using RequestURL to check if \"$sGE_RELEASES_URL\" is newer than \"$sFILE_RELEASES_JSON\"" 1>&2

    if sGE_RELEASES_JSON=$(RequestURL "$sGE_RELEASES_URL" "$sFILE_RELEASES_JSON"); then
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGEReleases: RequestURL returned success" 1>&2
    else
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGEReleases: RequestURL returned failure" 1>&2
    fi

    if [[ -n $sGE_RELEASES_JSON ]]; then
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGEReleases: sGE_RELEASES_JSON is not empty" 1>&2
        [[ -f $sFILE_RELEASES_JSON.usrbak ]] && $sCOMMAND_RM "$sFILE_RELEASES_JSON".usrbak
        [[ -f $sFILE_RELEASES_JSON ]] && mv "$sFILE_RELEASES_JSON" "$sFILE_RELEASES_JSON".usrbak
        printf '%s' "$sGE_RELEASES_JSON" > "$sFILE_RELEASES_JSON"
        return 0
    elif [[ -z $sGE_RELEASES_JSON ]]; then
        ((iDEBUG)) && echo "($LINENO) UpdateSavedGEReleases: sGE_RELEASES_JSON is NULL" 1>&2
        if [[ ! -f $sFILE_RELEASES_JSON ]]; then
            echo "($LINENO) UpdateSavedGEReleases: Response from RequestURL was NULL and file \"$sFILE_RELEASES_JSON\" not found. Is \"$sGE_RELEASES_URL\" a valid URL?" 1>&2
            return 1
         fi
    fi

    return 0
}

###############################################################################
# Attempt to download a package (Proton*.tar.gz) using a tmp path.
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
DownloadGEPackage() {

    local sVERSION=$(CleanUpVersion "$1")
    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "($LINENO) RemoveGEVersion: sVERSION is null" 1>&2
        return 1
    }
    local sTMP_DIR=$(mktemp -qd --tmpdir "$(basename "$0" .sh)".tmp.XXXXXXXXXX)
    local sTMP_PACKAGE=$sTMP_DIR/Proton-${sVERSION}.tar.gz
    local sGE_DOWNLOAD_URL=$(QueryGEAttribute "$sVERSION" "browser_download_url")
    local iSIZE_BYTES=''

    [[ -z $sGE_DOWNLOAD_URL ]] && {
        ((iDEBUG)) && "($LINENO) DownloadGEPackage: sVERSION is NULL" 1>&2
        return 1
    }

    echo "Downloading \"$sGE_DOWNLOAD_URL\""
    if curl -# -L "$sGE_DOWNLOAD_URL" -o "$sTMP_PACKAGE"; then
        iSIZE_BYTES=$(stat -c '%s' "$sTMP_PACKAGE")
        ((iDEBUG)) && echo "($LINENO) DownloadGEPackage: Package size in bytes: $iSIZE_BYTES" 1>&2
        if [[ $iSIZE_BYTES -eq 9 ]] && [[ $(cat "$sTMP_PACKAGE" 2>/dev/null) = "Not Found" ]]; then
            echo "($LINENO) DownloadGEPackage: Server responded \"Not Found\" for version \"$sVERSION\""
            CleanUp
            return 1
        fi
        if [[ $iSIZE_BYTES = "$(QueryGEAttribute "$sVERSION" "size")" ]]; then
            echo "($LINENO) DownloadGEPackage: Downloaded package size matches the expected size"
        else
            printf '%s\n%s\n' \
                   "($LINENO) DownloadGEPackage: Downloaded file size and expected size do not match" \
                   "($LINENO) DownloadGEPackage: (\"$iSIZE_BYTES\" != \"$(QueryGEAttribute "$sVERSION" "size")\")" 1>&2
           CleanUp
           return 1
        fi
        ((iDEBUG)) && echo "($LINENO) DownloadGEPackage: Copying package \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\"" 1>&2
        if cp "$sTMP_PACKAGE" "$sGE_INSTALL_PATH"; then
            ((iDEBUG)) && echo "($LINENO) DownloadGEPackage: Package copied successfully" 1>&2
            echo "Download succeeded"
            CleanUp
        else
            ((iDEBUG)) && echo "($LINENO) DownloadGEPackage: Copy package \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\" failed" 1>&2
            echo "Download failed"
            CleanUp
            return 1
        fi
    else
        ((iDEBUG)) && echo "($LINENO) DownloadGEPackage: curl returned failure status"
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Install a GE version using either a saved package or downloading a new one
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
# NOTE sINSTALL_VERSION is set in getops when -i is invoked
# NOTE If -u and -i are both invoked, the update will run first and then the install, if needed
InstallGEVersion() {

    local sVERSION=''

    if [[ $iUPDATE -eq 1 ]]; then
        [[ -z $sGE_LATEST_VERSION ]] && GetLatestGEVersion || return 1
        sVERSION=$sGE_LATEST_VERSION
    elif [[ $iUPDATE -eq 0 ]]; then
        sVERSION=${sINSTALL_VERSION:-$(CleanUpVersion "$1")}
    else
        sVERSION=$(CleanUpVersion "$1")
        echo "($LINENO) InstallGEVersion: error detecting install mode"
        return 1
    fi

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "($LINENO) InstallGEVersion: sVERSION is null" 1>&2
        return 1
    }

    # Re-install a version that is already installed
    if IsInstalled "$sVERSION"; then
        if [[ $iFORCE -eq 0 ]]; then
            echo "\"$sVERSION\" is already installed"
            return 0
        elif [[ $iFORCE -eq 1 ]]; then
            if IsSteamRunning; then
                echo "Please close Steam before re-installing a version that is already installed"
                return 1
            else
                echo "Forcing re-install of version \"$sVERSION\""
            fi
        fi
    fi

    # if a saved package exists and force mode is not active
    if [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 0 ]]; then
        echo "Using saved package: \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if ExtractGEPackage "$sVERSION"; then
            return 0
        else
            return 1
        fi
    # if a saved package exists and force mode is active
    elif [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 1 ]]; then
        echo "Removing saved package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if $sCOMMAND_RM "$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz"; then
            echo "Package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz removed\""
        else
            echo "Removing package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\" failed"
            return 1
        fi
    fi

    # If a saved package for this version doesn't exist or it was removed, download it and install it
    if DownloadGEPackage "$sVERSION"; then
        if ExtractGEPackage "$sVERSION"; then
            echo "Installation of version \"$sVERSION\" was successful"
            return 0
        else
            echo "Installation of version \"$sVERSION\" failed"
            return 1
        fi
    else
        echo "Version \"$sVERSION\" not found"
        return 1
    fi

    return 0
}

###############################################################################
# Removes an installed version path and package (if -f is also supplied)
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE supports removing the package specified by version even if that version is not installed
#      when the -f parameter is combined with -R
RemoveGEVersion() {

    local sVERSION=$(CleanUpVersion "$1")
    local sREMOVE_PATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
    local sREMOVE_PACKAGE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz
    local sSIZE="0"

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "($LINENO) RemoveGEVersion: sVERSION is null" 1>&2
        return 1
    }

    if ! IsInstalled "$sVERSION"; then
        echo "Version \"$sVERSION\" is not installed"
        return 0
    fi

    ((iDEBUG)) && echo "($LINENO) RemoveGEVersion: Removing \"$sREMOVE_PATH\"" 1>&2
    # If force is enabled, remove the path and the package
    if [[ $iFORCE -eq 1 ]]; then
        ((iDEBUG)) && echo "($LINENO) RemoveGEVersion: force is enabled" 1>&2
        # Remove the path if it exists
        [[ -d $sREMOVE_PATH ]] && {
            if ! IsSteamRunning; then
                sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
                sSIZE=${sSIZE%[[:space:]]*}
                if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                    echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
                else
                    echo "Failed to remove \"$sREMOVE_PATH\""
                    return 1
                fi
            else
                echo "Please close Steam before removing an install path"
                return 1
            fi
        }
        # Remove the package if it exists
        [[ -f $sREMOVE_PACKAGE ]] && {
            sSIZE=$(du -h "$sREMOVE_PACKAGE" 2>/dev/null)
            sSIZE=${sSIZE%[[:space:]]*}
            if $sCOMMAND_RM -f "$sREMOVE_PACKAGE" >/dev/null; then
                echo "Removed package \"$sREMOVE_PACKAGE\" (${sSIZE:-'error'})"
            else
                echo "Failed to remove package \"$sREMOVE_PACKAGE\""
                return 1
            fi
        }
    # If force is not enabled, remove only the install path for sVERSION
    elif [[ $iFORCE -eq 0 ]]; then
        ((iDEBUG)) && echo "($LINENO) RemoveGEVersion: force is not enabled" 1>&2
        # Remove the path if it exists
        [[ -d $sREMOVE_PATH ]] && {
            if ! IsSteamRunning; then
                sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
                sSIZE=${sSIZE%[[:space:]]*}
                if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                    echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
                else
                    echo "Failed to remove \"$sREMOVE_PATH\""
                    return 1
                fi
            else
                echo "Please close Steam before removing an install path"
                return 1
            fi
        }
    fi

    return 0
}

###############################################################################
# Extracts a saved package (Proton-*.tar.gz) in the install path to the install path
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
ExtractGEPackage() {

    local sVERSION=$(CleanUpVersion "$1")
    local sEXTRACT_FILE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "($LINENO) ExtractGEPackage: sVERSION is null" 1>&2
        return 1
    }

    printf '%s' "Extracting"
    if tar --checkpoint=.10000 -C "$sGE_INSTALL_PATH" -xzf "$sEXTRACT_FILE" 2>/dev/null; then
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        printf '\r\033[0K%s\n' "Package extraction failed"
        [[ -d $sGE_INSTALL_PATH/Proton-${sVERSION} ]] && {
            ((iDEBUG)) && echo "($LINENO) ExtractGEPackage: Removing failed extraction path \"$sGE_INSTALL_PATH/Proton-${sVERSION}\"" 1>&2
            if $sCOMMAND_RM -rf "$sGE_INSTALL_PATH/Proton-${sVERSION}"; then
                ((iDEBUG)) && echo "($LINENO) ExtractGEPackage: Removal succeeded" 1>&2
            else
                echo "Failed to remove path of failed extraction: \"$sGE_INSTALL_PATH/Proton-${sVERSION}\""
                # TODO update/remove message when install verification is updated
                echo "This script may interpret it as a valid install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# List the currently installed GE versions and any saved packages
ListInstalledGEVersions() {

    local iCOUNT=0
    local sNODE=''
    #local sEXTRACTED_VERSION=''

    ((iDEBUG)) && echo "($LINENO) ListInstalledGEVersions: Install path: \"$sGE_INSTALL_PATH\"" 1>&2

    echo "Installed version(s):"
    for sNODE in "$sGE_INSTALL_PATH"/*; do
        if [[ -d $sNODE ]]; then
            #sEXTRACTED_VERSION=$(cat "$sNODE"/version 2>/dev/null)
            #sEXTRACTED_VERSION=${sEXTRACTED_VERSION#*[[:blank:]]}
            #if [[ -z $sEXTRACTED_VERSION ]] || [[ $sEXTRACTED_VERSION = "file not found" ]]; then sEXTRACTED_VERSION="error: version file not found"; fi
            #echo "  ${sNODE##*/} ($sEXTRACTED_VERSION)"
            echo "  ${sNODE##*/}"
            ((iCOUNT++))
        fi
    done
    [[ $iCOUNT -eq 0 ]] && echo "None found"

    echo "Saved package(s):"
    sNODE=''
    iCOUNT=0
    for sNODE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sNODE ]]; then
            if [[ $iDEBUG -eq 1 ]]; then
                echo "  ${sNODE##*/} (size: $(stat -c '%s' "$sNODE"), expected size: $(QueryGEAttribute "${sNODE##*/}" "size"))"
            else
                echo "  ${sNODE##*/}"
            fi
            ((iCOUNT++))
        fi
    done
    [[ $iCOUNT -eq 0 ]] && echo "None found"

    return 0
}

###############################################################################
# Report disk usage and file counts for the install path and/or a specified installed version
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
ReportGEDiskUsage() {

    local sVERSION=$(CleanUpVersion "$1")
    local sPATH=''
    local sSIZE="0"
    local iFAILED=0

    # NOTE do not return 1 if sVERSION is NULL, functionality below depends on it

    if ! command -v du >/dev/null && ! command -v find >/dev/null && ! command -v wc >/dev/null; then
        iFAILED=1
    fi

    # if all checks succeeded
    if [[ $iFAILED -eq 0 ]]; then
        # set the path to be reported based on whether a version was provided or not
        if [[ -z $sVERSION ]]; then
            # report the file count and disk usage for the entire install path
            sPATH=$sGE_INSTALL_PATH
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                ((iDEBUG)) && echo "Path: $sPATH" 1>&2
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
        if [[ -n $sVERSION ]]; then
            # Report the file count and disk usage for a specific version
            sPATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Version \"$sVERSION\" report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                ((iDEBUG)) && echo "Path: $sPATH" 1>&2
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
    # if any check failed
    elif [[ $iFAILED -eq 1 ]]; then
        ((iDEBUG)) && echo "($LINENO) ReportGEDiskUsage: At least one optional command was not found" 1>&2
        echo "One or more optional commands not found (see -h). Report not available"
        return 1
    fi

    return 0
}

###############################################################################
# Removes all saved packages in the install path defined by the global variable sGE_INSTALL_PATH
# NOTE a package is any regular file that matches the glob pattern "Proton-*.tar.gz"
RemoveSavedPackages() {

    local iSUCCESS=0
    local iFAILED=0

    ((iDEBUG)) && echo "($LINENO) RemoveSavedPackages: Install path: \"$sGE_INSTALL_PATH\"" 1>&2

    for sPACKAGE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sPACKAGE ]]; then
            if $sCOMMAND_RM -f "$sPACKAGE"; then
                ((iDEBUG)) && echo "($LINENO) RemoveSavedPackages: Package \"$sPACKAGE\" removed" 1>&2
                ((iSUCCESS++))
            else
                echo "Remove \"$sPACKAGE\" failed"
                ((iFAILED++))
            fi
        fi
    done

    if [[ $iSUCCESS -eq 0 ]]; then
        echo "0 packages removed"
    elif [[ $iSUCCESS -gt 0 ]]; then
        echo "$iSUCCESS packages removed"
    fi

    [[ $iFAILED -gt 0 ]] && {
        echo "Failed to remove $iFAILED package(s)"
        return 1
    }

    return 0
}

###############################################################################
# Removes the path defined by the global variable sGE_INSTALL_PATH
# NOTE currently requires -f to be combined with -X
RemoveGEInstallPath() {

    local sSIZE="0"

    if command -v du >/dev/null; then
        sSIZE=$(du -sh "$sGE_INSTALL_PATH")
    else
        ((iDEBUG)) && echo "($LINENO) RemoveGEInstallPath: command du not found" 1>&2
        sSIZE="unknown"
    fi

    if $sCOMMAND_RM -rf "$sGE_INSTALL_PATH"; then
        echo "Remove install path succeeded ( ${sSIZE%%[[:blank:]]*} removed )"
        if [[ $iDEBUG -eq 1 ]]; then
            mkdir -pv "$sGE_INSTALL_PATH"
        else
            mkdir -p "$sGE_INSTALL_PATH"
        fi
    else
        echo "Removal of install path \"$sGE_INSTALL_PATH\" failed"
        return 1
    fi

    return 0
}

###############################################################################
# Wrapper for QueryGEAttribute to first check latest.json, then if a value is not returned, check releases.json
# Accepts two required parameters, version and attribute, returns the value or NULL if not found/error
# NOTE attributes are validated in QueryJSONAttribute
QueryGEAttribute() {

    [[ -z $1 || -z $2 || $# -ne 2 ]] && {
        ((iDEBUG)) && "($LINENO) QueryGEAttribute: parameter error 1: \"$1\" 2: \"$2\"" 1>&2
        return 1
    }

    local sVERSION=$(CleanUpVersion "$1")
    local sVALUE=''
    local sATTRIBUTE=$2
    local iEXIT_STATUS

    if UpdateSavedGELatestRelease; then
        ((iDEBUG)) && echo "($LINENO) QueryGEAttribute: UpdateSavedGELatestRelease returned success"
    else
        ((iDEBUG)) && echo "($LINENO) QueryGEAttribute: UpdateSavedGELatestRelease returned failure"
    fi

    sVALUE=$(QueryJSONAttribute "$sFILE_LATEST_JSON" "$sVERSION" "$sATTRIBUTE")
    iEXIT_STATUS=$?
    if [[ $iDEBUG -eq 1 && $iEXIT_STATUS -gt 0 ]]; then
        echo "($LINENO) QueryGEAttribute: QueryJSONAttribute returned failure" 1>&2
    elif [[ $iDEBUG -eq 1 && $iEXIT_STATUS -eq 0 ]]; then
        echo "($LINENO) QueryGEAttribute: QueryJSONAttribute returned success" 1>&2
    elif ((iDEBUG)); then
        echo "($LINENO) QueryGEAttribute: QueryJSONAttribute unknown exit status \$?: \"$?\"" 1>&2
    fi

    # if the returned value from QueryJSONAttribute was NULL, try searching in releases
    if [[ -z $sVALUE ]]; then
        if UpdateSavedGEReleases; then
            ((iDEBUG)) && echo "($LINENO) QueryGEAttribute: UpdateSavedGEReleases returned success"
        else
            ((iDEBUG)) && echo "($LINENO) QueryGEAttribute: UpdateSavedGEReleases returned failure"
        fi

        sVALUE=$(QueryJSONAttribute "$sFILE_RELEASES_JSON" "$sVERSION" "$sATTRIBUTE")
        iEXIT_STATUS=$?
        if [[ $iDEBUG -eq 1 && $iEXIT_STATUS -gt 0 ]]; then
            echo "($LINENO) QueryGEAttribute: QueryJSONAttribute returned failure status" 1>&2
        elif [[ $iDEBUG -eq 1 && $iEXIT_STATUS -eq 0 ]]; then
            echo "($LINENO) QueryGEAttribute: QueryJSONAttribute returned success status" 1>&2
        elif ((iDEBUG)); then
            echo "($LINENO) QueryGEAttribute: QueryJSONAttribute unknown exit status \$?: \"$?\"" 1>&2
        fi
    fi

    if [[ -n $sVALUE ]]; then
        printf '%s' "$sVALUE"
        return 0
    else
        printf ''
        return 1
    fi

    # NOTE do not return 0/1 here
}

###############################################################################
# Return the value of a requested attribute from a saved latest/releases JSON file
# value = $( QueryJSONAttribute "file.json" "version" "attribute")
# NOTE This function relies on the JSON being in an exact order, if that order is changed (eg. by the github api) this function will cease to work
# Example JSON order expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE the default media-type requested is "application/vnd.github.v3.text+json" (I may make use of the body_text)
QueryJSONAttribute() {

    if [[ $# -ne 3 ]] || [[ ! -f $1 ]] || [[ -z $1 || -z $2 || -z $3 ]]; then
        ((iDEBUG)) && echo "($LINENO) QueryJSONAttribute: invalid parameter error 1: \"$1\" 2: \"$2\" 3: \"$3\" \$#: \"$#\"" 1>&2
        return 1
    fi

    [[ ${3,,} != @(size|browser_download_url) ]] && {
        ((iDEBUG)) && echo "($LINENO) QueryJSONAttribute: unsupported attribute requested \"$2\"" 1>&2
        return 1
    }

    local sVERSION=''
    local iSIZE=''
    local sBROWSER_URL=''
    local sATTRIBUTE=''
    local iLINE_COUNTER=0
    local iLINE_VERSION_FOUND=0
    local iLINE_SIZE_FOUND=0
    local iLINE_BROWURL_FOUND=0
    local iFLAG_VERSION_FOUND=0
    local iFLAG_SIZE_FOUND=0
    #local iFLAG_BROWURL_FOUND=0

    sVERSION=$(CleanUpVersion "$2")

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "($LINENO) QueryJSONAttribute: sVERSION is null" 1>&2
        return 1
    }

    sATTRIBUTE=${3,,}

    # WARNING do not manually output to stdout in this loop (unless you connect the file to different fd, and set read -u accordingly)
    # NOTE stderr is redirected to /dev/null, I don't rememeber why (probably before all debug messages were redirected to fd2/stderr)
    while IFS= read -r; do
        ((iLINE_COUNTER++))
        # version match
        # sVERSION example: 5.9-GE-5-ST
        # NOTE must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        [[ $REPLY =~ ^.*\"name\":.*\"Proton-${sVERSION}\.tar\.gz\".*$ ]] && {
            iFLAG_VERSION_FOUND=1
            iLINE_VERSION_FOUND=$iLINE_COUNTER
        }

        # NOTE must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        [[ $iFLAG_VERSION_FOUND -eq 1 ]] && {
            [[ ${REPLY,,} =~ ^.*\"size\":.*[[:digit:]]+.*$ ]] && {
                iFLAG_SIZE_FOUND=1
                iLINE_SIZE_FOUND=$iLINE_COUNTER
                iSIZE=${REPLY//[[:space:]]}
                iSIZE=${iSIZE/#\"size\":}
                iSIZE=${iSIZE%%[[:punct:]]*} # iSIZE=${iSIZE%,*}
                continue
            }
        }

        # NOTE must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        [[ $iFLAG_VERSION_FOUND -eq 1 && $iFLAG_SIZE_FOUND -eq 1 ]] && {
            [[ $REPLY =~ ^.*\"browser_download_url\":.*\".*Proton-${sVERSION}\.tar\.gz\".*$ ]] && {
                #iFLAG_BROWURL_FOUND=1
                iLINE_BROWURL_FOUND=$iLINE_COUNTER
                sBROWSER_URL=${REPLY/#*\"browser_download_url\":}
                sBROWSER_URL=${sBROWSER_URL//[[:space:]]}
                sBROWSER_URL=${sBROWSER_URL/#\"}
                sBROWSER_URL=${sBROWSER_URL%%\"*}
                break
            }
        }
    done < "$1" 2>/dev/null

    # debug messages
    ((iDEBUG)) && {
        if [[ $iFLAG_VERSION_FOUND -eq 0 ]]; then
            echo "($LINENO) QueryJSONAttribute: version match not found" 1>&2
        elif [[ $iFLAG_VERSION_FOUND -eq 1 ]]; then
            echo "($LINENO) QueryJSONAttribute: version match found at line $iLINE_VERSION_FOUND" 1>&2
        fi
        if [[ -z $iSIZE ]]; then
            echo "($LINENO) QueryJSONAttribute: iSIZE is NULL" 1>&2
        else
            echo "($LINENO) QueryJSONAttribute: iSIZE: \"$iSIZE\"" 1>&2
        fi
        if [[ -z $sBROWSER_URL ]]; then
            echo "($LINENO) QueryJSONAttribute: sBROWSER_URL is NULL" 1>&2
        else
            echo "($LINENO) QueryJSONAttribute: sBROWSER_URL: \"$sBROWSER_URL\"" 1>&2
        fi
        echo "($LINENO) QueryJSONAttribute: iLINE_VERSION_FOUND: $iLINE_VERSION_FOUND iLINE_SIZE_FOUND: $iLINE_SIZE_FOUND iLINE_BROWURL_FOUND: $iLINE_BROWURL_FOUND" 1>&2
    }

    # output the value of the requested attribute
    if [[ -n $iSIZE && -n $sBROWSER_URL ]]; then
        case $sATTRIBUTE in
            (size)
                printf '%s' "$iSIZE" >&1
            ;;
            (browser_download_url)
                printf '%s' "$sBROWSER_URL" >&1
            ;;
            (*)
                # NOTE NULL response indicates error OR not found. check return status, response, and debug messages
                printf ''
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Run the sed script created by CreateSedUnminifyJSONscript on a supplied path/file
# TODO
ReformatJSONUsingSed() {

    local sFILE_JSON

    sFILE_JSON=${1:?"($LINENO) ReformatJSONsed: Parameter required"} #TODO
    #shellcheck disable=SC2181
    [[ $? -gt 0 ]] && return 1

    ((iDEBUG)) && echo "($LINENO) ReformatJSONUsingSed: sFILE_JSON: \"$sFILE_JSON\"" 1>&2

    if [[ -f $sFILE_JSON && -w $sFILE_JSON ]]; then
        if sed -f "$sFILE_SED_UNMINIFY_SCRIPT" -i.sedbak "$sFILE_JSON"; then
            ((iDEBUG)) && echo "($LINENO) ReformatJSONUsingSed: sed returned success" 1>&2
            return 0
        else
            ((iDEBUG)) && echo "(($LINENO)) ReformatJSONUsingSed: sed returned failure" 1>&2
            return 1
        fi
    else
        echo "($LINENO) ReformatJSONUsingSed: Invalid file: \"$sFILE_JSON\""
    fi

    return 0
}

###############################################################################
# Detect if a string is minified or not (zero newlines)
# return 0 if yes, 1 if no
# NOTE the current un-minify script works on both minified and not-minified JSON data
#      so this function is pointless other than reporting debug info
IsJSONminified() {

    local sJSON=${1:?"($LINENO) IsJSONminified: Parameter required"} #TODO
    #shellcheck disable=SC2181
    [[ $? -gt 0 ]] && return 1

    # NOTE do not use herestring
    iLINES=$(printf '%s' "$sJSON" | wc -l)
    ((iDEBUG)) && "($LINENO) IsJSONminified: iLINES: \"$iLINES\"" 1>&2
    # 0 is the actual value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added
    if [[ $iLINES -le 1 ]]; then
        ((iDEBUG)) && "($LINENO) IsJSONminified: Detected minified JSON" 1>&2
        return 0
    else
        ((iDEBUG)) && "($LINENO) IsJSONminified: JSON is not minified" 1>&2
        return 1
    fi

    # assume it is minified if an error occurs
    # NOTE the unminify script works on both minified and un-minified JSON
    # NOTE it will reformat the body_text section if needed when the media type
    #      "application/vnd.github.v3.text+json" is requested (default)

    return 0
}

###############################################################################
# If the sed script sFILE_SED_UNMINIFY_SCRIPT is not found, create it
# This sed script is used to un-minify minified JSON and reformat the body_text section
# NOTE supports both unminified and minified input
# TODO
CreateSedUnminifyJSONscript() {

    if [[ ! -f $sFILE_SED_UNMINIFY_SCRIPT ]]; then
        ((iDEBUG)) && echo "($LINENO) CreateSedUnminifyJSONscript: script file at \"$sFILE_SED_UNMINIFY_SCRIPT\" does not exist, creating it" 1>&2
        cat > "$sFILE_SED_UNMINIFY_SCRIPT" <<"END_OF_SED_SCRIPT"
#### begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s/","/"\n"/g
#### end minimum required for ge-install-manager

# replace:  "assets": [
# with:     "assets":newline
s/"assets":\[/"assets":\n/g

# replace:  :{"
# with:     :newline"
s/:{"/:\n"/g

# replace:  "},"
# with:     "newline"
s/"},"/"\n"/g

# replace:  },"
# with:     newline"
s/},"/\n"/g

# replace:  {"
# with:     "
s/{"/"/g

#### Re-format text intended for formating ('\n') in "body_text" when media type
#### "application/vnd.github.v3.text+json" is requested
# replace:  \n
# with:     newline
s/\\n/\n/g

# replace:  ,"
# with:     newline"
s/,"/\n"/g

#### one per release listed
# replace:  "}]
# with:     "
s/"}\]/"/g

# replace:  "}
# with:     "
s/"}/"/g

#### very minor
# replace:  ["
# with:     "
s/\["/"/g
END_OF_SED_SCRIPT
    else
        ((iDEBUG)) && echo "($LINENO) CreateSedUnminifyJSONscript: script file found at \"$sFILE_SED_UNMINIFY_SCRIPT\" ($(stat -c '%s' "$sFILE_SED_UNMINIFY_SCRIPT") bytes/824 bytes expected)" 1>&2
    fi

    return 0
}

###############################################################################
# Check if a version is installed
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE Currently only checks if a path for the version exists
# TODO better verification
IsInstalled() {

    [[ -z $1 ]] && {
        ((iDEBUG)) && echo "($LINENO) IsInstalled: NULL parameter error" 1>&2
        return 1
    }

    sVERSION=$(CleanUpVersion "$1")

    ((iDEBUG)) && echo "IsInstalled: Checking for version \"$sVERSION\" at \"$sGE_INSTALL_PATH/Proton-${sVERSION}\"" 1>&2

    if [[ -d $sGE_INSTALL_PATH/Proton-${sVERSION} ]]; then
        ((iDEBUG)) && echo "IsInstalled: Version \"$sVERSION\" found" 1>&2
        return 0
    else
        ((iDEBUG)) && echo "IsInstalled: Version \"$sVERSION\" not found" 1>&2
        return 1
    fi

    # NOTE do not return 0 here
}

###############################################################################
# Check if Steam is running using 'ps -e'
# return 0 = Steam is running
# return 1 = Steam is not running / ps is missing / Steam is not running but steamwebhelper is
IsSteamRunning() {

    local iSTEAM=0
    local iWEBHLPR=0

    if command -v ps >/dev/null; then
        while IFS= read -r; do
            [[ ${REPLY,,} =~ ^.*steam$ ]] && {
                iSTEAM=1
                ((iDEBUG)) && echo "($LINENO) IsSteamRunning: steam match: \"$REPLY\"" 1>&2
            }
            [[ ${REPLY,,} =~ ^.*steamwebhelper.*$ ]] && {
                iWEBHLPR=1
                ((iDEBUG)) && echo "($LINENO) IsSteamRunning: steamwebhelper match: \"$REPLY\"" 1>&2
            }
        done < <(ps -e)
        #return $(( iSTEAM == 1 ? 0 : 1 ))

        if [[ $iSTEAM -eq 1 ]]; then
            return 0
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 1 ]]; then
            echo "Warning: at least one steamwebhelper process(es) is still running and Steam is not running"
            return 1
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 0 ]]; then
            return 1
        else
            echo "($LINENO) IsSteamRunning: unknown error iSTEAM: \"$iSTEAM\" iWEBHLPR: \"$iWEBHLPR\" (last)REPLY: \"$REPLY\""
            return 1
        fi
    else
        # ps missing
        echo "($LINENO) IsSteamRunning: command 'ps' not found"
        return 1
    fi

    return 1
}

###############################################################################
# RequestURL "URL "path/file"
# If the mtime (determined by curl) is newer for remote (versus local file) download a new one
# NOTE return NULL via stdout if remote file is not newer
# TODO
RequestURL() {

    local sURL=${1:?"($LINENO) RequestURL: URL parameter required"} # TODO
    local sFILE=${2:?"($LINENO) RequestURL: File parameter requried"} # TODO
    #shellcheck disable=SC2181
    [[ $? -gt 0 ]] && return 1
    [[ $# -ne 2 ]] && return 1

    local sRESPONSE
    local sMODIFIED_RESPONSE

    if sRESPONSE=$(curl -sz "$sFILE" \
                        -H "$sCURL_HEADER_USER_AGENT" \
                        -H "$sCURL_HEADER_CONTENT_TYPE" \
                        -H "$sCURL_HEADER_GITHUB_MEDIATYPE" \
                        -L "$sURL" \
                        -o - 2>/dev/null); then

        ((iDEBUG)) && "($LINENO) RequestURL: curl returned success" 1>&2

        if [[ -n $sRESPONSE ]]; then
            ((iDEBUG)) && "($LINENO) RequestURL: sRESPONSE is not empty" 1>&2
            if IsJSONminified "$sRESPONSE"; then
                ((iDEBUG)) && "($LINENO) RequestURL: IsJSONminified returned success" 1>&2
            else
                ((iDEBUG)) && "($LINENO) RequestURL: IsJSONminified returned failure" 1>&2
            fi
            # NOTE the current un-minify script works on both minified and unminified JSON so we run it regardless
            # NOTE It needs to run on both to enable future support for displaying the body_text (update notes) section because
            #      it also transforms literal \n in the body_text to newlines
            [[ -f $sFILE ]] && mv "$sFILE" "$sFILE".runtf.bak
            printf '%s' "$sRESPONSE" > "$sFILE"
            if ReformatJSONUsingSed "$sFILE"; then
                ((iDEBUG)) && "($LINENO) RequestURL: ReformatJSONUsingSed returned success" 1>&2
                sMODIFIED_RESPONSE=$(cat "$sFILE")
                printf '%s' "${sMODIFIED_RESPONSE%$'\n'}" # remove the newline added by cat
                return 0
            else
                ((iDEBUG)) && "($LINENO) RequestURL: ReformatJSONUsingSed returned failure" 1>&2
                printf ''
                return 1
            fi
        else
            ((iDEBUG)) && "($LINENO) RequestURL: sRESPONSE is NULL" 1>&2
            printf ''
            return 1
        fi
        printf '%s' "$sRESPONSE"

        return 0
    else
        ((iDEBUG)) && "($LINENO) RequestURL: curl returned failure" 1>&2
        printf ''
        return 1
    fi
}

###############################################################################
# Support different formats for version specification
# Internally, the script uses case-sensitive "base" versions such as "5.9-GE-5-ST" but
# for parsing parameters many other variations are supported. Examples are in usage above.
# NOTE not only does this enable multiple types of input but it also enables reporting
#      with the exact input given which may or may not be helpful in case of an error/problem
# NOTE if the naming format for packages changes, this function also must be adapted
# TODO support even more variations?
CleanUpVersion() {

    local iLENGTH=0
    local sVERSION=${1-}

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "($LINENO) CleanUpVersion: sVERSION is NULL" 1>&2
        return 1
    }

    ((iDEBUG)) && {
        iLENGTH=${#sVERSION}
        echo "($LINENO) CleanUpVersion: before: \"$sVERSION\"" 1>&2
    }

    # global upper case
    sVERSION=${sVERSION^^}
    # anchored left, remove a single "PROTON-" and anything to the left of it
    sVERSION=${sVERSION#*'PROTON-'}
    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    sVERSION=${sVERSION%'.TAR.GZ'*}

    ((iDEBUG)) && {
        echo "($LINENO) CleanUpVersion: after: \"$sVERSION\"" 1>&2
        [[ $iLENGTH -ne ${#sVERSION} ]] && echo "($LINENO) CleanUpVersion: removed $(( iLENGTH - ${#sVERSION} )) characters" 1>&2
    }

    printf '%s' "$sVERSION"

    return 0
}

###############################################################################
# A simple helper function used only for debugging and integration testing
ShowConsoleDiff() {

    [[ $# -ne 2 ]] && { echo "Give me two files to work with numbskull!"; return 1; }

    # iCOLUMNS=$(stty size)
    # iCOLUMNS=${iCOLUMNS##*[[:space:]]}
    if [[ $(shopt checkwinsize) =~ ^checkwinsize.*off$ ]]; then
        shopt -s checkwinsize
        diff --color -csaW${COLUMNS} "$1" "$2"
        shopt -u checkwinsize
    else
        diff --color -csaW${COLUMNS} "$1" "$2"
    fi

    return 0
}

###############################################################################
# Diagnostic tool - exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    # All hope abandon, ye who enter here!
    #-------------------------------------------------------------------------------------

    # WARNING there's no telling what will be here in any given version, or what damage it could cause
    # NOTE It's safe to run -fzZ, but not this
    if [[ $iINTEGRATION_TESTING -eq 1 ]]; then
        CreateSedUnminifyJSONscript

        sTEST=$(RequestURL "$sGE_LATEST_VERSION_URL")

        if IsJSONminified "$sTEST"; then
            #echo "JSON is minified"
            printf '%s' "$sTEST" > "$sGE_INSTALL_PATH/test.minified"
            ReformatJSONUsingSed "$sGE_INSTALL_PATH/test.minified"
            ShowConsoleDiff "$sGE_INSTALL_PATH/test.minified" "$sGE_INSTALL_PATH/test.minified.sedbak"
        fi
        #ReformatJSONUsingSed "$sFILE_LATEST_JSON"
        #ReformatJSONUsingSed "$sFILE_RELEASES_JSON"
        exit
    fi

    #-------------------------------------------------------------------------------------

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>/dev/stdout; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip ps stat sed

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: \"$PWD\""
    echo "SHELL: \"$SHELL\""
    echo "SHELLOPTS: \"$SHELLOPTS\""
    echo "SHLVL: \"$SHLVL\""
    echo "BASH_VERSINFO: \"${BASH_VERSINFO[*]}\""
    echo "BASH_VERSION: \"$BASH_VERSION\""
    echo "MACHTYPE: \"$MACHTYPE\""
    echo "OSTYPE: \"$OSTYPE\""
    echo "PROMPT_COMMAND: \"$PROMPT_COMMAND\""
    echo "LANG: \"$LANG\""
    echo "LC_MESSAGES: \"$LC_MESSAGES\""
    echo "LC_ALL: \"$LC_ALL\""
    echo "EUID: \"$EUID\""
    #echo "${FUNCNAME[@]}"
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Optional command support
ConfigureOptionalCommands() {

    if command -v trash >/dev/null; then
        sCOMMAND_RM="trash"
    fi

    return 0
}

###############################################################################
# Remove temporary paths on EXIT/manual invocation if debug mode is not active
CleanUp() {
    # NOTE must be first
    iREAL_EXIT_STATUS=$? # used to pass the exit status to the calling environment in case of unexpected failure

    [[ -d $sTMP_DIR ]] && {
        if [[ $iDEBUG -eq 0 ]]; then
            if ! $sCOMMAND_RM -rf "$sTMP_DIR"; then
                echo "CleanUp: Failed to remove temporary path at $sTMP_DIR"
                return 1
            fi
        elif [[ $iDEBUG -eq 1 ]]; then
            [[ $iFINAL_CLEANUP -eq 1 ]] && {
                echo "($LINENO) CleanUp: Temporary path saved at: $sTMP_DIR" 1>&2
            }
        fi
    }

    return 0
}

###############################################################################
# Parse command line parameters and set global variables according to what was
# requested. Order of operations for invocations that involve multiple parameters
# is listed at the end of the usage section.
ParseParameters() {
    while getopts 'zZThHflSs:i:d:R:NuUX' sOPT; do
        case "$sOPT" in
            (h) iSHOW_HELP=1 ;;
            (H) iSHOW_USAGE=1 ;;
            (f) iFORCE=1 ;;
            (T) iINTEGRATION_TESTING=1 ;; # -fTzZ (undocumented, used for integration testing new features)
            (z) iDEBUG=1 ;;
            (Z)
                if [[ $iFORCE -eq 1 ]] && [[ $iDEBUG -eq 1 ]]; then
                    ReportEnvironmentInfo # exactly -fzZ (undocumented diagnostic tool)
                fi
            ;;
            (u) iCHECK_UPDATE=1 ;;
            (X) iREMOVE_INSTALL_PATH=1 ;;
            (N) iREMOVE_SAVED_PACKAGES=1 ;;
            (R)
                iREMOVE=1
                sREMOVE_VERSION=$OPTARG
            ;;
            (l) iLIST_INSTALLED_GE_VERSIONS=1 ;;
            (s)
                iREPORT_VERSION_USAGE=1
                sREPORT_VERSION=$OPTARG
            ;;
            (S) iREPORT_INSTALL_PATH_USAGE=1 ;;
            (d)
                iDOWNLOAD=1
                sDOWNLOAD_VERSION=$OPTARG
            ;;
            (i)
                iINSTALL=1
                sINSTALL_VERSION=$OPTARG
            ;;
            (U) iUPDATE=1 ;;
            (":"|"?")
                return 1
            ;;
        esac
    done

    return 0
}

###############################################################################

Main() {

    # Parse script parameters and arguments, set global variables
    if ! ParseParameters "$@"; then
        exit 1
    fi

    # show help and/or usage
    if [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 0 ]]; then
        ShowHelp
        exit
    elif [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowHelp
        ShowUsage
        exit
    elif [[ $iSHOW_HELP -eq 0 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowUsage
        exit
    fi

    # debug mode
    ((iDEBUG)) && {
        echo "($LINENO) Main: Debug mode enabled" 1>&2
    }

    #TODO
    ConfigureOptionalCommands

    #TODO
    CreateSedUnminifyJSONscript

    [[ ! -d $sGE_INSTALL_PATH ]] && {
        if [[ $iDEBUG -eq 1 ]]; then
            mkdir -pv "$sGE_INSTALL_PATH"
        else
            mkdir -p "$sGE_INSTALL_PATH"
        fi
    }

    # checkupdate
    if [[ $iCHECK_UPDATE -eq 1 && $iUPDATE -eq 0 ]]; then
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
    fi

    # remove install path
    if [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 1 ]]; then
        if IsSteamRunning; then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    elif [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 0 ]]; then
        echo "-X must be combined with -f to confirm that you are sure" # "Use the force Harry" ~ Gandalf
    fi

    # remove saved packages
    if [[ $iREMOVE_SAVED_PACKAGES -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]]; then
        # TODO -f required?
        RemoveSavedPackages
    fi

    # remove an installed version or package
    if [[ $iREMOVE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && [[ $iREMOVE_SAVED_PACKAGES -eq 0 ]]; then
        # NOTE sREMOVE_VERSION is set in getops
        RemoveGEVersion "$sREMOVE_VERSION"
    elif [[ $iREMOVE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # downlaod a package
    ((iDOWNLOAD)) && {
        # NOTE sDOWNLOAD_VERSION is set in getops
        DownloadGEPackage "$sDOWNLOAD_VERSION"
    }

    # check for new version and update if it is not installed
    if [[ $iUPDATE -eq 1 ]]; then
        if UpdateSavedGELatestRelease; then
            if GetLatestGEVersion; then # set sGE_LATEST_VERSION
                if IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 1 ]]; then # Latest version is installed and -f is suppled
                    if RemoveGEVersion "$sGE_LATEST_VERSION"; then
                        if InstallGEVersion; then # InstallGEVersion checks iUPDATE then sINSTALL_VERSION and/or sGE_LATEST_VERSION
                            echo "Update succeeded"
                        else
                            echo "Update failed"
                        fi
                    fi
                elif IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 0 ]]; then # Latest version is installed and -f was not supplied
                    ((iDEBUG)) && printf '%s' "($LINENO) Main: Update: "
                    echo "Latest version is already installed ($sGE_LATEST_VERSION)"
                elif ! IsInstalled "$sGE_LATEST_VERSION"; then # Latest version is not installed
                    ((iDEBUG)) && printf '%s' "($LINENO) Main: Update: "
                    echo "Latest version is not installed"
                    if InstallGEVersion; then
                        ((iDEBUG)) && printf '%s' "($LINENO) Main: Update: "
                        echo "Update succeeded"
                        if IsSteamRunning; then echo "Please restart Steam to use the new version"; fi
                    else
                        ((iDEBUG)) && printf '%s' "($LINENO) Main: Update: "
                        echo "Update failed"
                    fi
                fi
            else
                ((iDEBUG)) && printf '%s\n' "($LINENO) Main: Update: GetLatestGEVersion returned failure status" 1>&2
            fi
        else
            # GetLatestGEVersionInfo failed
            ((iDEBUG)) && printf '%s\n' "($LINENO) Main: Update: GetLatestGEVersionInfo returned failure status" 1>&2
            echo "Update failed"
        fi
        # Like purchasing a tribble, this is probably a bad idea
        [[ $iINSTALL -eq 1 ]] && iUPDATE=0 # Reset iUPDATE to 0 so update and install can run in the same invocation
    fi

    # install a package
    if [[ $iINSTALL -eq 1 ]] && [[ $iUPDATE -eq 0 ]]; then
        # NOTE sINSTALL_VERSION is set in getops
        InstallGEVersion "$sINSTALL_VERSION"
    fi

    # list installed versions
    [[ $iLIST_INSTALLED_GE_VERSIONS -eq 1 ]] && ListInstalledGEVersions

    # Report entire install path disk usage and file count
    [[ $iREPORT_INSTALL_PATH_USAGE -eq 1 ]] && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    [[ $iREPORT_VERSION_USAGE -eq 1 ]] && ReportGEDiskUsage "$sREPORT_VERSION"


    # if no parameters were supplied, show help
    # NOTE ignore iFORCE and iDEBUG flags
    if [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && \
       [[ $iREMOVE_SAVED_PACKAGES -eq 0 ]] && \
       [[ $iREMOVE -eq 0 ]] && \
       [[ $iLIST_INSTALLED_GE_VERSIONS -eq 0 ]] && \
       [[ $iREPORT_VERSION_USAGE -eq 0 ]] && \
       [[ $iREPORT_INSTALL_PATH_USAGE -eq 0 ]] && \
       [[ $iDOWNLOAD -eq 0 ]] && \
       [[ $iINSTALL -eq 0 ]] && \
       [[ $iCHECK_UPDATE -eq 0 ]] && \
       [[ $iUPDATE -eq 0 ]]; then

        ((iDEBUG)) && {
            if IsSteamRunning; then
                echo "($LINENO) Main: Steam is running" 1>&2
            else
                echo "($LINENO) Main: Steam is not running" 1>&2
            fi
            echo "($LINENO) Main: Nothing to do" 1>&2
        }

        # report latest version installed status
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
        ShowHelp
    fi

    return 0
}

###############################################################################
# EXIT trap
trap '((iDEBUG)) && echo "Exit status (before CleanUp): $?" 1>&2; iFINAL_CLEANUP=1 CleanUp; ((iDEBUG)) && echo "Exit status (after CleanUp): $?" 1>&2; exit $iREAL_EXIT_STATUS' EXIT

###############################################################################

Main "$@"
