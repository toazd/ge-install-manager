#!/usr/bin/env bash
#shellcheck disable=SC2155
# https://github.com/koalaman/shellcheck/wiki/SC2155

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

set +e # WARNING DO NOT set -e

###############################################################################
# Global notes/intentions/goals
#
#  All non-special variables are written in capital letters, prefixed with a lower-case letter
#   that denotes usage within the scope of that particular variable.
#  This is not a strict requirement by Bash. It's a convenience for reference and readability.
#  When you see a variable prefixed with an 'i' in this script you can be sure that it (almost) always contains only integers.
#  (some 'int' designated variables may contain alphabetic characters temporarily before trimming away all but the digits)
#    eg. iDEBUG will always contain digits and nothing else (integers). Mathematical operator usage involving these variables is always valid.
#    eg. sGE_LATEST_VERSION can and will contain any variety of alphanumeric and/or special/control characters (string).
#    eg. Indexed arrays or associative arrays are prefixed with 'ia' and 'aa' respectively.
#
#  All functions have appropriate return values. Currently, only two states are utilized, 1 (failure) and 0 (success).
#    eg. IsSteamRunning => success(0) = yes, failure(1) = no
#    eg. if InstallGEVersion "5.9-GE-5-ST"; then echo "success"; else echo "failure"; fi
#
#  Functions that 'return' values do so in a manner expecting the use of command substitution (or otherwise connecting to/capturing stdout)
#  and those values are returned exactly as they were received (eg. no additional newlines)
#    eg. iSIZE_BYTES=$(QueryGEAttribute "5.9-GE-t-ST" "size")
#
#  In addition to appropriate return values, functions that are expected to return a value other than an exit status also
#  intentionally return NULL if a non-fatal event occured.
#  (except in the case of GetLatestGEVersion which sets the global variable sGE_LATEST_VERSION to NULL instead)
#  This can be leveraged to better determine the type of event that occured, if any, and what to do about it, if anything
#    eg. QueryGEAttribute will return a NULL value (and exit status failure [1]) if the invoking parameters were syntatically valid,
#        but a value for that version was not found or if that version was not found. Therefore, it is up to the calling function
#        to report the status if appropriate (eg. version not found). To see more details about what each function is doing
#        simply add -z to the parameter list (enable debug mode). The debug mode (typically) makes it very easy to know what went
#        wrong (almost) exactly where and what to do about it (if anything).
#
#  All debug related messages are redirected to file descriptor 2 (which, by default, is stderr). This enables simple and effective filtering of
#  messages when debug mode is enabled. It also keeps debug messages from interfering with functions that pass their output to the caller via stdin.
#
#  Most integer variables (excepting counters) are used simply as boolean values (0 or 1)
#    eg. iDEBUG is either 1 (on) or 0 (off)
#    eg. iINSTALL is either 1 (on, install <version> requested) or 0 (off, install not requested)
#
#  Most of the script logic is written in a "medium" or "long" form so it's easier to quickly grasp what is happening. "Short-hand",
#  "minified", and/or extremely optimized forms are intentionally avoided.
#
#
###############################################################################
# "Things that would be nice, but aren't required for main features" list
#
# TODO Find a way to not download releases so often (updates to download_count update the mtime of the remote file)
# TODO What if githubs anonymous request rate limit is exceeded (60/hr)?
# TODO The script has outgrown getopts. Support for multiple identical parameters per single invocation depends
#      on using something else or simply making a parser
# TODO support for using jq if sed fails to reformat minified JSON how the script expects (or just use jq first if it's available)
#
###############################################################################
# Global variables
sSCRIPT_VERSION="0.7.3"
sSCRIPT_CODENAME="Cochrane Bonaventure"
# ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/
sGE_INSTALL_PATH="$HOME"/.steam/root/compatibilitytools.d
#sSCRIPT_SHORT_NAME="ge-install-manager"
sSCRIPT_FULL_NAME=${0##*/}
sSCRIPT_CONFIG_PATH=${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME
sSCRIPT_CACHE_PATH=${XDG_CACHE_HOME:-"$HOME"/.cache}/$sSCRIPT_FULL_NAME # TODO consider moving saved packages to here instead
# JSON data sources TODO optional support for jq in addition to keeping sed as a fallback
sGE_LATEST_VERSION_URL="https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest"
sGE_RELEASES_URL="https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases"
# HTML data sources (reference only, this script does not currently support html data sources)
# https://github.com/GloriousEggroll/proton-ge-custom/releases
# https://github.com/GloriousEggroll/proton-ge-custom/tags
sFILE_LATEST_JSON="$sSCRIPT_CACHE_PATH"/latest.json
sFILE_RELEASES_JSON="$sSCRIPT_CACHE_PATH"/releases.json
# NOTE JSON is returned minified when a custom User-Agent is used.
# This saves ~25KiB per releases file download and ~0.5KiB per latest file download
sCURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
sCURL_HEADER_USER_AGENT="User-Agent: toazd/$sSCRIPT_FULL_NAME/$sSCRIPT_VERSION"
sCURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
sGE_LATEST_VERSION=''
sFILE_SCRIPT_CONFIG=$sSCRIPT_CONFIG_PATH/$sSCRIPT_FULL_NAME.conf
sFILE_SED_UNMINIFY_SCRIPT="$sSCRIPT_CONFIG_PATH/unminify-JSON.sed" # TODO consider moving to XDG_DATA_HOME
sCOMMAND_RM="rm" # command 'trash' replaces 'rm' if it is found
sTMP_BASE_PATH=/tmp
sTMP_PREFIX="$sSCRIPT_FULL_NAME.tmp."
# some script functionality depends on the following being initialized as 0
iFORCE=0
iDEBUG=0
iDOWNLOAD=0
iINSTALL=0
iREMOVE=0
iUPDATE=0
iVERIFY=0
iREMOVE_INSTALL_PATH=0
iREMOVE_SAVED_PACKAGES=0
iLIST_INSTALLED_GE_VERSIONS=0
iREPORT_VERSION_USAGE=0
iREPORT_INSTALL_PATH_USAGE=0
iSHOW_HELP=0
iSHOW_USAGE=0
iCHECK_UPDATE=0
iINTEGRATION_TESTING=0
iSIZE_BYTES_SED_UNMINIFY_SCRIPT=824
iREAL_EXIT_STATUS=0
OPTERR=1 # make sure it's on

###############################################################################
# TODO
ShowHelp() {
    cat <<HELP_MESSAGE

    $(basename "$0")  v$sSCRIPT_VERSION "$sSCRIPT_CODENAME"

    Required:       Bash 3.2+(TBD), curl, sed, tar, gzip, stat, wc
    Optional:       du (display disk usage of a path/file)
                    ps (is steam running)
                    sort, cmp (verify)
                    trash (used in place of of rm [excluding temporary files])

    Install path:          $sGE_INSTALL_PATH
    Latest version URL:    $sGE_LATEST_VERSION_URL
    Releases URL:          $sGE_RELEASES_URL

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
                      Combine with -f to also remove the saved package
    -V            - Verify each installation using its saved package
                      Combined with -v, -V will be skipped
                      Saved packages will be downloaded as needed
    -v <version>  - Verify <version> using its saved package
    -d <version>  - Download the package for <version> and save it to the install path
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      -f is also required to confirm that you are sure
                      NOTE: Saved packages are currently stored in the installation path
    -f            - Force install, upgrade, or remove
                      Combined with -U and/or -i, remove saved package and download a new copy
                      Combined with -R to remove a saved package (even if that version is not installed)
    -z            - Enable debug mode
                      Enable extra output messages and preserve any temporary files created

HELP_MESSAGE

    return 0
}

###############################################################################
# TODO
ShowUsage() {
    cat <<USAGE_MESSAGE
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle,
      Report environment info (-fzZ),
      Show help,
      Show usage,
      Debug toggle,
      Check for latest release,
      Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Download,
      Update,
      Install,
      List installed,
      Report install path usage,
      Report specific version usage
      Verify

USAGE_MESSAGE

    return 0
}

###############################################################################
# Sets the global variable sGE_LATEST_VERSION to the latest version
# TODO *might* want to check releases if latest fails.
GetLatestGEVersion() {

    # WARNING DO NOT make this local
    sGE_LATEST_VERSION=''

    if UpdateSavedGELatestRelease; then
        while IFS= read -r; do
            # WARNING do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST",
            #         they are not always the same name as the package
            # NOTE must be compatible with all 3 of the following potential formats
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            [[ $REPLY =~ ^.*\"name\":.*\"Proton-.*\.tar\.gz\".*$ ]] && {
                DebugMessage "matched line \"$REPLY\""
                sGE_LATEST_VERSION=${REPLY#*\"name\":}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION#*\"}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION%.tar.gz\"*}
                DebugMessage "sGE_LATEST_VERSION set to \"$sGE_LATEST_VERSION\""
                break
            }
        done < "$sFILE_LATEST_JSON"

        [[ -z $sGE_LATEST_VERSION ]] && {
            DebugMessage "sGE_LATEST_VERSION is NULL (no match or not found)"
            return 1
        }
    else
        DebugMessage "UpdateSavedGELatestRelease returned failure status"
        return 1
    fi

    return 0
}

###############################################################################
# Retrieve "latest" JSON from sGE_LATEST_VERSION_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGELatestRelease() {

    local sGE_LATEST_RELEASE_JSON=''

    DebugMessage "Using RequestURL to check if \"$sGE_LATEST_VERSION_URL\" is newer than \"$sFILE_LATEST_JSON\""

    if sGE_LATEST_RELEASE_JSON=$(RequestURL "$sGE_LATEST_VERSION_URL" "$sFILE_LATEST_JSON"); then
        DebugMessage "RequestURL returned success"
    else
        DebugMessage "RequestURL returned failure"
    fi

    # check the response and report and respond accordingly
    if [[ -n $sGE_LATEST_RELEASE_JSON ]]; then
        DebugMessage "sGE_LATEST_RELEASE_JSON is not empty"
        [[ -f $sFILE_LATEST_JSON.ulrbak ]] && $sCOMMAND_RM "$sFILE_LATEST_JSON".ulrbak
        [[ -f $sFILE_LATEST_JSON ]] && mv "$sFILE_LATEST_JSON" "$sFILE_LATEST_JSON".ulrbak
        printf '%s' "$sGE_LATEST_RELEASE_JSON" > "$sFILE_LATEST_JSON"
        return 0
    elif [[ -z $sGE_LATEST_RELEASE_JSON ]]; then
        DebugMessage "sGE_LATEST_RELEASE_JSON is NULL"
        if [[ ! -f $sFILE_LATEST_JSON ]]; then
            echo "Response from RequestURL was NULL and file \"$sFILE_LATEST_JSON\" not found. Is \"$sGE_LATEST_VERSION_URL\" a valid URL?"
            return 1
        fi
    fi

    return 0
}

###############################################################################
# Retrieve "releases" JSON from sGE_RELEASES_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGEReleases() {

    local sGE_RELEASES_JSON=''

    # BUG updates to download_count in remote releases cause curl -z to download a new version much more often than is needed
    DebugMessage "Using RequestURL to check if \"$sGE_RELEASES_URL\" is newer than \"$sFILE_RELEASES_JSON\""

    if sGE_RELEASES_JSON=$(RequestURL "$sGE_RELEASES_URL" "$sFILE_RELEASES_JSON"); then
        DebugMessage "RequestURL returned success"
    else
        DebugMessage "RequestURL returned failure"
    fi

    if [[ -n $sGE_RELEASES_JSON ]]; then
        DebugMessage "sGE_RELEASES_JSON is not empty"
        [[ -f $sFILE_RELEASES_JSON.usrbak ]] && $sCOMMAND_RM "$sFILE_RELEASES_JSON".usrbak
        [[ -f $sFILE_RELEASES_JSON ]] && mv "$sFILE_RELEASES_JSON" "$sFILE_RELEASES_JSON".usrbak
        printf '%s' "$sGE_RELEASES_JSON" > "$sFILE_RELEASES_JSON"
        return 0
    elif [[ -z $sGE_RELEASES_JSON ]]; then
        DebugMessage "sGE_RELEASES_JSON is NULL"
        if [[ ! -f $sFILE_RELEASES_JSON ]]; then
            echo "Response from RequestURL was NULL and file \"$sFILE_RELEASES_JSON\" not found. Is \"$sGE_RELEASES_URL\" a valid URL?"
            return 1
         fi
    fi

    return 0
}

###############################################################################
# Attempt to download a package (Proton*.tar.gz) using a tmp path.
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
DownloadGEPackage() {

    local sVERSION=$(CleanUpVersion "$1")
    [[ -z $sVERSION ]] && { DebugMessage "Parameter error (NULL)"; return 1; }
    local sTMP_PATH=$(MkTempPath)
    local sTMP_PACKAGE=$sTMP_PATH/Proton-${sVERSION}.tar.gz
    local sGE_DOWNLOAD_URL=$(QueryGEAttribute "$sVERSION" "browser_download_url")
    local iSIZE_BYTES=''

    [[ -z $sGE_DOWNLOAD_URL ]] && { DebugMessage "sGE_DOWNLOAD_URL is NULL"; return 1; }

    echo "Downloading \"$sGE_DOWNLOAD_URL\""
    if curl -# -L "$sGE_DOWNLOAD_URL" -o "$sTMP_PACKAGE"; then
        iSIZE_BYTES=$(stat -c '%s' "$sTMP_PACKAGE")
        DebugMessage "Package size in bytes: \"$iSIZE_BYTES\""
        if [[ $iSIZE_BYTES -eq 9 ]] || [[ $(cat "$sTMP_PACKAGE" 2>/dev/null) =~ ^[Nn]ot[[:blank:]]+[Ff]ound$ ]]; then
            echo "Server responded \"Not Found\" for version \"$sVERSION\""
            CleanUp
            return 1
        fi
        if [[ $iSIZE_BYTES = "$(QueryGEAttribute "$sVERSION" "size")" ]]; then
            echo "Downloaded package is the expected size"
        else
            printf '%s\n%s\n' \
                   "Downloaded file size and expected size do not match" \
                   "(\"$iSIZE_BYTES\" vs \"$(QueryGEAttribute "$sVERSION" "size")\")"
           CleanUp
           return 1
        fi
        DebugMessage "Copying package \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\""
        if cp "$sTMP_PACKAGE" "$sGE_INSTALL_PATH"; then
            DebugMessage "Package copied successfully"
            echo "Download succeeded"
            CleanUp
        else
            DebugMessage "Copy package from \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\" failed"
            echo "Download failed"
            CleanUp
            return 1
        fi
    else
        DebugMessage "'curl' returned failure status"
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Install a GE version using either a saved package or downloading a new one
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
# NOTE sINSTALL_VERSION is set in getops when -i is invoked
# NOTE If -u and -i are both invoked, the update will run first and then the install, if needed
InstallGEVersion() {

    local sVERSION=''

    DebugMessage "Determining mode"
    if [[ $iUPDATE -eq 1 ]]; then
        DebugMessage "Update mode active"
        [[ -z $sGE_LATEST_VERSION ]] && {
            if GetLatestGEVersion; then
                DebugMessage "GetLatestGEVersion returned success"
                sVERSION=$sGE_LATEST_VERSION
            else
                DebugMessage "GetLatestGEVersion returned failure"
                return 1
            fi
        }
    elif [[ $iUPDATE -eq 0 ]]; then
        DebugMessage "Install mode active"
        sVERSION=${sINSTALL_VERSION:-$(CleanUpVersion "$1")}
    else
        DebugMessage "Unknown error detecting install mode"
        return 1
    fi

    sVERSION=$(CleanUpVersion "$1")

    [[ -z $sVERSION ]] && { DebugMessage "sVERSION is NULL"; return 1; }

    DebugMessage "Requested sVERSION is \"$sVERSION\""

    # Re-install a version that is already installed
    if IsInstalled "$sVERSION"; then
        if [[ $iFORCE -eq 0 ]]; then
            echo "Version \"$sVERSION\" is already installed"
            return 0
        elif [[ $iFORCE -eq 1 ]]; then
            if IsSteamRunning; then
                echo "Please close Steam before re-installing a version that is already installed"
                return 1
            else
                echo "Forcing re-install of version \"$sVERSION\""
            fi
        fi
    fi

    # if a saved package exists and force mode is not active
    if [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 0 ]]; then
        echo "Using saved package: \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if ExtractGEPackage "$sVERSION"; then
            return 0
        else
            return 1
        fi
    # if a saved package exists and force mode is active
    elif [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 1 ]]; then
        echo "Removing saved package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if $sCOMMAND_RM "$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz"; then
            echo "Package removed"
        else
            echo "Removing package failed"
            return 1
        fi
    fi

    # If a saved package for this version doesn't exist or it was removed, download it and install it
    if DownloadGEPackage "$sVERSION"; then
        if ExtractGEPackage "$sVERSION"; then
            echo "Installation of version \"$sVERSION\" was successful"
            return 0
        else
            echo "Installation of version \"$sVERSION\" failed"
            return 1
        fi
    else
        echo "Version \"$sVERSION\" not found"
        return 1
    fi

    return 0
}

###############################################################################
# Removes an installed version path and package (if -f is also supplied)
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE supports removing the package specified by version even if that version is not installed
#      when the -f parameter is combined with -R
RemoveGEVersion() {

    local sVERSION=$(CleanUpVersion "$1")
    local sREMOVE_PATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
    local sREMOVE_PACKAGE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz
    local sSIZE="0"

    [[ -z $sVERSION ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    DebugMessage "Requested sVERSION: \"$sVERSION\" sREMOVE_PATH: \"$sREMOVE_PATH\" sREMOVE_PACKAGE: \"$sREMOVE_PACKAGE\""
    # If force is enabled, remove the path and the package
    if [[ $iFORCE -eq 1 ]]; then
        DebugMessage "Force mode is enabled"
        # Remove the path if it exists
        if [[ -d $sREMOVE_PATH ]]; then
            DebugMessage "sREMOVE_PATH exists"
            if ! IsSteamRunning; then
                sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
                sSIZE=${sSIZE%[[:space:]]*}
                if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                    echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
                else
                    echo "Failed to remove \"$sREMOVE_PATH\""
                    return 1
                fi
            else
                echo "Please close Steam before removing an install path"
                return 1
            fi
        else
            DebugMessage "sREMOVE_PACKAGE does not exist"
            echo "Install path not found for version \"$sVERSION\""
        fi
        # Remove the package if it exists
        if [[ -f $sREMOVE_PACKAGE ]]; then
            DebugMessage "sREMOVE_PACKAGE exists"
            sSIZE=$(du -h "$sREMOVE_PACKAGE" 2>/dev/null)
            sSIZE=${sSIZE%[[:space:]]*}
            if $sCOMMAND_RM -f "$sREMOVE_PACKAGE" >/dev/null; then
                echo "Removed package \"$sREMOVE_PACKAGE\" (${sSIZE:-'error'})"
            else
                echo "Failed to remove package \"$sREMOVE_PACKAGE\""
                return 1
            fi
        else
            DebugMessage "sREMOVE_PACKAGE does not exist"
            echo "Package \"$sREMOVE_PACKAGE\" not found"
        fi
    # If force is not enabled, remove only the install path for sVERSION
    elif [[ $iFORCE -eq 0 ]]; then
        DebugMessage "Force is not enabled"
        # Remove the path if it exists
        if [[ -d $sREMOVE_PATH ]]; then
            if ! IsSteamRunning; then
                sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
                sSIZE=${sSIZE%[[:space:]]*}
                if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                    echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
                else
                    echo "Failed to remove \"$sREMOVE_PATH\""
                    return 1
                fi
            else
                echo "Please close Steam before removing an install path"
                return 1
            fi
        else
            DebugMessage "Install path does not exist"
            echo "Install path not found for version \"$sVERSION\""
        fi
        [[ -f $sREMOVE_PACKAGE ]] && {
            echo "Saved package not removed \"$sREMOVE_PACKAGE\" (include -f to remove it)"
        }
    fi

    return 0
}

###############################################################################
# Extracts a saved package (Proton-*.tar.gz) in the install path to the install path
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
# Accepts one optional second parameter, the path to extract the package to
ExtractGEPackage() {

    local sVERSION=$(CleanUpVersion "$1")
    local sEXTRACT_FILE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz
    local sEXTRACT_PATH=${2:-$sGE_INSTALL_PATH}

    [[ -z $sVERSION ]] && {
        DebugMessage "Parameter error (NULL)"
        return 1
    }

    [[ ! -d $sEXTRACT_PATH && -w $sEXTRACT_PATH ]] && {
        DebugMessage "Parameter error (Not a valid path)"
        return 1
    }

    printf '%s' "Extracting \"$sEXTRACT_FILE\" to \"$sEXTRACT_PATH\""
    if tar --checkpoint=.10000 -C "$sEXTRACT_PATH" -xzf "$sEXTRACT_FILE" 2>/dev/null; then
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        printf '\r\033[0K%s\n' "Package extraction failed"
        [[ -d $sEXTRACT_PATH/Proton-${sVERSION} ]] && {
            DebugMessage "Removing failed extraction path \"$sEXTRACT_PATH/Proton-${sVERSION}\""
            if $sCOMMAND_RM -rf "$sEXTRACT_PATH/Proton-${sVERSION}"; then
                DebugMessage "Removal succeeded"
                echo "Removed failed extraction path at \"$sEXTRACT_PATH/Proton-${sVERSION}\""
            else
                echo "Failed to remove path of failed extraction: \"$sEXTRACT_PATH/Proton-${sVERSION}\""
                # TODO update/remove message when install verification is updated
                echo "This script may interpret it as a valid install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# List the currently installed GE versions and any saved packages
ListInstalledGEVersions() {

    local iCOUNT=0
    local sNODE
    #local sEXTRACTED_VERSION=''

    DebugMessage "Install path: \"$sGE_INSTALL_PATH\""

    echo "Installed version(s):"
    for sNODE in "$sGE_INSTALL_PATH"/*; do
        if [[ -d $sNODE ]]; then
            #sEXTRACTED_VERSION=$(cat "$sNODE"/version 2>/dev/null)
            #sEXTRACTED_VERSION=${sEXTRACTED_VERSION#*[[:blank:]]}
            #if [[ -z $sEXTRACTED_VERSION ]] || [[ $sEXTRACTED_VERSION = "file not found" ]]; then sEXTRACTED_VERSION="error: version file not found"; fi
            #echo "  ${sNODE##*/} ($sEXTRACTED_VERSION)"
            echo "  ${sNODE##*/} ($(du -sh "$sNODE" | cut -f1))"
            ((iCOUNT++))
        fi
    done
    [[ $iCOUNT -eq 0 ]] && echo "None found"

    echo "Saved package(s):"
    sNODE=''
    iCOUNT=0
    for sNODE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sNODE ]]; then
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "${sNODE##*/} (size: $(stat -c '%s' "$sNODE"), expected size: $(QueryGEAttribute "${sNODE##*/}" "size"))"
            else
                echo "  ${sNODE##*/} ($(du -h "$sNODE" | cut -f1))"
            fi
            ((iCOUNT++))
        fi
    done
    if [[ $iCOUNT -ge 1 ]]; then
        echo "Saved packages disk usage: $(du -csh "$sGE_INSTALL_PATH/"*.tar.gz | tail -n1 | cut -f1)"
    elif [[ $iCOUNT -eq 0 ]]; then
        echo "None found"
    fi

    return 0
}

###############################################################################
# Report disk usage and file counts for the install path and/or a specified installed version
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
ReportGEDiskUsage() {

    local sVERSION=$(CleanUpVersion "$1")
    local sPATH=''
    local sSIZE="0"
    local iFAILED=0

    # NOTE do not return 1 if sVERSION is NULL, functionality below depends on it

    if ! command -v du >/dev/null && ! command -v find >/dev/null && ! command -v wc >/dev/null; then
        iFAILED=1
    fi

    # if all checks succeeded
    if [[ $iFAILED -eq 0 ]]; then
        # set the path to be reported based on whether a version was provided or not
        if [[ -z $sVERSION ]]; then
            # report the file count and disk usage for the entire install path
            sPATH=$sGE_INSTALL_PATH
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                DebugMessage "Path: $sPATH"
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
        if [[ -n $sVERSION ]]; then
            # Report the file count and disk usage for a specific version
            sPATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Version \"$sVERSION\" report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                DebugMessage "Path: $sPATH"
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
    # if any check failed
    elif [[ $iFAILED -eq 1 ]]; then
        DebugMessage "At least one optional command was not found"
        echo "One or more optional commands not found (see -h). Report not available."
        return 1
    fi

    return 0
}

###############################################################################
# Removes all saved packages in the install path defined by the global variable sGE_INSTALL_PATH
# NOTE a package is any regular file that matches the glob pattern "Proton-*.tar.gz"
RemoveSavedPackages() {

    local iSUCCESS=0
    local iFAILED=0

    DebugMessage "Install path: \"$sGE_INSTALL_PATH\""

    for sPACKAGE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sPACKAGE ]]; then
            if $sCOMMAND_RM -f "$sPACKAGE"; then
                if [[ $iDEBUG -eq 1 ]]; then
                    DebugMessage "Package \"$sPACKAGE\" removed"
                else
                    echo "Removed package \"$sPACKAGE\""
                fi
                ((iSUCCESS++))
            else
                echo "Remove \"$sPACKAGE\" failed"
                ((iFAILED++))
            fi
        fi
    done

    if [[ $iSUCCESS -eq 0 ]]; then
        echo "0 packages removed"
    elif [[ $iSUCCESS -gt 0 ]]; then
        echo "$iSUCCESS packages removed"
    fi

    [[ $iFAILED -gt 0 ]] && {
        echo "Failed to remove $iFAILED package(s)"
        return 1
    }

    return 0
}

###############################################################################
# Removes the path defined by the global variable sGE_INSTALL_PATH
# NOTE currently requires -f to be combined with -X
RemoveGEInstallPath() {

    local sSIZE="0"

    if command -v du >/dev/null; then
        sSIZE=$(du -sh "$sGE_INSTALL_PATH")
    else
        DebugMessage "Command du not found"
        sSIZE="unknown"
    fi

    if $sCOMMAND_RM -rf "$sGE_INSTALL_PATH"; then
        echo "Remove install path succeeded ( ${sSIZE%%[[:blank:]]*} removed )"
        DebugMessage "Recreating install path at \"$sGE_INSTALL_PATH\""
        if mkdir -p "$sGE_INSTALL_PATH"; then
            DebugMessage "Creation succeeded"
        else
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "Creation failed"
            else
                echo "Warning: failed to re-create install path at \"$sGE_INSTALL_PATH\""
                return 1
            fi
        fi
    else
        echo "Removal of install path \"$sGE_INSTALL_PATH\" failed"
        return 1
    fi

    return 0
}

###############################################################################
# TODO sort, cmp,
VerifyGEInstall() {

    local sNODE
    local sTMP_PATH=$(MkTempPath)
    local sVERSION=$(CleanUpVersion "$1")
    local iaEXTRACTED=()
    local iaINSTALLED=()
    local iMATCH_COUNTER=0
    local iMISSING_COUNTER=0
    local iMISMATCH_COUNTER=0
    local iFILE_COUNT_MATCH=0
    local iCOUNTER=0
    local iCOUNTER_EXTRACTED=0
    local iCOUNTER_INSTALLED=0
    local iSTART_TIME_SECONDS=0 # NOTE bash 5+ is required for EPOCHSECONDS
    local iEND_TIME_SECONDS=0   # NOTE bash 4.2+ is required for printf $()T
    local iPROGRESS=0
    local iPREV_PROGRESS=1

    # Required external commands
    if ! command -v cmp >/dev/null && ! command -v sort >/dev/null; then
        echo "Command 'cmp' is required to use this function"
        return 1
    fi

    # Check for install paths that don't have a saved package, download if missing
    for sNODE in "$sGE_INSTALL_PATH/Proton-"*; do
        [[ -d $sNODE ]] && {
            # Verify that it is installed
            IsInstalled "${sNODE##*/}" && {
                # If no saved package exists for this version
                [[ ! -f $sGE_INSTALL_PATH/${sNODE##*/}.tar.gz ]] && {
                    echo "Package not found for installed version \"${sNODE##*/}\""
                    DownloadGEPackage "${sNODE##*/Proton-}"
                }
            }
        }
    done

    # For each saved package available, check each file of the contents against the install path if it exists
    for sNODE in "$sGE_INSTALL_PATH"/Proton-${sVERSION:-*}.tar.gz; do
        [[ -f $sNODE ]] && {
            sVERSION=$(CleanUpVersion "${sNODE##*/}")
            #[[ $sNODE != *Proton-5.9-GE-TEST-ST* ]] && continue
            echo "Found a package for version \"$sVERSION\""
            if ! IsInstalled "$sVERSION"; then
                echo "Version \"$sVERSION\" is not installed"
                continue
            else
                echo "Version \"$sVERSION\" is installed"
                if ! ExtractGEPackage "$sVERSION" "$sTMP_PATH"; then
                    return 1
                fi

                # create two indexed arrays, each containing a seperate list of files, one from the extracted path and the other from the installed path respectively
                #printf '\033[s%s' "Indexing files to compare"
                # NOTE __pycache__ is created at runtime and will not be present in the saved packages
                echo "Indexing files to compare"
                while IFS= read -r sFILE_EXTRACTED; do
                    iaEXTRACTED+=("$sFILE_EXTRACTED")
                done < <(find "$sTMP_PATH/Proton-${sVERSION}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)
                while IFS= read -r sFILE_INSTALLED; do
                    iaINSTALLED+=("$sFILE_INSTALLED")
                done < <(find "$sGE_INSTALL_PATH/Proton-${sVERSION}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)

                # Report files found in each
                #printf "\033[u\033[0K%s\n" "${#iaEXTRACTED[@]} (extracted files) vs ${#iaINSTALLED[@]} (installed files)"
                echo "${#iaEXTRACTED[@]} (extracted) vs ${#iaINSTALLED[@]} (installed)"

                # Based on array element sizes, decide on a method to compare files
                #if [[ $(true) = "$(false)" ]]; then
                if [[ ${#iaEXTRACTED[@]} -ne ${#iaINSTALLED[@]} ]]; then
                    #DebugMessage "Array sizes do not match: ${#iaEXTRACTED[@]} vs ${#iaINSTALLED[@]}"
                    DebugMessage "Array sizes are not equal"
                    echo "Using slower method for comparing"
                    iFILE_COUNT_MATCH=0
                else
                    #DebugMessage "Array sizes match: ${#iaEXTRACTED[@]} vs ${#iaINSTALLED[@]}"
                    DebugMessage "Array sizes are equal"
                    echo "Using faster method for comparing"
                    iFILE_COUNT_MATCH=1
                fi

                # begin comparing, using the faster method
                # NOTE do not output to console during the either compare loop
                printf '%s\033[s' "Comparing files"
                # if the number of entries match, check them directly against eachother
                if [[ $iFILE_COUNT_MATCH -eq 1 ]]; then
                    iTOTAL_FILES=${#iaEXTRACTED[@]}
                    iSTART_TIME_SECONDS=$(date +%s)
                    for iCOUNTER in "${!iaEXTRACTED[@]}"; do
                        cmp -s "${iaEXTRACTED[iCOUNTER]}" "${iaINSTALLED[iCOUNTER]}"
                        case $? in
                            (0) ((iMATCH_COUNTER++)) ;;
                            (1) ((iMISMATCH_COUNTER++)) ;;
                            (2) ((iMISSING_COUNTER++)) ;;
                        esac
                        # 1 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 2 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 3 - do nothing - 5.9-GE-3-ST - 6 seconds

                        # 1 - 5.9-GE-3-ST - 6 seconds
                        # 2 - 5.9-GE-3-ST - 7 seconds
                        # 3 - 5.9-GE-3-ST - 7 seconds
                        #unset 'iaINSTALLED[iCOUNTER]'
                        #unset 'iaEXTRACTED[iCOUNTER]'

                        # Progress report
                        iPROGRESS=$(((iCOUNTER*100)/iTOTAL_FILES))
                        [[ $iPROGRESS -ne $iPREV_PROGRESS ]] && printf '\033[u%s' "... ${iPROGRESS}%" # Only update the progress when it actually changes
                        iPREV_PROGRESS=$iPROGRESS
                    done
                    iEND_TIME_SECONDS=$(date +%s)
                # begin comparing, using the slower method
                # if the number of elements don't match, check only the files that appear in the archive
                # NOTE this method is quite a bit slower TODO learn a better way
                # for each file in iaEXTRACTED, find the entry in iaINSTALLED that matches it (as much as is possible), then compare them
                elif [[ $iFILE_COUNT_MATCH -eq 0 ]]; then
                    iTOTAL_FILES=${#iaEXTRACTED[@]}
                    iSTART_TIME_SECONDS=$(date +%s)
                    for iCOUNTER_EXTRACTED in "${!iaEXTRACTED[@]}"; do
                        # strip away the part of the path that is different for the current file
                        sCOMPARE_EXTRACTED=${iaEXTRACTED[iCOUNTER_EXTRACTED]/#$sTMP_PATH\/}

                        for iCOUNTER_INSTALLED in "${!iaINSTALLED[@]}"; do
                            # strip away the part of the path that is different for the current file
                            sCOMPARE_INSTALLED=${iaINSTALLED[iCOUNTER_INSTALLED]/#$sGE_INSTALL_PATH\/}

                            if [[ $sCOMPARE_INSTALLED = "$sCOMPARE_EXTRACTED" ]]; then
                                cmp -s "${iaINSTALLED[iCOUNTER_INSTALLED]}" "${iaEXTRACTED[iCOUNTER_EXTRACTED]}"
                                case $? in
                                    (0) ((iMATCH_COUNTER++)) ;;
                                    (1) ((iMISMATCH_COUNTER++)) ;;
                                    (2) ((iMISSING_COUNTER++)) ;;
                                esac
                                # fastest - 5.9-GE-3-ST - 246 seconds
                                unset 'iaINSTALLED[iCOUNTER_INSTALLED]'

                                # do nothing1 - 5.9-GE-3-ST - 376 seconds
                                # do nothing2 - 5.9-GE-3-ST - 484 seconds

                                # 5.9-GE-3-ST - 486 seconds
                                #iaINSTALLED=(${iaINSTALLED[@]:0:$iCOUNTER_INSTALLED} ${iaINSTALLED[@]:$((iCOUNTER_INSTALLED+1))})

                                # 5.9-GE-3-ST - 398 seconds
                                #iaINSTALLED=("${iaINSTALLED[@]:0:$iCOUNTER_INSTALLED}" "${iaINSTALLED[@]:$((iCOUNTER_INSTALLED+1))}")

                                #unset 'iaEXTRACTED[iCOUNTER_EXTRACTED]'
                                #iaEXTRACTED=(${iaEXTRACTED[@]:0:$iCOUNTER_EXTRACTED} ${iaEXTRACTED[@]:$((iCOUNTER_EXTRACTED+1))})
                                #iTOTAL_FILES=${#iaEXTRACTED[@]}
                            fi
                        done

                        # Progress report
                        iPROGRESS=$(((iCOUNTER_EXTRACTED*100)/iTOTAL_FILES))
                        [[ $iPROGRESS -ne $iPREV_PROGRESS ]] && printf '\033[u%s' "... ${iPROGRESS}%" # Only update the progress when it actually changes
                        iPREV_PROGRESS=$iPROGRESS
                    done
                    iEND_TIME_SECONDS=$(date +%s)
                fi
                printf "\033[u\033[0K%s\n" ". Finished in $((iEND_TIME_SECONDS-iSTART_TIME_SECONDS)) seconds."

                echo "$iMATCH_COUNTER files match. $iMISSING_COUNTER files are missing. $iMISMATCH_COUNTER do not match."
            fi
            #quit after one round
            #return 0
        }
    done

    return 0
}

###############################################################################
# Wrapper for QueryGEAttribute to first check latest.json, then if a value is not returned, check releases.json
# Accepts two required parameters, version and attribute, returns the value or NULL if not found/error
# NOTE attributes are validated in QueryJSONAttribute
QueryGEAttribute() {

    [[ -z $1 || -z $2 || $# -ne 2 ]] && {
        DebugMessage "Parameter error 1: \"$1\" 2: \"$2\" \$#: \"$#\""
        return 1
    }

    local sVERSION=$(CleanUpVersion "$1")
    local sVALUE=''
    local sATTRIBUTE=$2
    local iEXIT_STATUS

    if UpdateSavedGELatestRelease; then
        DebugMessage "UpdateSavedGELatestRelease returned success"
    else
        DebugMessage "UpdateSavedGELatestRelease returned failure"
    fi

    sVALUE=$(QueryJSONAttribute "$sFILE_LATEST_JSON" "$sVERSION" "$sATTRIBUTE")
    iEXIT_STATUS=$?
    if [[ $iDEBUG -eq 1 && $iEXIT_STATUS -gt 0 ]]; then
        DebugMessage "QueryJSONAttribute returned failure"
    elif [[ $iDEBUG -eq 1 && $iEXIT_STATUS -eq 0 ]]; then
        DebugMessage "QueryJSONAttribute returned success"
    elif ((iDEBUG)); then
        DebugMessage "QueryJSONAttribute unknown exit status \$?: \"$?\""
    fi

    # if the returned value from QueryJSONAttribute was NULL, try searching in releases
    if [[ -z $sVALUE ]]; then
        if UpdateSavedGEReleases; then
            DebugMessage "UpdateSavedGEReleases returned success"
        else
            DebugMessage "UpdateSavedGEReleases returned failure"
        fi

        sVALUE=$(QueryJSONAttribute "$sFILE_RELEASES_JSON" "$sVERSION" "$sATTRIBUTE")
        iEXIT_STATUS=$?
        ((iDEBUG)) && {
            if [[ $iEXIT_STATUS -gt 0 ]]; then
                DebugMessage "QueryJSONAttribute returned failure status"
            elif [[ $iEXIT_STATUS -eq 0 ]]; then
                DebugMessage "QueryJSONAttribute returned success status"
            else
                DebugMessage "QueryJSONAttribute unknown exit status \$?: \"$?\""
            fi
        }
    fi

    if [[ -n $sVALUE ]]; then
        printf '%s' "$sVALUE"
        return 0
    else
        printf ''
        return 1
    fi

    # NOTE do not return 0/1 here
}

###############################################################################
# Return the value of a requested attribute from a saved latest/releases JSON file
# value = $( QueryJSONAttribute "file.json" "version" "attribute")
# NOTE This function relies on the JSON being in an exact order, if that order is changed (eg. by the github api) this function will cease to work
# Example JSON order expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE the default media-type requested is "application/vnd.github.v3.text+json" (I may make use of the body_text which generally contains change/update notes)
QueryJSONAttribute() {

    if [[ $# -ne 3 ]] || [[ ! -f $1 ]] || [[ -z $1 || -z $2 || -z $3 ]]; then
        DebugMessage "Invalid parameter error 1: \"$1\" 2: \"$2\" 3: \"$3\" \$#: \"$#\""
        return 1
    fi

    [[ ${3,,} != @(size|browser_download_url) ]] && {
        DebugMessage "Unsupported attribute requested \"$2\""
        return 1
    }

    local sVERSION=''
    local iSIZE=''
    local sBROWSER_URL=''
    local sATTRIBUTE=''
    local iLINE_COUNTER=0
    local iLINE_VERSION_FOUND=0
    local iLINE_SIZE_FOUND=0
    local iLINE_BROWURL_FOUND=0
    local iFLAG_VERSION_FOUND=0
    local iFLAG_SIZE_FOUND=0
    #local iFLAG_BROWURL_FOUND=0

    sVERSION=$(CleanUpVersion "$2")

    [[ -z $sVERSION ]] && {
        DebugMessage "sVERSION is NULL"
        return 1
    }

    sATTRIBUTE=${3,,}

    # WARNING do not manually output to stdout in this loop (unless you connect the file to different fd, and set read -u accordingly)
    # NOTE stderr is redirected to /dev/null, I don't rememeber why (probably before all debug messages were redirected to fd2/stderr)
    while IFS= read -r; do
        ((iLINE_COUNTER++))
        # version match
        # sVERSION example: 5.9-GE-5-ST
        # NOTE must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        [[ $REPLY =~ ^.*\"name\":.*\"Proton-${sVERSION}\.tar\.gz\".*$ ]] && {
            iFLAG_VERSION_FOUND=1
            iLINE_VERSION_FOUND=$iLINE_COUNTER
        }

        # NOTE must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        [[ $iFLAG_VERSION_FOUND -eq 1 ]] && {
            [[ ${REPLY,,} =~ ^.*\"size\":.*[[:digit:]]+.*$ ]] && {
                iFLAG_SIZE_FOUND=1
                iLINE_SIZE_FOUND=$iLINE_COUNTER
                iSIZE=${REPLY//[[:space:]]}
                iSIZE=${iSIZE/#\"size\":}
                iSIZE=${iSIZE%%[[:punct:]]*} # iSIZE=${iSIZE%,*}
                continue
            }
        }

        # NOTE must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        [[ $iFLAG_VERSION_FOUND -eq 1 && $iFLAG_SIZE_FOUND -eq 1 ]] && {
            [[ $REPLY =~ ^.*\"browser_download_url\":.*\".*Proton-${sVERSION}\.tar\.gz\".*$ ]] && {
                #iFLAG_BROWURL_FOUND=1
                iLINE_BROWURL_FOUND=$iLINE_COUNTER
                sBROWSER_URL=${REPLY/#*\"browser_download_url\":}
                sBROWSER_URL=${sBROWSER_URL//[[:space:]]}
                sBROWSER_URL=${sBROWSER_URL/#\"}
                sBROWSER_URL=${sBROWSER_URL%%\"*}
                break
            }
        }
    done < "$1" 2>/dev/null

    # debug messages
    ((iDEBUG)) && {
        if [[ $iFLAG_VERSION_FOUND -eq 0 ]]; then
            DebugMessage "Version match not found"
        elif [[ $iFLAG_VERSION_FOUND -eq 1 ]]; then
            DebugMessage "Version match found at line $iLINE_VERSION_FOUND"
        fi
        if [[ -z $iSIZE ]]; then
            DebugMessage "iSIZE is NULL"
        else
            DebugMessage "iSIZE: \"$iSIZE\""
        fi
        if [[ -z $sBROWSER_URL ]]; then
            DebugMessage "sBROWSER_URL is NULL"
        else
            DebugMessage "sBROWSER_URL: \"$sBROWSER_URL\""
        fi
        DebugMessage "iLINE_VERSION_FOUND: $iLINE_VERSION_FOUND iLINE_SIZE_FOUND: $iLINE_SIZE_FOUND iLINE_BROWURL_FOUND: $iLINE_BROWURL_FOUND"
    }

    # output the value of the requested attribute
    if [[ -n $iSIZE && -n $sBROWSER_URL ]]; then
        case $sATTRIBUTE in
            (size)
                printf '%s' "$iSIZE" >&1
            ;;
            (browser_download_url)
                printf '%s' "$sBROWSER_URL" >&1
            ;;
            (*)
                # NOTE NULL response indicates error OR not found. check return status, response, and debug messages
                printf ''
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Run the sed script created by CreateSedUnminifyJSONscript on a supplied path/file
# TODO
ReformatJSONUsingSed() {

    local sFILE_JSON=$1

    [[ -z $sFILE_JSON ]] && {
        DebugMessage "Parameter error (NULL)"
        return 1
    }

    DebugMessage "sFILE_JSON: \"$sFILE_JSON\""

    if [[ -f $sFILE_JSON && -w $sFILE_JSON ]]; then
        if sed -f "$sFILE_SED_UNMINIFY_SCRIPT" -i.sedbak "$sFILE_JSON"; then
            DebugMessage "'sed' returned success"
            return 0
        else
            DebugMessage "'sed' returned failure"
            return 1
        fi
    else
        DebugMessage "Invalid file requested: \"$sFILE_JSON\""
        return 1
    fi

    return 0
}

###############################################################################
# Detect if a string is minified or not (zero newlines)
# return 0 if yes, 1 if no
# NOTE the current un-minify script works on both minified and not-minified JSON data
#      so this function is pointless other than reporting debug info
IsJSONminified() {

    local sJSON=$1

    [[ -z $sJSON ]] && {
        DebugMessage "Parameter error (NULL)"
        return 1
    }

    # NOTE do not use herestring
    iLINES=$(printf '%s' "$sJSON" | wc -l)
    DebugMessage "iLINES: \"$iLINES\""
    # 0 is the actual value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added
    if [[ $iLINES -le 1 ]]; then
        DebugMessage "JSON is minified"
        return 0
    else
        DebugMessage "JSON is not minified"
        return 1
    fi

    # assume it is minified if an error occurs
    # NOTE the unminify script works on both minified and un-minified JSON
    # NOTE it will reformat the body_text section if needed when the media type
    #      "application/vnd.github.v3.text+json" is requested (default)

    return 0
}

###############################################################################
# If the sed script sFILE_SED_UNMINIFY_SCRIPT is not found it's size doesn't match what's expected, create it
# This sed script is used to un-minify minified JSON and reformat the body_text section
# NOTE supports both unminified and minified input
# TODO
CreateSedUnminifyJSONscript() {

    if [[ ! -f $sFILE_SED_UNMINIFY_SCRIPT ]] || [[ $(stat -c '%s' "$sFILE_SED_UNMINIFY_SCRIPT") -ne $iSIZE_BYTES_SED_UNMINIFY_SCRIPT ]]; then
        DebugMessage "'sed' script at \"$sFILE_SED_UNMINIFY_SCRIPT\" does not exist or is not the expected size ($iSIZE_BYTES_SED_UNMINIFY_SCRIPT)"
        cat > "$sFILE_SED_UNMINIFY_SCRIPT" <<"END_OF_SED_SCRIPT"
#### begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s/","/"\n"/g
#### end minimum required for ge-install-manager

# replace:  "assets": [
# with:     "assets":newline
s/"assets":\[/"assets":\n/g

# replace:  :{"
# with:     :newline"
s/:{"/:\n"/g

# replace:  "},"
# with:     "newline"
s/"},"/"\n"/g

# replace:  },"
# with:     newline"
s/},"/\n"/g

# replace:  {"
# with:     "
s/{"/"/g

#### Re-format text intended for formating ('\n') in "body_text" when media type
#### "application/vnd.github.v3.text+json" is requested
# replace:  \n
# with:     newline
s/\\n/\n/g

# replace:  ,"
# with:     newline"
s/,"/\n"/g

#### one per release listed
# replace:  "}]
# with:     "
s/"}\]/"/g

# replace:  "}
# with:     "
s/"}/"/g

#### very minor
# replace:  ["
# with:     "
s/\["/"/g
END_OF_SED_SCRIPT
    else
        DebugMessage "'sed' script already exists at sFILE_SED_UNMINIFY_SCRIPT and is the expected size ($iSIZE_BYTES_SED_UNMINIFY_SCRIPT)"
    fi

    return 0
}

###############################################################################
# Check if a version is installed
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE Currently only checks if a path for the version exists
# TODO better verification
IsInstalled() {

    local sVERSION

    [[ -z $1 ]] && {
        DebugMessage "Parameter error (NULL)"
        return 1
    }

    sVERSION=$(CleanUpVersion "$1")

    DebugMessage "Checking for version \"$sVERSION\" at \"$sGE_INSTALL_PATH/Proton-${sVERSION}\""

    if [[ -d $sGE_INSTALL_PATH/Proton-${sVERSION} ]]; then
        DebugMessage "Version \"$sVERSION\" found"
        return 0
    else
        DebugMessage "Version \"$sVERSION\" not found"
        return 1
    fi

    # NOTE do not return 0 here
}

###############################################################################
# Check if Steam is running using 'ps -e'
# return 0 = Steam is running
# return 1 = Steam is not running / ps is missing / Steam is not running but steamwebhelper is / unknown error
IsSteamRunning() {

    local iSTEAM=0
    local iWEBHLPR=0

    if command -v ps >/dev/null; then
        while IFS= read -r; do
            [[ ${REPLY,,} =~ ^.*steam$ ]] && {
                iSTEAM=1
                DebugMessage "'steam' match: \"$REPLY\""
            }
            [[ ${REPLY,,} =~ ^.*steamwebhelper.*$ ]] && {
                iWEBHLPR=1
                DebugMessage "'steamwebhelper' match: \"$REPLY\""
            }
        done < <(ps -e)
        #return $(( iSTEAM == 1 ? 0 : 1 ))

        if [[ $iSTEAM -eq 1 ]]; then
            return 0
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 1 ]]; then
            echo "Warning: at least one steamwebhelper process(es) is still running but Steam is not running"
            # TODO report their PIDs
            return 1
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 0 ]]; then
            return 1
        else
            DebugMessage "Unknown error iSTEAM: \"$iSTEAM\" iWEBHLPR: \"$iWEBHLPR\" (last)REPLY: \"$REPLY\""
            return 1
        fi
    else
        # ps missing
        DebugMessage "Command 'ps' not found"
        return 1
    fi

    return 1
}

###############################################################################
# RequestURL "URL "path/file"
# If the mtime (determined by curl) is newer for remote (versus local file) download a new one
# TODO
RequestURL() {

    local sURL=$1
    local sFILE=$2
    local sRESPONSE
    local sMODIFIED_RESPONSE

    [[ -z $sURL || -z $sFILE || $# -ne 2 ]] && {
        DebugMessage "Parameter error (NULL or not exactly two)"
    }

    if sRESPONSE=$(curl -sz "$sFILE" \
                        -H "$sCURL_HEADER_USER_AGENT" \
                        -H "$sCURL_HEADER_CONTENT_TYPE" \
                        -H "$sCURL_HEADER_GITHUB_MEDIATYPE" \
                        -L "$sURL" \
                        -o - 2>/dev/null); then

        DebugMessage "'curl' returned success"

        if [[ -n $sRESPONSE ]]; then
            DebugMessage "sRESPONSE is not empty"
            if IsJSONminified "$sRESPONSE"; then
                DebugMessage "IsJSONminified returned success"
            else
                DebugMessage "IsJSONminified returned failure"
            fi
            [[ -f $sFILE ]] && mv "$sFILE" "$sFILE".rurlbak
            printf '%s' "$sRESPONSE" > "$sFILE"
        else
            DebugMessage "sRESPONSE is NULL"
        fi
        #printf '%s' "$sRESPONSE"
        #return 0
    else
        DebugMessage "'curl' returned failure"
        printf ''
        return 1
    fi

    # Run the minify script whether the response is minified or not
    # NOTE the current un-minify script works on both minified and unminified JSON
    # NOTE It needs to run on both to enable future support for displaying the body_text (update notes) section because
    #      it also transforms literal \n in the body_text to newlines
    if ReformatJSONUsingSed "$sFILE"; then
        DebugMessage "ReformatJSONUsingSed returned success"
        sMODIFIED_RESPONSE=$(cat "$sFILE" 2>/dev/null)
        printf '%s' "${sMODIFIED_RESPONSE%$'\n'}" # remove the newline added by cat
        return 0
    else
        DebugMessage "ReformatJSONUsingSed returned failure"
        printf ''
        return 1
    fi
}

###############################################################################
ParseConfigFile() {

    local sCONFIG_FILE=$1
    local iNUM_LINES
    local iCOUNTER

    [[ -z $sCONFIG_FILE || ! -f $sCONFIG_FILE || ! -w $sCONFIG_FILE ]] && {
        DebugMessage "Parameter error (sCONFIG_FILE NULL, not a file, or not writeable"
        return 1
    }

    iNUM_LINES=$(wc -l < "$sCONFIG_FILE")
    DebugMessage "sCONFIG_FILE \"$sCONFIG_FILE\" contains $iNUM_LINES newlines"

    #[[ $iNUM_LINES -eq 0 ]] && {
        cat <<DEFAULT_CONFIG > "$sCONFIG_FILE"
#
# $sSCRIPT_FULL_NAME v$sSCRIPT_VERSION default config file
#
# Lines begining with "#" or anything appear after "#" on a line are ignored
#

# default install path
install_path=$HOME/.steam/root/compatibilitytools.d           #  partial comment
invalid==format #exactly one = is required
 # line start with blank and comment
	# tab then comment
installpath=/test/path
key=value
	 #tab-space-comment
ops====typo
DEFAULT_CONFIG

    #}

    while IFS= read -r; do
        ((iCOUNTER++))
        # Ignore lines that being with a #
        [[ $REPLY =~ ^#.*$ ]] && { DebugMessage "Ignoring line $iCOUNTER (begins with #): \"$REPLY\""; continue; }

        # Strip comments away and then any spaces/tabs that were before them
        # trim lines that contain # not at the begining or only at the end
        if [[ $REPLY =~ ^.*#.*$ ]] || [[ $REPLY =~ ^.*#$ ]]; then

            DebugMessage "Trimming partially commented line $iCOUNTER: \"$REPLY\""
            # remove the # and everything to the right of it
            REPLY=${REPLY%%'#'*}

            #DebugMessage "Before blank trim: \"${REPLY:$((${#REPLY}-1)):1}\""
            # trim spaces and tabs from the end of the line
            while [[ ${REPLY:$((${#REPLY}-1)):1} = [[:blank:]] ]]; do
                #DebugMessage "Trimming one or more [[:blank:]] from \"$REPLY\""
                REPLY=${REPLY:0:$((${#REPLY}-1))}
            done
            DebugMessage "After blank trim: \"$REPLY\""
        fi
        # end strip comments

        # Ignore lines that are empty after stripping comments away
        [[ $REPLY =~ ^$ ]] && { DebugMessage "Ignoring line $iCOUNTER (empty)"; continue; }

        # Ignore lines that begin with one or more space or one or more tab and don't contain comments
        [[ $REPLY =~ ^[[:blank:]]+ ]] && { DebugMessage "Ignoring line $iCOUNTER (begins with space or tab)"; continue; }

        # Ignore lines that may contain a key and an = but nothing except spaces or tabs after the =
        [[ $REPLY =~ ^.*=[[:blank:]]*$ ]] && { DebugMessage "Ignoring line $iCOUNTER (key with no value): \"$REPLY\""; continue; }

        # Ignore lines that don't contain exactly one =
        [[ $REPLY =~ (^|[^=])=($|[^=]) ]] || { DebugMessage "Ignoring line $iCOUNTER (more than one =): \"$REPLY\""; continue; }

        echo "VALID($iCOUNTER): \"$REPLY\""

        sKEY=${REPLY%=*}
        sVALUE=${REPLY#*=}
        case $REPLY in
            (install_path=*|installpath=*)
                echo "key: \"$sKEY\""
                echo "value: \"$sVALUE\""
            ;;

        esac
    done < "$sCONFIG_FILE"



    return 0
}

###############################################################################
# Support different formats for version specification
# Internally, the script uses case-sensitive "base" versions such as "5.9-GE-5-ST" but
# for parsing parameters many other variations are supported. Examples are in usage above.
# NOTE not only does this enable multiple types of input but it also enables reporting
#      with the exact input given which may or may not be helpful in case of an error/problem
# NOTE if the naming format for packages changes, this function also must be adapted
# TODO support even more variations?
CleanUpVersion() {

    local iLENGTH=0
    local sVERSION=${1-}

    [[ -z $sVERSION ]] && {
        DebugMessage "Parameter error (NULL)"
        return 1
    }

    ((iDEBUG)) && {
        iLENGTH=${#sVERSION}
        DebugMessage "Before: \"$sVERSION\""
    }

    # global upper case
    sVERSION=${sVERSION^^}
    # anchored left, remove a single "PROTON-" and anything to the left of it
    sVERSION=${sVERSION#*'PROTON-'}
    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    sVERSION=${sVERSION%'.TAR.GZ'*}

    ((iDEBUG)) && {
        DebugMessage "After: \"$sVERSION\""
        [[ $iLENGTH -ne ${#sVERSION} ]] && DebugMessage "Removed $(( iLENGTH - ${#sVERSION} )) characters"
    }

    printf '%s' "$sVERSION"

    return 0
}

###############################################################################
# Bash only primitive replacement for mktemp
# Accepts no parameters, returns the tmp path/file created
MkTempFile() {

    local sTMP_FILE_CREATED

    [[ -d $sTMP_BASE_PATH && -w $sTMP_BASE_PATH ]] || return 1

    sTMP_FILE_CREATED="$sTMP_BASE_PATH/${sTMP_PREFIX}$(GenerateRandomAlphaNumericString 10)"

    # Create the empty temp file
    printf '' > "$sTMP_FILE_CREATED"

    # "Return" the path and filename,
    # meant to be captured using command substitution eg. sTEMPFILE=$(MkTemp)
    printf '%s' "$sTMP_FILE_CREATED"

    return 0
}

###############################################################################
# Bash only primitive replacement for mktemp
# Accepts no parameters, returns the tmp path created
MkTempPath() {

    local sTMP_PATH_CREATED

    [[ -d $sTMP_BASE_PATH && -w $sTMP_BASE_PATH ]] || return 1

    sTMP_PATH_CREATED="$sTMP_BASE_PATH/${sTMP_PREFIX}$(GenerateRandomAlphaNumericString 10)"

    # Create the path
    mkdir -p "$sTMP_PATH_CREATED"

    # "Return" the path and filename,
    # meant to be captured using command substitution eg. sTEMPFILE=$(MkTemp)
    printf '%s' "$sTMP_PATH_CREATED"

    return 0
}

###############################################################################
# Generate a pseudo-random alphanumeric string using only Bash
# Accepts one optional parameter: the length of the string to generate (range 1-32767) (default: 10)
GenerateRandomAlphaNumericString() {

    local sLIST
    local iLEN=${1:-10}
    local sRESULT
    local iC=1

    sLIST=$(printf '%s' {a..z}{0..9}{A..Z})

    # If the length requested is outside sane upper and lower bounds, reset it
    [[ $iLEN -lt 1 ]] && iLEN=1
    [[ $iLEN -gt 32767 ]] && iLEN=32767

    # Loop iLEN times
    for (( iC; iC<=iLEN; iC++ )) do

        # Randomly choose one offset of length one from sLIST
        sCHAR=${sLIST:$RANDOM%${#sLIST}:1}

        # Randomly invert the case
        (( RANDOM % 2 )) && sCHAR=${sCHAR~}

        # Concatenate sRESULT and sCHAR
        sRESULT=${sRESULT}${sCHAR}

    done

    # "Return" the resulting string,
    # meant to be captured using command substitution
    # eg. sSTRING_OF_LENGTH_TEN=$(GenerateRandomAlphaNumericString 10)
    printf '%s' "$sRESULT"

    return 0
}

###############################################################################
# Setup env and report
# TODO
SetupEnvironment() {

    local iFAILED=0

    # NOTE ((iDEBUG)) && echo "($LINENO) SetupEnvironment: "

    # sGE_INSTALL_PATH
    if [[ -d $sGE_INSTALL_PATH ]]; then
        DebugMessage "Found existing sGE_INSTALL_PATH at \"$sGE_INSTALL_PATH\""
        if [[ -w $sGE_INSTALL_PATH ]]; then
            DebugMessage "Script has write access to sGE_INSTALL_PATH"
        else
            DebugMessage "Script does not have write access to sGE_INSTALL_PATH"
            iFAILED=1
        fi
    elif [[ ! -d $sGE_INSTALL_PATH ]]; then
        DebugMessage "sGE_INSTALL_PATH not found. Creating at \"$sGE_INSTALL_PATH\""
        if mkdir -p "$sGE_INSTALL_PATH"; then
            DebugMessage "Create install path succeeded"
        else
            DebugMessage "Create install path failed"
            iFAILED=1
        fi
    fi

    # sSCRIPT_CONFIG_PATH
    if [[ -d $sSCRIPT_CONFIG_PATH ]]; then
        DebugMessage "Found existing sSCRIPT_CONFIG_PATH at \"$sSCRIPT_CONFIG_PATH\""
        if [[ -w $sSCRIPT_CONFIG_PATH ]]; then
            DebugMessage "Script has write access to sSCRIPT_CONFIG_PATH"
        else
            DebugMessage "Script does not have write access to sSCRIPT_CONFIG_PATH"
            iFAILED=1
        fi
    elif [[ ! -d $sSCRIPT_CONFIG_PATH ]]; then
        DebugMessage "sSCRIPT_CONFIG_PATH not found. Creating at \"$sSCRIPT_CONFIG_PATH\""
        if mkdir -p "$sSCRIPT_CONFIG_PATH"; then
            DebugMessage "Create config path succeeded"
        else
            DebugMessage "Create config path failed"
            iFAILED=1
        fi
    fi

    # sSCRIPT_CACHE_PATH
    if [[ -d $sSCRIPT_CACHE_PATH ]]; then
        DebugMessage "Found existing sSCRIPT_CACHE_PATH at \"$sSCRIPT_CACHE_PATH\""
        if [[ -w $sSCRIPT_CACHE_PATH ]]; then
            DebugMessage "Script has write access to sSCRIPT_CACHE_PATH"
        else
            DebugMessage "Script does not have write access to sSCRIPT_CACHE_PATH"
            iFAILED=1
        fi
    elif [[ ! -d $sSCRIPT_CACHE_PATH ]]; then
        DebugMessage "sSCRIPT_CACHE_PATH not found. Creating at \"$sSCRIPT_CACHE_PATH\""
        if mkdir -p "$sSCRIPT_CACHE_PATH"; then
            DebugMessage "Create cache path succeeded"
        else
            DebugMessage "Create cache path failed"
            iFAILED=1
        fi
    fi

    # sFILE_SCRIPT_CONFIG
    if [[ -f $sFILE_SCRIPT_CONFIG ]]; then
        DebugMessage "Found existing sFILE_SCRIPT_CONFIG at \"$sFILE_SCRIPT_CONFIG\""
        if [[ -w $sFILE_SCRIPT_CONFIG ]]; then
            DebugMessage "Script has write access to sFILE_SCRIPT_CONFIG"
        else
            DebugMessage "Script does not have write access to sFILE_SCRIPT_CONFIG"
            iFAILED=1
        fi
        if [[ -r $sFILE_SCRIPT_CONFIG ]]; then
            DebugMessage "Script has read access to sFILE_SCRIPT_CONFIG"
        else
            DebugMessage "Script does not have read access to sFILE_SCRIPT_CONFIG"
            iFAILED=1
        fi
    elif [[ ! -f $sFILE_SCRIPT_CONFIG ]]; then
        DebugMessage "sFILE_SCRIPT_CONFIG not found. Creating at \"$sFILE_SCRIPT_CONFIG\""
        if printf '' > "$sFILE_SCRIPT_CONFIG"; then
            DebugMessage "Create script config file succeeded"
        else
            DebugMessage "Create script config file failed"
            iFAILED=1
        fi
    fi

    if [[ $iFAILED -eq 0 ]]; then
        DebugMessage "All tasks succeeded"
        return 0
    elif [[ $iFAILED -eq 1 ]]; then
        DebugMessage "One or more tasks failed"
        return 1
    fi

    return 1
}


###############################################################################
# A simple helper function used only for debugging and integration testing
ShowConsoleDiff() {

    [[ $# -ne 2 ]] && { echo "Give me two files to work with numbskull!"; return 1; }

    # iCOLUMNS=$(stty size)
    # iCOLUMNS=${iCOLUMNS##*[[:space:]]}
    if [[ $(shopt checkwinsize) =~ ^checkwinsize.*off$ ]]; then
        shopt -s checkwinsize
        diff --color -csaW${COLUMNS} "$1" "$2"
        shopt -u checkwinsize
    else
        diff --color -csaW${COLUMNS} "$1" "$2"
    fi

    return 0
}

###############################################################################
# Output to stderr a message and also report the calling line and calling function
# Almost mimic the caller built-in but exclude the source file name
DebugMessage() {

    # If debug mode is not active, do nothing
    ((iDEBUG)) || return 0

    [[ -z $1 ]] && { echo "($LINENO)[DebugMessage]: Parameter error (NULL)" 1>&2; return 0; }

    #echo "Length: ${#FUNCNAME[@]}" 1>&2
    #echo "FuncTrace: ${FUNCNAME[@]}" 1>&2
    #echo "$((${#FUNCNAME[@]}-2))" 1>&2

    # Show a function trace up to 4 functions back
    # (excluding bash's main from the function trace)
    # General format:
    # Function stack {1..4}:
    #   (Calling Line)[Function call order]: Message
    # Function stack count >4:
    #   (Calling Line)[(Function count before), Function call order]: Message
    case $((${#FUNCNAME[@]}-2)) in
        0) printf '%s\n' "$1" 1>&2 ;; # NOTE if ${#FUNCNAME[@]}-2 would be <= zero "0", the case checked is zero "0"
        1) printf '%s\n' "(L${BASH_LINENO[0]})[${FUNCNAME[1]}]: $1" 1>&2 ;;
        2) printf '%s\n' "(L${BASH_LINENO[0]})[${FUNCNAME[2]},${FUNCNAME[1]}]: $1" 1>&2 ;;
        3) printf '%s\n' "(L${BASH_LINENO[0]})[${FUNCNAME[3]},${FUNCNAME[2]},${FUNCNAME[1]}]: $1" 1>&2 ;;
        4) printf '%s\n' "(L${BASH_LINENO[0]})[${FUNCNAME[4]},${FUNCNAME[3]},${FUNCNAME[2]},${FUNCNAME[1]}]: $1" 1>&2 ;;
        *) printf '%s\n' "(L${BASH_LINENO[0]})[($((${#FUNCNAME[@]}-5))),${FUNCNAME[3]},${FUNCNAME[2]},${FUNCNAME[1]}]: $1" 1>&2 ;;
    esac
    # Output to stderr / fd2
    #if [[ -n ${FUNCNAME[3]} && -n ${FUNCNAME[2]} && ${FUNCNAME[1]} ]]; then
    #    printf '%s\n' "(${BASH_LINENO[0]})(${#FUNCNAME[@]})[${FUNCNAME[3]}=>${FUNCNAME[2]}=>${FUNCNAME[1]}] $1" 1>&2
    #fi
    return 0
}

###############################################################################
# Diagnostic tool - exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    # All hope abandon, ye who enter here!
    #-------------------------------------------------------------------------------------
    if [[ $iINTEGRATION_TESTING -eq 1 ]]; then
        ParseConfigFile "$sFILE_SCRIPT_CONFIG"
    fi
    ((iINTEGRATION_TESTING)) && exit
    #-------------------------------------------------------------------------------------

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>/dev/stdout; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip ps stat sed cmp sort

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: \"$PWD\""
    echo "SHELL: \"$SHELL\""
    echo "SHELLOPTS: \"$SHELLOPTS\""
    echo "SHLVL: \"$SHLVL\""
    echo "BASH_VERSINFO: \"${BASH_VERSINFO[*]}\""
    echo "BASH_VERSION: \"$BASH_VERSION\""
    echo "MACHTYPE: \"$MACHTYPE\""
    echo "OSTYPE: \"$OSTYPE\""
    echo "PROMPT_COMMAND: \"$PROMPT_COMMAND\""
    echo "LANG: \"$LANG\""
    echo "LC_MESSAGES: \"$LC_MESSAGES\""
    echo "LC_ALL: \"$LC_ALL\""
    echo "EUID: \"$EUID\""
    #echo "${FUNCNAME[@]}"
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Optional command support
ConfigureOptionalCommands() {

    if command -v trash >/dev/null; then
        sCOMMAND_RM="trash"
    fi

    DebugMessage "sCOMMAND_RM: \"$sCOMMAND_RM\""

    return 0
}

###############################################################################
# Remove any temporary files/paths created by the script if debug mode is not enabled
CleanUp() {

    for sNODE in "$sTMP_BASE_PATH/$sTMP_PREFIX"*; do
        # paths
        [[ -d $sNODE ]] && {
            DebugMessage "Temporary path found at \"$sNODE\""
            if ((iDEBUG)); then
                DebugMessage "Debug enabled. Temporary path not removed."
            else
                if rm -rf "$sNODE"; then
                    DebugMessage "Temporary path removed"
                else
                    DebugMessage "Failed to remove temporary path"
                fi
            fi
        }

        # files
        [[ -f $sNODE ]] && {
            DebugMessage "Tmp file found at \"$sNODE\""
            if ((iDEBUG)); then
                DebugMessage "Debug enabled. Temporary file not removed."
            else
                if rm -rf "$sNODE"; then
                    DebugMessage "Temporary file removed"
                else
                    DebugMessage "Failed to remove temporary file"
                fi
            fi
        }
    done

    return 0
}

###############################################################################
# Parse command line parameters and set global variables according to what was
# requested. Order of operations for invocations that involve multiple parameters
# are listed at the end of the usage section.
ParseParameters() {
    while getopts 'zZThHflSs:i:d:R:NuUXv:V' sOPT; do
        case "$sOPT" in
            (h) iSHOW_HELP=1 ;;
            (H) iSHOW_USAGE=1 ;;
            (f) iFORCE=1 ;;
            (T) iINTEGRATION_TESTING=1 ;; # -fTzZ (undocumented, used for integration testing new features)
            (z) iDEBUG=1 ;;
            (Z)
                if [[ $iFORCE -eq 1 ]] && [[ $iDEBUG -eq 1 ]]; then
                    ReportEnvironmentInfo # exactly -fzZ (undocumented diagnostic tool)
                fi
            ;;
            (u) iCHECK_UPDATE=1 ;;
            (X) iREMOVE_INSTALL_PATH=1 ;;
            (N) iREMOVE_SAVED_PACKAGES=1 ;;
            (R)
                iREMOVE=1
                sREMOVE_VERSION=$OPTARG
            ;;
            (l) iLIST_INSTALLED_GE_VERSIONS=1 ;;
            (s)
                iREPORT_VERSION_USAGE=1
                sREPORT_VERSION=$OPTARG
            ;;
            (S) iREPORT_INSTALL_PATH_USAGE=1 ;;
            (d)
                iDOWNLOAD=1
                sDOWNLOAD_VERSION=$OPTARG
            ;;
            (i)
                iINSTALL=1
                sINSTALL_VERSION=$OPTARG
            ;;
            (U) iUPDATE=1 ;;
            (V) iVERIFY=1 ;;
            (v)
                iVERIFY=1
                sVERIFY_VERSION=$OPTARG
            ;;
            (":"|"?")
                return 1
            ;;
        esac
    done

    return 0
}

###############################################################################

Main() {

    # Parse script parameters and arguments, set global variables
    ParseParameters "$@" || exit 1

    # show help and/or usage
    if [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 0 ]]; then
        ShowHelp
        exit
    elif [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowHelp
        ShowUsage
        exit
    elif [[ $iSHOW_HELP -eq 0 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowUsage
        exit
    fi

    # debug mode
    DebugMessage "Debug mode enabled"

    #TODO
    if ! SetupEnvironment; then
        DebugMessage "One or more environment setup tasks failed"
    fi

    #TODO
    ConfigureOptionalCommands

    #TODO
    CreateSedUnminifyJSONscript

    # checkupdate
    if [[ $iCHECK_UPDATE -eq 1 && $iUPDATE -eq 0 ]]; then
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
    fi

    # remove install path
    if [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 1 ]]; then
        if IsSteamRunning; then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    elif [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 0 ]]; then
        echo "-X must be combined with -f to confirm that you are sure"
    fi

    # remove saved packages
    if [[ $iREMOVE_SAVED_PACKAGES -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]]; then
        RemoveSavedPackages # TODO -f required?
    fi

    # Remove an installed version or package
    if [[ $iREMOVE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && [[ $iREMOVE_SAVED_PACKAGES -eq 0 ]]; then
        RemoveGEVersion "$sREMOVE_VERSION" # NOTE sREMOVE_VERSION is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif [[ $iREMOVE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Download a package
    ((iDOWNLOAD)) && {
        DownloadGEPackage "$sDOWNLOAD_VERSION" # NOTE sDOWNLOAD_VERSION is set in getops
    }

    # Check for new version and it if it is not installed
    if [[ $iUPDATE -eq 1 ]]; then
        if UpdateSavedGELatestRelease; then
            if GetLatestGEVersion; then # set sGE_LATEST_VERSION
                if IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 1 ]]; then # Latest version is installed and -f is suppled
                    if RemoveGEVersion "$sGE_LATEST_VERSION"; then
                        if InstallGEVersion; then # InstallGEVersion checks iUPDATE then sINSTALL_VERSION and/or sGE_LATEST_VERSION
                            echo "Update succeeded"
                        else
                            echo "Update failed"
                        fi
                    fi
                elif IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 0 ]]; then # Latest version is installed and -f was not supplied
                    #((iDEBUG)) && printf '%s' "($LINENO) Main: Update: " 1>&2
                    echo "Latest version is already installed ($sGE_LATEST_VERSION)"
                elif ! IsInstalled "$sGE_LATEST_VERSION"; then # Latest version is not installed
                    #((iDEBUG)) && printf '%s' "($LINENO) Main: Update: " 1>&2
                    echo "Latest version is not installed"
                    if InstallGEVersion; then
                        #((iDEBUG)) && printf '%s' "($LINENO) Main: Update: " 1>&2
                        echo "Update succeeded"
                        if IsSteamRunning; then
                            echo "Restart Steam to use the new version"
                        fi
                    else
                        #((iDEBUG)) && printf '%s' "($LINENO) Main: Update: " 1>&2
                        echo "Update failed"
                    fi
                fi
            else
                DebugMessage "Update: GetLatestGEVersion returned failure status"
            fi
        else
            # GetLatestGEVersionInfo failed
            DebugMessage "Update: GetLatestGEVersionInfo returned failure status"
            echo "Update failed"
        fi
        # Like purchasing a tribble, this is probably a bad idea
        [[ $iINSTALL -eq 1 ]] && iUPDATE=0 # Reset iUPDATE to 0 so update and install can run in the same invocation
    fi

    # Install a package
    if [[ $iINSTALL -eq 1 ]] && [[ $iUPDATE -eq 0 ]]; then
        # NOTE sINSTALL_VERSION is set in getops
        InstallGEVersion "$sINSTALL_VERSION"
    fi

    # List installed versions
    [[ $iLIST_INSTALLED_GE_VERSIONS -eq 1 ]] && ListInstalledGEVersions

    # Report entire install path disk usage and file count
    [[ $iREPORT_INSTALL_PATH_USAGE -eq 1 ]] && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    [[ $iREPORT_VERSION_USAGE -eq 1 ]] && ReportGEDiskUsage "$sREPORT_VERSION"

    # Run verify if remove install path and remove saved packages wasn't requested
    # TODO add support to verify even if remove saved packages and/or remove install path was invoked
    # so long as some sort of install was also requested. Additionally, maybe support installing a version
    # that is not installed when verify is called and force mode is active.
    if [[ $iVERIFY -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -ne 1 && $iREMOVE_SAVED_PACKAGES -ne 1 ]]; then
        VerifyGEInstall "$sVERIFY_VERSION"
    fi

    # If no parameters were supplied, show help
    # NOTE ignore iFORCE and iDEBUG flags
    if [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && \
       [[ $iREMOVE_SAVED_PACKAGES -eq 0 ]] && \
       [[ $iREMOVE -eq 0 ]] && \
       [[ $iLIST_INSTALLED_GE_VERSIONS -eq 0 ]] && \
       [[ $iREPORT_VERSION_USAGE -eq 0 ]] && \
       [[ $iREPORT_INSTALL_PATH_USAGE -eq 0 ]] && \
       [[ $iDOWNLOAD -eq 0 ]] && \
       [[ $iINSTALL -eq 0 ]] && \
       [[ $iCHECK_UPDATE -eq 0 ]] && \
       [[ $iVERIFY -eq 0 ]] && \
       [[ $iUPDATE -eq 0 ]]; then

        ((iDEBUG)) && {
            if IsSteamRunning; then
                DebugMessage "Steam is running"
            else
                DebugMessage "Steam is not running"
            fi
            DebugMessage "Nothing to do"
        }

        # report latest version installed status
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
        ShowHelp
    fi

    return 0
}

###############################################################################
# EXIT trap
trap 'iREAL_EXIT_STATUS=$?; DebugMessage "[EXIT INT trap]: Exit status (before CleanUp): $iREAL_EXIT_STATUS"; CleanUp; DebugMessage "[EXIT INT trap]: Exit status (after CleanUp): $?"; exit $iREAL_EXIT_STATUS' EXIT INT

###############################################################################

Main "$@"

