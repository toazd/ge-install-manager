#!/usr/bin/env bash
# vim: set ft=shell nowrap et sta shiftwidth=4 ts=8 sts=0
# misc-bash/script-sloc ge-install-manager:
# 2071/3148 SLOC (65%) [SLOC/Comment:2.84], 730 comments (23%) [S:94%,I:5%] [Comment/SLOC:0.35], 384 empty (12%)

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

# -e  Exit immediately if a command exits with a non-zero status.
set +e # WARNING: DO NOT set -e

# -h Remember the location of commands as they are looked up. Default is on.
# -u Treat unset variables as an error when substituting. Default is off.
# -o pipefail The return value of a pipeline is the status of the last command
#             to exit with a non-zero status, or zero if no command exited with
#             a non-zero status. Default is off.
set -huo pipefail

# -a Remove all alias definitions.
# NOTE: If the shebang is changed, this may have undesired behavior
unalias -a

###############################################################################
# "Things that would be nice, but aren't required for main features" list
#
# TODO: Find a way to not download releases more often than is necessary
#       (updates to download_count update the mtime of the remote file)
# TODO: Replace getopts with a custom parser
# TODO: support for using jq in addition to sed
#
###############################################################################

# Set the minimum global variables required to show help and/or usage
declare -gr SCRIPT_VERSION="0.7.4"
declare -gr SCRIPT_CODENAME="Cochrane Bonaventure"
declare -gr SCRIPT_FULL_NAME=${0##*/}
declare -gr TEMP_PREFIX=$SCRIPT_FULL_NAME.tmp.
declare -g temp_base_path=/tmp # Configuration file: tmp_path
declare -gi debug=0
declare -gi remove_install_path=0
declare -gi remove_all_saved_packages=0
declare -gi remove_installed_version=0
declare -gi remove_saved_package=0
declare -gi list_installed_versions=0
declare -gi report_version_usage=0
declare -gi report_install_path_usage=0
declare -gi download=0
declare -gi install=0
declare -gi check_update=0
declare -gi verify=0
declare -gi show_help=0
declare -gi show_usage=0
declare -gi update=0
declare -gi force=0 # Required only for -fzT
declare -gi integration_testing=0
declare -gi flag_sigint_caught=0

###############################################################################
# Purpose: Set remaining global variables that are not required to show help and/or usage
#          but are required for the rest of the script.
# Input:   None
# Output:  None
# Return:  Always 0
InitializeGlobalVars() {

    declare -gr CURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
    declare -gr CURL_HEADER_USER_AGENT="User-Agent: toazd/$SCRIPT_FULL_NAME/$SCRIPT_VERSION"
    declare -gr CURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
    declare -gi integration_testing=0
    declare -gi size_bytes_sed_unminify_script=824
    declare -gi real_exit_status=0
    declare -g install_path  # Configuration file: install_path
    declare -g script_config_path=${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME
    declare -g file_sed_unminify_script=$script_config_path/unminify-JSON.sed
    declare -g script_cache_path # Configuration file: cache_path
    declare -g latest_version_url # Configuration file: latest_version_url
    declare -g releases_url # Configuration file: releases_url
    declare -g file_latest_json
    declare -g file_releases_json
    declare -g latest_version
    declare -g file_script_config=$script_config_path/$SCRIPT_FULL_NAME.conf
    declare -g file_sed_unminify_script
    declare -g override_default_install_path=''
    declare -g command_rm # Configuration file: rm_command
    declare -g verify_version
    declare -g install_version
    declare -g download_version
    declare -g report_version
    declare -g remove_saved_version
    declare -g remove_installed_version

    return 0
}

###############################################################################
# Purpose: Print the help text to stdout
# Input:   None
# Output:  None
# Return:  Always 0
ShowHelp() {

    (cat) <<HELP_HEREDOC

    $(basename "$0")  v$SCRIPT_VERSION "$SCRIPT_CODENAME"

    Required:       Bash 3.2+(TBD), curl, sed, tar, gzip, stat, wc
    Optional:       date, du, ps, sort, cmp, envsubst, fallocate, trash

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
    -r <version>  - Remove saved package <version>
    -V            - Verify each installation using its saved package
                      Combined with -v, -V will be skipped
                      Saved packages will be downloaded as needed
    -v <version>  - Verify <version> using its saved package
    -d <version>  - Download and save the package for <version>
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      -f is also required to confirm that you are sure
                      NOTE: Saved packages are currently stored in the installation path
    -f            - Force install, upgrade, or remove
                      Combined with -U and/or -i, remove saved package and download a new copy
    -z            - Enable debug mode
                      Enable extra output messages and preserve any temporary files created
                      Debug message format: (calling line)[function trace]: message
HELP_HEREDOC

    return 0
}

###############################################################################
# Purpose: Print the usage text to stdout
# Input:  None
# Output: None
# Return: Always 0
ShowUsage() {

     (cat) <<USAGE_HEREDOC
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle,
      Report environment info (-fzZ),
      Show help,
      Show usage,
      Debug toggle,
      Check for latest release,
      Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Remove saved package (if remove install path is not active),
      Download,
      Update,
      Install,
      List installed,
      Report install path usage,
      Report specific version usage
      Verify

USAGE_HEREDOC

    return 0
}

###############################################################################
# Purpose: Set the global variable latest_version to the latest version
#          which is retrieved from the name member of the assets object in
#          the local file file_latest_json.
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = UpdateSavedGELatestRelease returned 1, or a match was not found
#              in file_latest_json
#
# TODO: Might want to check releases if latest fails. But, will the first entry
#       always be the latest?
GetLatestGEVersion() {

    latest_version=''

    if (UpdateSavedGELatestRelease); then
        while IFS= read -r --; do
            # WARNING: Do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST"
            #          for matching. The version extracted from them (eg. 5.9-GE-5-ST) is not
            #          always the same as the version extracted from browser_download_url
            # NOTE: The regex must match all 3 of the following potential formats:
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name": "Proton-5.9-GE-5-ST.tar.gz"
            [[ $REPLY =~ ^[[:blank:]]*\"name\":[[:blank:]]*\"Proton-.*\.tar\.gz\".*$ ]] && {
                latest_version=${REPLY#*\"name\":}
                latest_version=${latest_version#*\"}
                latest_version=${latest_version%.tar.gz\"*}
                break
            }
        done < "$file_latest_json"
        [[ -z $latest_version ]] && { ((debug)) && DebugMessage "latest_version is NULL (no match or not found)"; return 1; }
    else
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Call the RequestURL function to save the (JSON) from the URL
#          latest_version_url to the local file file_latest_json
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = RequestURL returned 1 or an unknown error occured
#
# TODO: Consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGELatestRelease() {

    ((debug)) && {
        DebugMessage "latest_version_url: \"$latest_version_url\""
        DebugMessage "file_latest_json: \"$file_latest_json\""
    }

    if (RequestURL "$latest_version_url" "$file_latest_json"); then
        ((debug)) && DebugMessage "RequestURL returned success"
        return 0
    else
        ((debug)) && DebugMessage "RequestURL returned failure"
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Call the RequestURL function to save the (JSON) from the URL
#          releases_url to the local file file_releases_json
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = RequestURL returned 1 or an unknown error occured
#
# TODO: Consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGEReleases() {

    # BUG: updates to download_count in the remote file cause curl -z to download a new version much more often than is needed
    #      Until a workaround is found, latest and releases are kept seperate and not checked at the same time
    ((debug)) && {
        DebugMessage "releases_url: \"$releases_url\""
        DebugMessage "file_releases_json: \"$file_releases_json\""
    }

    if (RequestURL "$releases_url" "$file_releases_json"); then
        ((debug)) && DebugMessage "RequestURL returned success"
        return 0
    else
        ((debug)) && DebugMessage "RequestURL returned failure"
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Using curl, download a proton-ge-custom release package to a
#          temporary path and if the download size matches the expected size
#          copy it to install_path
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
DownloadGEPackage() {

    # Declare local variables
    local version
    local temp_path
    local temp_package
    local temp_base_path_remaining_bytes
    local install_path_remaining_bytes
    local expected_size_bytes
    local package_download_url
    local -i downloaded_package_size_bytes=0

    # Set local variables, checking return values and reporting as needed
    version=$(CleanUpVersion "${1-}")
    [[ -z $version ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    temp_path=$(MkTempPath) || { ((debug)) && DebugMessage "MkTempPath returned failure"; return 1; }
    temp_package=$temp_path/Proton-${version}.tar.gz
    temp_base_path_remaining_bytes=$(SpaceRemaining "$temp_base_path" "b") || { ((debug)) && DebugMessage "SpaceRemaining returned failure checking $temp_path"; return 1; }
    install_path_remaining_bytes=$(SpaceRemaining "$install_path" "b") || { ((debug)) && DebugMessage "SpaceRemaining returned failure checking $install_path"; return 1; }
    package_download_url=$(QueryGEAttribute "$version" "browser_download_url") || { ((debug)) && DebugMessage "QueryGEAttribute browser_download_url returned failure"; return 1; }
    expected_size_bytes=$(QueryGEAttribute "$version" "size") || { ((debug)) && DebugMessage "QueryGEAttribute size returned failure"; return 1; }
    [[ -z $package_download_url ]] && { ((debug)) && DebugMessage "package_download_url is NULL"; return 1; }

    # Check if there is enough free space to copy the package to install_path
    if [[ $expected_size_bytes -gt $install_path_remaining_bytes ]]; then
        printf '%s\n%s\n' \
               "WARNING: Not enough free space at \"$install_path\"" \
               "Need at least $expected_size_bytes bytes but there is only $install_path_remaining_bytes bytes free"
        return 1
    else
        ((debug)) && {
            DebugMessage "install_path ($install_path) remaining bytes: $install_path_remaining_bytes"
            DebugMessage "temp_path ($temp_path) remaining bytes: $temp_base_path_remaining_bytes"
            DebugMessage "Expected package size (bytes): $expected_size_bytes"
        }
    fi

    # If there is not enough free space remaining on the temp_path file system
    # TODO: Use a different path as a fallback?
    if [[ $temp_base_path_remaining_bytes -lt $expected_size_bytes ]]; then
        ((debug)) && DebugMessage "Free space on \"$temp_base_path\" is $temp_base_path_remaining_bytes bytes"
        printf '%s\n%s\n%s\n' \
               "WARNING: Not enough free space at \"$temp_base_path\"" \
               "Need at least $expected_size_bytes bytes but there is only $temp_base_path_remaining_bytes bytes free" \
               "Free up space or change tmp_path in the configuration file"
        return 1
    else
        # If fallocate is found, preallocate the file to be downloaded
        if command -v fallocate &>/dev/null; then
            if fallocate -l "$expected_size_bytes" -- "$temp_package"; then
                ((debug)) && DebugMessage "fallocate succeeded"
            else
                #echo "Failed to preallocate \"$sTMP_FILE\", download may fail"
                ((debug)) && DebugMessage "\"fallocate -l $expected_size_bytes -- $temp_package\" returned failure"
                [[ -f $temp_package ]] && rm -f -- "$temp_package"
            fi
        else
            ((debug)) && DebugMessage "fallocate not found"
        fi
    fi

    # Attempt to retrieve the package with curl
    echo "Downloading \"$package_download_url\""
    if curl -# -L "$package_download_url" -o "$temp_package"; then

        # Get the file size in bytes
        downloaded_package_size_bytes=$(stat -c '%s' -- "$temp_package")
        ((debug)) && DebugMessage "Downloaded package size in bytes: \"$downloaded_package_size_bytes\""

        # A file size of 9 bytes indicates the response was "Not Found"
        # TODO: Also check for rate limit exceeded - need a sample file first
        if [[ $downloaded_package_size_bytes -eq 9 ]]; then
            echo "Server responded \"Not Found\" for version \"$version\""
            CleanUp
            return 1
        fi

        # Check if the the package size and expected size are equal
        if [[ $downloaded_package_size_bytes -eq $(QueryGEAttribute "$version" "size") ]]; then
            echo "Downloaded package is the expected size ($expected_size_bytes bytes)"
        else
            printf '%s\n%s\n' \
                   "Downloaded file size and expected size do not match" \
                   "(\"$downloaded_package_size_bytes\" vs \"$expected_size_bytes\")"
           CleanUp
           return 1
        fi

        # Copy the package from the temporary path to the install path
        ((debug)) && DebugMessage "Copying package \"$temp_package\" to \"$install_path\""
        if cp -- "$temp_package" "$install_path"; then
            ((debug)) && DebugMessage "Package copied successfully"
            echo "Download succeeded"
            CleanUp
        else
            ((debug)) && DebugMessage "Copy package from \"$temp_package\" to \"$install_path\" failed"
            echo "Download failed"
            CleanUp
            return 1
        fi
    else
        # curl returned >0
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: TODO
# Input:   TODO
# Output:  TODO
# Return:  0 = Success
#          1 = Failure
UpdateGEVersion() {

    update=1

    if InstallGEVersion; then
        update=0
        return 0
    else
        return 1
    fi

    return 1
}


###############################################################################
# Purpose: Install a requested proton-ge-custom release version or install the
#          latest version. If force mode is active and a saved package exists
#          for the requested version the package will be removed and a new one
#          will be downloaded.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          When called with no parameter/a NULL parameter and $update=1, the latest version will be installed.
# Output:  None
# Return:  0 = Success
#          1 = Failure
#
# TODO: Seperate Install and Update
InstallGEVersion() {

    local version

    # Determine the "mode" (install or update)
    ((debug)) && DebugMessage "Determining mode"
    if [[ $update -eq 1 ]]; then
        ((debug)) && DebugMessage "Update mode active"
        [[ -z $latest_version ]] && {
            if GetLatestGEVersion; then
                version=$latest_version
            else
                return 1
            fi
        }
    elif [[ $update -eq 0 ]]; then
        ((debug)) && DebugMessage "Install mode active"
        version=${install_version:-$(CleanUpVersion "${1-}")}
    else
        ((debug)) && DebugMessage "Unknown error detecting install mode"
        return 1
    fi

    version=$(CleanUpVersion "${1-}")

    [[ -z $version ]] && { ((debug)) && DebugMessage "version is NULL"; return 1; }

    ((debug)) && DebugMessage "Requested version is \"$version\""

    # Re-install a version that is already installed
    if (IsInstalled "$version"); then
        if [[ $force -eq 0 ]]; then
            echo "Version \"$version\" is already installed"
            return 0
        elif [[ $force -eq 1 ]]; then
            if (IsSteamRunning); then
                echo "Please close Steam before re-installing a version that is already installed"
                return 1
            else
                echo "Forcing re-install of version \"$version\""
            fi
        fi
    fi

    # if a saved package exists and force mode is not active
    if [[ -f $install_path/Proton-${version}.tar.gz ]] && [[ $force -eq 0 ]]; then
        echo "Using saved package: \"$install_path/Proton-${version}.tar.gz\""
        if (ExtractGEPackage "$version"); then
            return 0
        else
            return 1
        fi
    # if a saved package exists and force mode is active
    elif [[ -f $install_path/Proton-${version}.tar.gz ]] && [[ $force -eq 1 ]]; then
        echo "Removing saved package \"$install_path/Proton-${version}.tar.gz\""
        if ($command_rm -- "$install_path/Proton-${version}.tar.gz"); then
            echo "Package removed"
        else
            echo "Removing package failed"
            return 1
        fi
    fi

    # If a saved package for this version doesn't exist or it was removed, download it and install it
    if (DownloadGEPackage "$version"); then
        if (ExtractGEPackage "$version"); then
            echo "Installation of version \"$version\" was successful"
            return 0
        else
            echo "Installation of version \"$version\" failed"
            return 1
        fi
    else
        echo "Version \"$version\" not found"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove an installed Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
RemoveGEVersion() {

    local version
    local remove_path
    local disk_usage

    version=$(CleanUpVersion "${1-}")
    [[ -z $version ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    remove_path=$install_path/Proton-${version}

    ((debug)) && DebugMessage "Requested version: \"$version\" remove_path: \"$remove_path\""

    # Remove the path if it exists
    if [[ -d $remove_path ]]; then
        if (! IsSteamRunning); then
            # Get the disk usage in human readable format
            disk_usage=$(du -sh -- "$remove_path" 2>/dev/null)
            disk_usage=${disk_usage%[[:space:]]*}
            if ($command_rm -rf -- "$remove_path" &>/dev/null); then
                echo "Removed path \"$remove_path\" (${disk_usage:-'error'})"
            else
                echo "Failed to remove \"$remove_path\""
                return 1
            fi
        else
            echo "Please close Steam before removing an install path"
            return 1
        fi
    else
        echo "Install path not found for version \"$version\""
    fi

    return 0
}

###############################################################################
# Purpose: Extract a Proton-ge-custom package (.tar.gz) to the install path or
#          optionally to a specified path.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (optional) The path to extract the package to
# Output:  None
# Return:  0 = Success
#          1 = Failure
ExtractGEPackage() {

    local version
    local extract_file
    local extract_path

    version=$(CleanUpVersion "${1-}")
    [[ -z $version ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    extract_file=$install_path/Proton-${version}.tar.gz
    extract_path=${2:-$install_path}
    [[ ! -d $extract_path && -w $extract_path ]] && { ((debug)) && DebugMessage "Parameter error (not a valid path)"; return 1; }

    # Display "Extracting" with trailing dots indicating the extraction progress
    printf '%s' "Extracting \"$extract_file\" to \"$extract_path\""
    if tar --checkpoint=.10000 -C "$extract_path" -xzf "$extract_file" 2>/dev/null; then
        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extraction failed"
        # If the extraction failed, remove the partially extracted path
        [[ -d $extract_path/Proton-${version} ]] && {
            if ($command_rm -- "$extract_path/Proton-${version}"); then
                ((debug)) && DebugMessage "Removal succeeded"
                echo "Removed failed extraction path at \"$extract_path/Proton-${version}\""
            else
                echo "Failed to remove path of failed extraction: \"$extract_path/Proton-${version}\""
                # TODO: update/remove message when install verification is updated
                echo "This script may interpret it as a valid install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Print the currently installed Proton-ge-custom versions, saved
#          packages, and their individual disk usage to stdout.
# Input:   None
# Output:  None
# Return:  Always 0
ListInstalledGEVersions() {

    local -i i=0
    local node
    local installed_version_disk_usage
    local saved_package_disk_usage
    local saved_packages_total_disk_usage

    ((debug)) && DebugMessage "Install path: \"$install_path\""

    echo "Installed version(s):"
    for node in "$install_path"/Proton-*; do
        [[ -d $node ]] && {
            ((i++))
            # Get the disk usage of the package in human readable format
            IFS=$'\t' read -r -- installed_version_disk_usage path < <(du -sh -- "$node")
            echo "  ${node##*/} ($installed_version_disk_usage)"
        }
    done
    [[ $i -eq 0 ]] && echo "  None found"

    echo "Saved package(s):"
    i=0
    for node in "$install_path"/Proton-*.tar.gz; do
        if [[ -f $node ]]; then
            ((i++))
            if [[ $debug -eq 1 ]]; then
                DebugMessage "${node##*/} (size: $(stat -c '%s' -- "$node"), expected size: $(QueryGEAttribute "${node##*/}" "size"))"
            else
                IFS=$'\t' read -r -- saved_package_disk_usage path < <(du -h -- "$node")
                echo "  ${node##*/} ($saved_package_disk_usage)"
            fi
        fi
    done
    if [[ $i -ge 1 ]]; then
        while IFS=$'\t' read -r -- size path; do
            [[ $path = "total" ]] && saved_packages_total_disk_usage=$size
        done < <(du -csh -- "$install_path/"*.tar.gz)

        echo "Saved packages total: $saved_packages_total_disk_usage"
    elif [[ $i -eq 0 ]]; then
        echo "  None found"
    fi

    return 0
}

###############################################################################
# Purpose: Print the disk usage and file count for the install_path and/or a
#          specified version to stdout.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 A required external command was not found or the version requested was not found

# Report disk usage and file counts for the install path and/or a specified installed version
# Accepts one optional parameter, the version,
ReportGEDiskUsage() {

    local version
    local file_counter
    local disk_usage="0"
    local -i flag_missing_command=0
    local path

    version=$(CleanUpVersion "${1-}")
    # NOTE: do not return 1 if version is NULL, functionality below depends on it

    # Optional commands that are required for this function
    if ! command -v du &>/dev/null; then
        echo "Command 'du' not found"
        flag_missing_command=1
    fi

    if ! command -v find &>/dev/null; then
        echo "Command 'find' not found"
        flag_missing_command=1
    fi

    # If all command checks succeeded
    if [[ $flag_missing_command -eq 0 ]]; then
        # Set the path to be reported based on whether a version was provided or not
        if [[ -z $version ]]; then
            # Report the file count and disk usage for the entire install path
            if [[ -d $install_path ]]; then
                disk_usage=$(du -sh -- "$install_path")
                file_counter=$(find "$install_path" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' \
                       "Path: $install_path" \
                       "Files: $file_counter" \
                       "Disk usage: ${disk_usage%%[[:blank:]]*}"
            else
                ((debug)) && DebugMessage "Path: $install_path"
                echo "Version \"$version\" not found"
                return 1
            fi
        fi
        if [[ -n $version ]]; then
            # Report the file count and disk usage for a specific version
            path=$install_path/Proton-${version}
            if [[ -d $path ]]; then
                disk_usage=$(du -sh -- "$path")
                file_counter=$(find "$path" -type f | wc -l)
                echo "Version \"$version\" report:"
                printf '  %s\n  %s\n  %s\n' \
                       "Path: $path" \
                       "Files: $file_counter" \
                       "Disk usage: ${disk_usage%%[[:blank:]]*}"
            else
                ((debug)) && DebugMessage "Path: $path"
                echo "Version \"$version\" not found"
                return 1
            fi
        fi
    # If any command check failed
    elif [[ $flag_missing_command -eq 1 ]]; then
        echo "Report not available."
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove a saved package for a specified Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 Failure
RemoveSavedPackage() {

    local version
    local package

    version=$(CleanUpVersion "${1-}")
    [[ -z $version ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    package=$install_path/Proton-${version}.tar.gz

    if [[ -f $package ]]; then
        if [[ -w $package ]]; then
            if ($command_rm -- "$package"); then
                echo "Removed \"$package\""
                return 0
            else
                echo "Failed to remove version \"$version\" ($command_rm failed)"
                return 1
            fi
        else
            echo "Failed to remove version \"$version\" (no write permission)"
            return 1
        fi
    else
        echo "Failed to remove version \"$version\" (file not found)"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove all saved packages in install_path
# Input:   None
# Output:  None
# Return:  0 Success (all packages or 0 packages were removed)
#          1 Failure (any one package removal failed)
RemoveAllSavedPackages() {

    local -i success_counter=0
    local -i failure_counter=0
    local package

    ((debug)) && DebugMessage "Install path: \"$install_path\""

    for package in "$install_path"/Proton-*.tar.gz; do
        if [[ -f $package ]]; then
            if ($command_rm -- "$package"); then
                echo "Removed \"$package\""
                ((success_counter++))
            else
                echo "Remove \"$package\" failed"
                ((failure_counter++))
            fi
        fi
    done

    if [[ $success_counter -eq 0 ]]; then
        echo "0 packages removed"
    elif [[ $success_counter -gt 0 ]]; then
        echo "$success_counter packages removed"
    fi

    [[ $failure_counter -gt 0 ]] && {
        echo "Failed to remove $failure_counter package(s)"
        return 1
    }

    return 0
}

###############################################################################
# Purpose: Remove install_path
# Input:   None
# Output:  None
# Return:  0 Success
#          1 Failure (Remove failed or re-creating install_path failed)
RemoveGEInstallPath() {

    local disk_usage="0"

    if command -v du &>/dev/null; then
        disk_usage=$(du -sh -- "$install_path")
    else
        ((debug)) && DebugMessage "Command 'du' not found"
        disk_usage="unknown"
    fi

    if ($command_rm -- "$install_path"); then
        echo "Remove install path succeeded ( ${disk_usage%%[[:blank:]]*} removed )"
        ((debug)) && DebugMessage "Recreating install path at \"$install_path\""

        # Re-create the install_path
        if mkdir -p -- "$install_path" &>/dev/null; then
            ((debug)) && DebugMessage "mkdir -p \"$install_path\" succeeded"
        else
            if [[ $debug -eq 1 ]]; then
                DebugMessage "mkdir -p \"$install_path\" failed"
            else
                echo "Warning: failed to re-create install path at \"$install_path\""
                return 1
            fi
        fi
    else
        echo "Removal of install path \"$install_path\" failed"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Verify all installed versions or a specified version by comparing
#          each file from the saved package to the installed file and report
#          the number of files that match, are missing, and don't match to stdout.
# Input:   None
# Output:  None
# Return:  0 Success
#          1 Failure
# NOTE: __pycache__ is created at runtime in an installed version path and will
#       not be present in the saved packages.
VerifyGEInstall() {

    local node
    local path
    local temp_path
    local version
    local file_extracted
    local file_installed
    local saved_cmp_alias=''
    local -a files_extracted
    local -a files_installed
    local -i expected_size_bytes=0
    local -i temp_base_path_remaining_bytes=0
    local -i match_counter=0
    local -i missing_counter=0
    local -i mismatch_counter=0
    local -i files_arrays_count_match=0
    local -i total_files=0
    local -i counter_extracted=0
    local -i counter_installed=0
    local -i start_time_seconds=0 # NOTE: bash 5+ is required for EPOCHSECONDS
    local -i end_time_seconds=0   # NOTE: bash 4.2+ is required for printf $()T
    local -i progress_percent=0
    local -i prev_progress=1
    local -i flag_missing_command=0

    version=$(CleanUpVersion "${1-}")

    # Required external commands
    if ! command -v cmp &>/dev/null; then
        echo "Command 'cmp' is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v sort &>/dev/null; then
        echo "Command 'sort' is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v date &>/dev/null; then
        echo "Command 'date' is required to use this function"
        flag_missing_command=1
    fi

    # If any one required command is missing
    [[ $flag_missing_command -eq 1 ]] && return 1

    # Check for install paths that don't have a saved package, download if missing
    for node in "$install_path/Proton-"*; do
        [[ -d $node ]] && {

            # Verify that it is installed
            (IsInstalled "${node##*/}") && {

                # If no saved package exists for this version
                [[ ! -f $install_path/${node##*/}.tar.gz ]] && {
                    echo "Package not found for installed version \"${node##*/}\""
                    if (! DownloadGEPackage "${node##*/Proton-}"); then
                        return 1
                    fi
                }
            }
        }
    done

    # For each saved package available, check each file in the package against the installed file
    for node in "$install_path"/Proton-${version:-*}.tar.gz; do
        [[ -f $node ]] && {
            version=$(CleanUpVersion "${node##*/}")
            echo "Found a package for version \"$version\""
            if (! IsInstalled "$version"); then
                echo "Version \"$version\" is not installed"
                continue
            else
                echo "Version \"$version\" is installed"

                # Check for enough free space to extract the package to tmp_path
                IFS=$'\t' read -r -- expected_size_bytes path < <(du -bs -- "$install_path/Proton-${version}")
                temp_base_path_remaining_bytes=$(SpaceRemaining "$temp_base_path" "b")

                ((debug)) && {
                    DebugMessage "$version extracted size: $expected_size_bytes bytes"
                    DebugMessage "$temp_base_path_remaining_bytes remaining bytes: $temp_base_path_remaining_bytes"
                }

                [[ $expected_size_bytes -gt $temp_base_path_remaining_bytes ]] && {
                    echo "WARNING: Not enough free space at \"$temp_base_path\" to continue"
                    CleanUp
                    return 1
                }

                # Reset for each package to check
                CleanUp
                temp_path=$(MkTempPath) || { ((debug)) && DebugMessage "MkTempPath returned failure"; return 1; }
                match_counter=0
                mismatch_counter=0
                missing_counter=0
                progress_percent=0
                prev_progress=1

                # Extract the package to a temporary path
                if (! ExtractGEPackage "$version" "$temp_path"); then
                    return 1
                fi

                # Create two indexed arrays, each containing a seperate list of files,
                # one from the extracted path and the other from the installed path respectively
                echo "Indexing files to compare"

                # Array of extracted files
                while IFS= read -r -- file_extracted; do
                    files_extracted+=("$file_extracted")
                done < <(find "$temp_path/Proton-${version}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)

                # Array of installed files
                while IFS= read -r -- file_installed; do
                    files_installed+=("$file_installed")
                done < <(find "$install_path/Proton-${version}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)

                # Report the number of files found in each path
                echo "${#files_extracted[@]} (extracted) vs ${#files_installed[@]} (installed)"

                # Based on array element sizes, decide on a method to compare files
                # The faster method is a one-to-one comparison of each array element.
                # The slower method takes each element of the extracted array and then searches through
                # the entire installed array until it finds a matching file name.
                if [[ ${#files_extracted[@]} -ne ${#files_installed[@]} ]]; then
                    echo "Using slower method for comparing"
                    files_arrays_count_match=0
                else
                    echo "Using faster method for comparing"
                    files_arrays_count_match=1
                fi

                # If an alias exists for cmp (much faster than executing cmp in a subshell)
                # NOTE: This isn't necessary by default. It is included in the event that
                #       the shebang is changed and a custom alias exists for cmp.
                # TODO: do other shells' subshells inherent aliases like bash?
                if alias cmp &>/dev/null; then
                    echo "Saving existing alias for command cmp"
                    saved_cmp_alias=$(alias cmp)
                    unalias cmp
                fi

                printf '%s\033[s' "Comparing files"

                # Begin comparing, using the faster method
                # If the number of elements match
                if [[ $files_arrays_count_match -eq 1 ]]; then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"; do
                        cmp -s -- "${files_extracted[counter_extracted]}" "${files_installed[counter_extracted]}"
                        case $? in
                            (0) ((match_counter++)) ;;
                            (1) ((mismatch_counter++)) ;;
                            (2) ((missing_counter++)) ;;
                        esac
                        # Some test results - this method is already
                        # reasonably fast so not much testing was done
                        # 1 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 2 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 3 - do nothing - 5.9-GE-3-ST - 6 seconds

                        # 1 - 5.9-GE-3-ST - 6 seconds
                        # 2 - 5.9-GE-3-ST - 7 seconds
                        # 3 - 5.9-GE-3-ST - 7 seconds
                        #unset 'files_installed[counter_extracted]'
                        #unset 'files_extracted[counter_extracted]'

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))
                        [[ $progress_percent -ne $prev_progress ]] && printf '\033[u%s' "... ${progress_percent}%" # Only update the progress_percent when it actually changes
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)

                # Begin comparing, using the slower method
                elif [[ $files_arrays_count_match -eq 0 ]]; then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"; do

                        # Strip away the part of the path that is different for the current file
                        sCOMPARE_EXTRACTED=${files_extracted[counter_extracted]/#$temp_path\/}
                        for counter_installed in "${!files_installed[@]}"; do

                            # Strip away the part of the path that is different for the current file
                            sCOMPARE_INSTALLED=${files_installed[counter_installed]/#$install_path\/}

                            if [[ $sCOMPARE_INSTALLED = "$sCOMPARE_EXTRACTED" ]]; then
                                cmp -s -- "${files_installed[counter_installed]}" "${files_extracted[counter_extracted]}"
                                case $? in
                                    (0) ((match_counter++)) ;;
                                    (1) ((mismatch_counter++)) ;;
                                    (2) ((missing_counter++)) ;;
                                esac
                                # Some test results - fastest is what remains
                                # fastest - 5.9-GE-3-ST - 246 seconds
                                unset 'files_installed[counter_installed]'

                                # do nothing1 - 5.9-GE-3-ST - 376 seconds
                                # do nothing2 - 5.9-GE-3-ST - 484 seconds

                                # 5.9-GE-3-ST - 486 seconds
                                #files_installed=(${files_installed[@]:0:$counter_installed} ${files_installed[@]:$((counter_installed+1))})

                                # 5.9-GE-3-ST - 398 seconds
                                #files_installed=("${files_installed[@]:0:$counter_installed}" "${files_installed[@]:$((counter_installed+1))}")

                                #unset 'files_extracted[counter_extracted]'
                                #files_extracted=(${files_extracted[@]:0:$counter_extracted} ${files_extracted[@]:$((counter_extracted+1))})
                                #total_files=${#files_extracted[@]}
                            fi
                        done

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))
                        [[ $progress_percent -ne $prev_progress ]] && printf '\033[u%s' "... ${progress_percent}%" # Only update the progress_percent when it actually changes
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)
                fi

                # Restore saved cmp alias
                # TODO: do other shells alias command output in a reusable format?
                [[ -n $saved_cmp_alias ]] && {
                    echo "Restoring saved alias for command cmp"
                    if ! $saved_cmp_alias; then
                        echo "Failed to restore alias for 'cmp'"
                    fi
                }

                printf "\033[u\033[0K%s\n" ". Finished in $((end_time_seconds-start_time_seconds)) seconds."

                # Report
                echo "$match_counter files match. $missing_counter files are missing. $mismatch_counter do not match."

                if [[ $match_counter -gt 0 && $missing_counter -eq 0 && $mismatch_counter -eq 0 ]]; then
                    echo "Version \"$version\" appears ok"
                elif [[ $missing_counter -gt 0 || $mismatch_counter -gt 0 ]]; then
                    printf '%s\n%s\n' \
                           "WARNING: Version \"$version\" has missing or potentially corrupt files." \
                           "If you did not manually modify your installation you may want to reinstall version \"$version\""
                fi
            fi
        }
    done

    return 0
}

###############################################################################
# Purpose: A wrapper for QueryJSONAttribute that provides a single function call
#          to retrieve values from keys/attributes in both file_latest_json and
#          file_releases_json.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (required) A supported attribute name (refer to QueryJSONAttribute)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 Failure (a value was not found for the requested attribute or an error occured)
# TODO Seperate return values for not found and error
QueryGEAttribute() {

    [[ -z $1 || -z $2 || $# -ne 2 ]] && { ((debug)) && DebugMessage "Parameter error 1: \"$1\" 2: \"$2\" \$#: \"$#\""; return 1; }

    local version
    local value
    local key=${2-}

    version=$(CleanUpVersion "${1-}")

    (UpdateSavedGELatestRelease) || return 1

    # Search file_latest_json
    value=$(QueryJSONAttribute "$file_latest_json" "$version" "$key") || return 1

    # If the returned value from QueryJSONAttribute was NULL and the return status
    # was 0 (success), try file_releases_json
    if [[ -z $value ]]; then
        (UpdateSavedGEReleases) || return 1
        if value=$(QueryJSONAttribute "$file_releases_json" "$version" "$key"); then
            ((debug)) && DebugMessage "QueryJSONAttribute returned success"
        else
            ((debug)) && DebugMessage "QueryJSONAttribute returned failure"
        fi
    fi

    if [[ -n $value ]]; then
        printf '%s' "$value"
        return 0
    else
        printf '' # TODO: is it really necessary to return NULL?
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Retrieve a supported attribute value from a specified JSON file
# Input:   1 (required) JSON file
#          2 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          3 (required) A supported attribute name (size or browser_download_url)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 Failure (a value was not found for the requested attribute or an error occured)
#
# NOTE This function relies on the JSON being structured in a precise, predictable order
# Example order of attributes expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE: The default media-type requested is "application/vnd.github.v3.text+json" and
#       the current sed script also reformats the body_text section to plain text. Those
#       choices were made to more easily support (eventually) showing release notes.
QueryJSONAttribute() {

    # If the number of parameters is not exactly three, the second parameter is not a regular file, or any of the three parameters are empty
    if [[ $# -ne 3 ]] || [[ ! -f $1 ]] || [[ -z $1 || -z $2 || -z $3 ]]; then
        ((debug)) && DebugMessage "Parameter error 1: \"$1\" 2: \"$2\" 3: \"$3\" \$#: \"$#\""
        return 1
    fi

    # Check if the attribute requested is currently supported
    [[ ${3,,} != @(size|browser_download_url) ]] && { ((debug)) && DebugMessage "Parameter error (unsupported attribute requested) \"$2\""; return 1; }

    local version
    local file_json=${1-}
    local value_browser_url=''
    local key
    local -i value_size_bytes=0
    local -i counter_lines=0
    local -i line_version_found=0
    local -i line_size_found=0
    local -i line_browserurl_found=0
    local -i flag_version_found=0
    local -i flag_size_found=0
    #local flag_browserurl_found=0

    version=$(CleanUpVersion "$2")

    [[ -z $version ]] && { ((debug)) && DebugMessage "version is NULL"; return 1; }

    key=${3,,}

    # WARNING: Do not output to stdout or stderr inside the following loop
    while IFS= read -r --; do
        ((counter_lines++))
        # version match
        # version example: 5.9-GE-5-ST
        # NOTE: must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        [[ $REPLY =~ ^.*\"name\":.*\"Proton-${version}\.tar\.gz\".*$ ]] && {
            flag_version_found=1
            line_version_found=$counter_lines
        }

        # NOTE: must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        [[ $flag_version_found -eq 1 ]] && {
            [[ ${REPLY,,} =~ ^.*\"size\":.*[[:digit:]]+.*$ ]] && {
                flag_size_found=1
                line_size_found=$counter_lines
                value_size_bytes=${REPLY//[[:space:]]}
                value_size_bytes=${value_size_bytes/#\"size\":}
                value_size_bytes=${value_size_bytes%%[[:punct:]]*} # value_size_bytes=${value_size_bytes%,*}
                continue
            }
        }

        # NOTE: must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        [[ $flag_version_found -eq 1 && $flag_size_found -eq 1 ]] && {
            [[ $REPLY =~ ^.*\"browser_download_url\":.*\".*Proton-${version}\.tar\.gz\".*$ ]] && {
                #flag_browserurl_found=1
                line_browserurl_found=$counter_lines
                value_browser_url=${REPLY/#*\"browser_download_url\":}
                value_browser_url=${value_browser_url//[[:space:]]}
                value_browser_url=${value_browser_url/#\"}
                value_browser_url=${value_browser_url%%\"*}
                break
            }
        }
    done < "$file_json" 2>/dev/null

    # debug messages
    [[ $debug -eq 1 ]] && {
        if [[ $flag_version_found -eq 0 ]]; then
            DebugMessage "Version match not found"
        elif [[ $flag_version_found -eq 1 ]]; then
            DebugMessage "Version match found at line $line_version_found"
        fi
        if [[ -z $value_size_bytes ]]; then
            DebugMessage "value_size_bytes is NULL"
        else
            DebugMessage "value_size_bytes: \"$value_size_bytes\""
        fi
        if [[ -z $value_browser_url ]]; then
            DebugMessage "value_browser_url is NULL"
        else
            DebugMessage "value_browser_url: \"$value_browser_url\""
        fi
        DebugMessage "line_version_found: $line_version_found line_size_found: $line_size_found line_browserurl_found: $line_browserurl_found"
    }

    # output the value of the requested attribute
    if [[ -n $value_size_bytes && -n $value_browser_url ]]; then
        case $key in
            (size)
                printf '%s' "$value_size_bytes"
            ;;
            (browser_download_url)
                printf '%s' "$value_browser_url"
            ;;
            (*)
                # NOTE: NULL response indicates error OR not found
                #       this is NOT ideal
                printf '' # TODO: is it really necessary to return NULL?
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Run sed using the script file_sed_unminify_script (generated by the
#          function CreateSedUnminifyJSONscript) on a specified file.
# Input:   1 (required) A JSON file (minified and not minified are both supported)
# Output:  None
# Return:  0 Success
#          1 Failure
ReformatJSONUsingSed() {

    local file_json=${1-}

    [[ -z $file_json ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    [[ -f $file_json ]] || { ((debug)) && DebugMessage "Parameter error (not a file)"; return 1; }

    ((debug)) && DebugMessage "file_json: \"$file_json\""

    if [[ -w $file_json ]]; then
        if sed -if -- "$file_sed_unminify_script" "$file_json"; then
            ((debug)) && DebugMessage "'sed' returned success"
            return 0
        else
            ((debug)) && DebugMessage "'sed' returned failure"
            return 1
        fi
    else
        ((debug)) && DebugMessage "No write access: \"$file_json\""
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Detect if a specified JSON file is minified or not. Used for debug
#          reporting only because the unminify script is run on the JSON
#          regardless of the result of this function. This function is not
#          generic. It is only applicable to Github api responses in JSON format.
# Input:   1 (required) A JSON file
# Output:  None
# Return:  0 Yes/True
#          1 No/False
IsJSONminified() {

    local file_json=${1-}
    local -i counter_lines=0

    [[ -z $file_json ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    [[ ! -f $file_json || ! -r $file_json ]] && { ((debug)) && DebugMessage "Parameter error (not a file and/or not readable)"; return 1; }

    counter_lines=$(wc -l -- < "$file_json")
    ((debug)) && DebugMessage "counter_lines: \"$counter_lines\""
    # 0 is the actual line value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added
    if [[ $counter_lines -le 1 ]]; then
        ((debug)) && DebugMessage "JSON is minified"
        return 0
    else
        ((debug)) && DebugMessage "JSON is not minified"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: If the sed script file_sed_unminify_script is not found or it's size
#          in bytes does not match an expected value, create/overwrite it
# Input:   None
# Output:  None
# Return:  Always 0
CreateSedUnminifyJSONscript() {

    if [[ ! -f $file_sed_unminify_script ]] || [[ $(stat -c '%s' -- "$file_sed_unminify_script") -ne $size_bytes_sed_unminify_script ]]; then
        ((debug)) && DebugMessage "'sed' script at \"$file_sed_unminify_script\" does not exist or is not the expected size ($size_bytes_sed_unminify_script)"
        (cat) <<"END_OF_SED_SCRIPT" > "$file_sed_unminify_script"
#### begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s/","/"\n"/g
#### end minimum required for ge-install-manager

# replace:  "assets": [
# with:     "assets":newline
s/"assets":\[/"assets":\n/g

# replace:  :{"
# with:     :newline"
s/:{"/:\n"/g

# replace:  "},"
# with:     "newline"
s/"},"/"\n"/g

# replace:  },"
# with:     newline"
s/},"/\n"/g

# replace:  {"
# with:     "
s/{"/"/g

#### Re-format text intended for formating ('\n') in "body_text" when media type
#### "application/vnd.github.v3.text+json" is requested
# replace:  \n
# with:     newline
s/\\n/\n/g

# replace:  ,"
# with:     newline"
s/,"/\n"/g

#### one per release listed
# replace:  "}]
# with:     "
s/"}\]/"/g

# replace:  "}
# with:     "
s/"}/"/g

#### very minor
# replace:  ["
# with:     "
s/\["/"/g
END_OF_SED_SCRIPT
    else
        ((debug)) && DebugMessage "'sed' script already exists at file_sed_unminify_script and is the expected size ($size_bytes_sed_unminify_script)"
    fi

    return 0
}

###############################################################################
# Purpose: Check if a version is installed
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Yes/True
#          1 No/False
# NOTE: Currently only checks if a path for the version exists
# TODO: Find a better way that is reliable
IsInstalled() {

    local version

    [[ -z $1 ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }

    version=$(CleanUpVersion "${1-}")

    ((debug)) && DebugMessage "Checking for version \"$version\" at \"$install_path/Proton-${version}\""

    if [[ -d $install_path/Proton-${version} ]]; then
        ((debug)) && DebugMessage "Version \"$version\" found"
        return 0
    else
        ((debug)) && DebugMessage "Version \"$version\" not found"
        return 1
    fi

    # NOTE: do not return 0 here
}

###############################################################################
# Purpose: Check if Steam is running
# Input:   None
# Output:  None
# Return:  0 Yes/True
#          1 No/False (ps not found or Steam is not running but steamwebhelper is or unknown error)
IsSteamRunning() {

    local -i found_steam=0
    local -i found_steamwebhelper=0

    while IFS= read -r --; do
        [[ ${REPLY,,} =~ ^.*steam$ ]] && {
            found_steam=1
            ((debug)) && DebugMessage "'steam' match: \"$REPLY\""
        }
        [[ ${REPLY,,} =~ ^.*steamwebhelper.*$ ]] && {
            found_steamwebhelper=1
            ((debug)) && DebugMessage "'steamwebhelper' match: \"$REPLY\""
        }
    done < <(ps -e 2>/dev/null)
    #return $(( found_steam == 1 ? 0 : 1 ))

    if [[ $found_steam -eq 1 ]]; then
        return 0
    elif [[ $found_steam -eq 0 && $found_steamwebhelper -eq 1 ]]; then
        echo "Warning: at least one steamwebhelper process is still running but Steam is not"
        # TODO: report their PIDs
        return 1
    elif [[ $found_steam -eq 0 && $found_steamwebhelper -eq 0 ]]; then
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Use curl -z to request a specified URL if the remote URL has an mtime
#          newer than the provided file. Used to update file_latest_json and
#          file_releases_json only when needed.
# Input:   1 (required) A URL (latest_version_url or releases_url)
#          2 (required) A file (does not have to exist)
# Output:  None
# Return:  0 Success
#          1 Failure
RequestURL() {

    local requested_url=${1-}
    local file_local=${2-}
    local file_temp

    file_temp=$(MkTempFile) || { ((debug)) && DebugMessage "MkTempFile returned failure"; return 1; }

    [[ -z $requested_url || -z $file_local || $# -ne 2 ]] && ((debug)) && DebugMessage "Parameter error (NULL or not exactly two)"
    [[ ! -f $file_temp || ! -w $file_temp ]] && ((debug)) && DebugMessage "Parameter error (temp file not a file or not writeable)"

    if (curl -sz "$file_local" \
             -H "$CURL_HEADER_USER_AGENT" \
             -H "$CURL_HEADER_CONTENT_TYPE" \
             -H "$CURL_HEADER_GITHUB_MEDIATYPE" \
             -L "$requested_url" \
             -o "$file_temp" 2>/dev/null); then

        ((debug)) && DebugMessage "'curl' returned success"
        if [[ $(stat -c '%s' -- "$file_temp") -gt 0 ]]; then
            if [[ -f $file_temp && -r $file_temp ]]; then
                # TODO: replace pattern matching tests with size comparisons using stat (need a sample for rate limit exceeded)
                while IFS= read -r --; do
                    [[ $REPLY == *"rate limit exceeded"* ]] && {
                        echo "($LINENO) RequestURL: Github API request rate limit exceeded. Try again later." 1>&2
                        CleanUp
                        return 1
                    }
                    [[ ${REPLY,,} == *"not found"* ]] && {
                        echo "($LINENO) RequestURL: Server responded \"Not Found\"" 1>&2
                        CleanUp
                        return 1
                    }
                done < "$file_temp"

                # NOTE: Only the status is checked, unminify is run regardless of the result
                (IsJSONminified "$file_temp")

                if (ReformatJSONUsingSed "$file_temp"); then
                    ((debug)) && DebugMessage "ReformatJSONUsingSed returned success"

                    # If the local file already exists, create a backup first
                    [[ -f $file_local ]] && (CreateBackup "$file_local")
                    if cp -f -- "$file_temp" "$file_local"; then
                        return 0
                    else
                        ((debug)) && DebugMessage "Failed to copy \"$file_temp\" to \"$file_local\""
                        return 1
                    fi
                else
                    ((debug)) && DebugMessage "ReformatJSONUsingSed returned failure"
                    return 1
                fi
            else
                ((debug)) && DebugMessage "file_temp not found or not readable: \"$file_temp\""
                return 1
            fi
        else
            # remote file is not newer if curl returns success and the response is NULL
            ((debug)) && DebugMessage "file_temp is size 0: \"$file_temp\""
            return 0
        fi
    else
        ((debug)) && DebugMessage "'curl' returned failure"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Backup a file/path in tar.gz format supporting upto a configurable
#          number (n) of backups with a basename (sans extension) suffix of _n.
#          The newest backup is the lowest index (n) and the oldest backup is
#          the highest index (n). The backups are stored in the parent path of
#          the file/path to be backed up.
# Input:   1 (required) The file or path to backup
# Output:  None
# Return:  0 Success
#          1 Failure
CreateBackup() {

    local backup_target=${1-}
    local backup_target_basename
    local backup_target_path
    local file
    local -i max_backups=3
    local -i backups_counter=0
    local -i backup_index=0
    local -i flag_rename_backups=0
    local -a files_existing_backups
    shopt -s nullglob dotglob

    [[ -z $backup_target ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }
    if [[ -f $backup_target ]]; then
        ((debug)) && DebugMessage "backup_target is a file"
    else
        ((debug)) && DebugMessage "backup_target is not a file"
        if [[ -d $backup_target ]]; then
            ((debug)) && DebugMessage "backup_target is a path"
        else
            ((debug)) && DebugMessage "Parameter error (not a file or a path)"
            return 1
        fi
    fi

    # If a relative file/path was given
    [[ ${backup_target:0:1} != "/" || ${backup_target:0:2} == "./" ]] && {
        ((debug)) && DebugMessage "Resolving relative path"
        backup_target=$(realpath -- "$backup_target" 2>/dev/null)
    }

    # If backup_target is a file, get the path to it
    if [[ -f $backup_target && ! -d $backup_target ]]; then
        backup_target_path=${backup_target%/*}
    else
        # Get the parent path of the backup_target
        backup_target_path=$(realpath -- "$(dirname -- "$backup_target" 2>/dev/null)" 2>/dev/null)
    fi

    backup_target_basename=${backup_target##*/}

    # Determine the basename suffix to use {1..$max_backups}
    for file in "$backup_target_path/$backup_target_basename"_?.tar.gz; do
        if [[ $file =~ ^.*[^_]_[[:digit:]]{1}\.tar\.gz$ ]]; then
            backup_index=${file##*_}
            backup_index=${backup_index/%.tar.gz}
            ((debug)) && DebugMessage "backup_index is $backup_index"
            [[ $backup_index =~ ^[[:digit:]]+$ ]] && {
                ((backups_counter++))
                files_existing_backups+=("$file")
                ((debug)) && DebugMessage "Valid backup file found at \"$file\""
                if [[ $backup_index = "1" ]]; then
                    ((debug)) && DebugMessage "backup_index 1 found, existing backups will be renamed"
                    flag_rename_backups=1
                fi
            }
        fi
    done
    ((debug)) && DebugMessage "Found $backups_counter backups"

    if [[ $flag_rename_backups -eq 1 ]]; then
        backup_index=$backups_counter
        if [[ $backup_index -ge $max_backups ]]; then

            # Remove the oldest (highest index) backup until max_backups is reached
            while [[ $backup_index -ge $max_backups ]]; do
                if ($command_rm -- "${files_existing_backups[backup_index-1]}"); then
                    ((debug)) && DebugMessage "Removed highest index greater than $max_backups: \"${files_existing_backups[backup_index-1]}\""
                    backup_index=$((backup_index-1))
                else
                    echo "($LINENO) CreateBackup: Failed to remove backup file ${files_existing_backups[backup_index-1]}"
                    return 1
                fi
            done
        fi

        # Rename existing backups, leaving room for a new index 1 (increment each existing index by +1)
        for ((backup_index; backup_index>=1; backup_index--)); do
            if mv -- "${files_existing_backups[backup_index-1]}" "${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"; then
                ((debug)) && DebugMessage "${files_existing_backups[backup_index-1]} renamed to ${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"
            else
                echo "($LINENO) CreateBackup: Failed to rename backup file: \"${files_existing_backups[backup_index-1]}\""
                return 1
            fi
        done
    else
        ((debug)) && DebugMessage "backup_index not found, not renaming backups"
    fi

    if tar -C "$backup_target_path" -cf "$backup_target_path/${backup_target_basename}_1.tar.gz" -z "$backup_target_basename"; then
        ((debug)) && DebugMessage "Created new backup at: \"$backup_target_path/${backup_target_basename}_1.tar.gz\""
        return 0
    else
        ((debug)) && DebugMessage "Backup failed: \"$backup_target_path/${backup_target_basename}_1.tar.gz\""
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Given a file/path (filesystem) and a unit (binary prefix), use stat
#          to calculate the remaining space on a filesystem by multiplying
#          the filesystem block size by the number of remaining blocks and
#          return the value in the unit requested.
# Input:   1 (required) File/path on the filesystem to check
#          1 (required) Binary prefix (see case below for supported formats)
# Output:  Integer value representing the space remaining in the unit requested
#          WARNING: Bash arithmatic is used because this script does not require
#                   the precision afforded by bc/etc.
# Return:  0 Success
#          1 Failure
# NOTE: bash arithmatic supports upto 1024^6/1024**6 (exbibyte)
# TODO: Add a third, optional parameter to request calculations using bc
SpaceRemaining() {

    local file_system=${1-}
    local binary_prefix=${2-}
    local -i power_of=0

    [[ -z $file_system || -z $binary_prefix ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }

    [[ ! -d $file_system ]] && { ((debug)) && DebugMessage "Parameter error (not a directory)"; return 1; }

    case ${binary_prefix,,} in
        (b|byte|bytes) power_of=0 ;;
        (k|kibi|kibibyte) power_of=1 ;;
        (m|mebi|mebibyte) power_of=2 ;;
        (g|gibi|gibibyte) power_of=3 ;;
        (t|tebi|tebibyte) power_of=4 ;;
        (p|pebi|pebibyte) power_of=5 ;;
        (e|exbi|exbibyte) power_of=6 ;;
    esac

    ((debug)) && DebugMessage "Checking \"$file_system\""

    if printf '%s' "$(( ($(stat -L --cached=never -c '%s' -f -- "$file_system") * $(stat -L --cached=never -c '%a' -f -- "$file_system")) / ( 1024 ** power_of ) ))"; then
        return 0
    else
        return 1
    fi
}

###############################################################################
# Purpose: Check if a requested amount of memory is currently free. Calculate
#          the real remaining memory if MemAvailable isn't available from
#          /proc/meminfo. Supports some fairly old kernels. Currently, this
#          function is not used by this script.
# Input:   1 (required) An integer representing the amount needed in kB
# Output:  None
# Return:  0 = Success
#          1 = Failure
# NOTE: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0a
# NOTE: https://github.com/torvalds/linux/blob/6aa303defb7454a2520c4ddcdf6b081f62a15890/mm/page_alloc.c#L4025
MemFree() {

    # MemAvailable
    local -i memory_available=0
    local -i requested_memory_free_kb=${1:-0}
    # MemAvailable not available
    local -i low_watermarks_total=0
    local -i memory_free=0
    local -i page_cache_total=0
    local -i sreclaimable=0
    local -i memory_available_kb=0
    local -i sunreclaimable=0

    [[ -z $requested_memory_free_kb ]] && { ((debug)) && DebugMessage "Parameter error (NULL)"; return 1; }

    ((debug)) && DebugMessage "Requested free: $requested_memory_free_kb"

    # If MemAvailable is present in /proc/meminfo (kernel >= 3.14)
    while IFS= read -r --; do
        [[ ${REPLY,,} == *memavailable* ]] && {
            REPLY=${REPLY%[[:blank:]]*}
            memory_available=${REPLY##*[[:blank:]]}
            [[ $memory_available =~ ^[[:digit:]]+$ ]] && {
                ((debug)) && DebugMessage "MemAvailable found in /proc/meminfo"
                ((debug)) && DebugMessage "MemAvailable: $memory_available"

                return $(( memory_available > requested_memory_free_kb ? 0 : 1 ))
            }
        }
    done </proc/meminfo

    # If MemAvailable is not available in /proc/meminfo - adds support for older kernel versions ( v2.6 < [uname -r] < v3.14)
    ((debug)) && DebugMessage "MemAvailable not found, using older methods"

    # Get the sum of the low water marks across all zones
    while IFS= read -r --; do
        [[ ${REPLY,,} == *low* ]] && {
            REPLY=${REPLY//[[:alpha:]]}
            REPLY=${REPLY//[[:blank:]]}
            low_watermarks_total=$((low_watermarks_total+REPLY))
        }
        # Get nr_slab_unreclaimable if available (v4.8+)
        [[ ${REPLY,,} == *nr_slab_unreclaimable* ]] && {
            REPLY=${REPLY##*[[:blank:]]}
            REPLY=${REPLY%[[:blank:]]*} # Not needed on my system, kept just in case
            sunreclaimable=$REPLY
        }
    done </proc/zoneinfo
    # TODO: 0 could indicate a serious problem or a customization?
    #[[ $low_watermarks_total -le 0 ]] && return 1

    # Parse /proc/meminfo
    while IFS= read -r --; do
        # MemFree
        [[ ${REPLY,,} == *memfree* ]] && {
            REPLY=${REPLY%[[:blank:]]*}
            memory_free=${REPLY##*[[:blank:]]}
            memory_available_kb=$((memory_free-low_watermarks_total))
        }
        # SReclaimable
        [[ ${REPLY,,} == *sreclaimable* ]] && {
            REPLY=${REPLY%[[:blank:]]*}
            sreclaimable=${REPLY##*[[:blank:]]}
        }
        # PageCache [ active(file) + inactive(file) ]
        if [[ ${REPLY,,} == *active\(file\)* ]] || [[ ${REPLY,,} == *inactive\(file\)* ]]; then
            REPLY=${REPLY%[[:blank:]]*}
            REPLY=${REPLY##*[[:blank:]]}
            page_cache_total=$((page_cache_total+REPLY)) # NOTE: two iterations are required to add both
        fi
    done </proc/meminfo

    # pagecache -= min(pagecache / 2, wmark_low);
    # subtract the lower of the two (page_cache_total/2) vs low_watermarks_total
    if [[ $low_watermarks_total -lt $(( page_cache_total / 2 )) ]]; then
        page_cache_total=$(( page_cache_total - low_watermarks_total ))
    elif [[ $(( page_cache_total / 2 )) -lt $low_watermarks_total ]]; then
        page_cache_total=$(( page_cache_total - (page_cache_total / 2) ))
    fi

    # reclaimable
    # subtract the lower of the two (sreclaimable/2) vs low_watermarks_total
    if [[ $low_watermarks_total -lt $(( sreclaimable / 2 )) ]]; then
        sreclaimable=$(( sreclaimable - low_watermarks_total ))
    elif [[ $(( sreclaimable / 2 )) -lt $low_watermarks_total ]]; then
        sreclaimable=$(( sreclaimable - (sreclaimable / 2) ))
    fi

    # Add both to memory_available_kb for the grand total
    # NOTE: nr_slab_unreclaimable may not be available on [uname -r] < 4.8
    if [[ $sunreclaimable -gt 0 ]]; then
        ((debug)) && DebugMessage "Using kernel v4.8+ calculation"
        memory_available_kb=$(( (memory_available_kb + page_cache_total + sreclaimable) - sunreclaimable ))
    else
        ((debug)) && DebugMessage "Using kernel <4.8 calculation"
        memory_available_kb=$(( (memory_available_kb + page_cache_total + sreclaimable) - (12 * low_watermarks_total) ))
    fi
    ((debug)) && DebugMessage "Available: $memory_available_kb"

    return $(( memory_available_kb > requested_memory_free_kb ? 0 : 1 ))
}

###############################################################################
# Purpose: If file_script_config is not found, create a default
# Input:   None
# Output:  None
# Return:  Always 0
CreateDefaultConfigFile() {

    (cat) <<DEFAULT_CONFIG > "$file_script_config" # This section is subject to expansion, etc.
#
# $SCRIPT_FULL_NAME v$SCRIPT_VERSION Default configuration file
#
# Quick start format:
# #comment
# key=value #comment
#
# Lines begining with an octothorpe "#" are considered comment lines and are ignored.
# Any characters that follow a space and an octothorpe " #" are considered comments.
# Empty lines and lines that begin with space/tab are ignored.
# Lines that contain one or more semi-colon(s) ";" will be ignored.
# Lines that contain potential escape sequences are ignored.
# A key with a null value and a value with a null key are ignored (eg. "key=" and "=value").
#
# Paths (install, cache, and tmp) do not have to exist but
# the script will need write permission to create them for you.
#
# When install_path is set to the special value "auto", the script will
# attempt to auto-detect the Steam installation path.
#
# Environment variables and script global variables will be expanded.
# \$SCRIPT_FULL_NAME is a script global variable that is always set to the basename of the script.
#
# Symlinks will not be resolved/canonicalized (they are safe to use).
#
# Do not quote variables outside parameter expansions (:+, :-, :=, or :?) unless
# you want the quotes included in the value.
#
DEFAULT_CONFIG

    cat <<"DEFAULT_CONFIG" >> "$file_script_config" # This section is not subject to expansion, etc.

# Default install path
install_path=auto

# Default cache path
cache_path=${XDG_CACHE_HOME:-"$HOME"/.cache}/$SCRIPT_FULL_NAME

# Default command used instead of rm (for removing all but temporary files)
# NOTE: Any command and its parameters that support the last parameter being either a file or a path is supported
rm_command=trash

# Default URL used to retrieve 'latest' JSON
latest_version_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest

# Default URL used to retrieve 'releases' JSON
releases_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases

# Default temporary file path
tmp_path=/tmp
DEFAULT_CONFIG

    return 0
}


###############################################################################
# Purpose: Parse the config file set in the global variable file_script_config,
#          validate recognized key/value pairs and then set/reset global
#          variables accordingly.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Runs DetectSteamInstallPath if install_path is set to the special value "auto"
ParseConfigFile() {

    local -i existing_config_file_lines=0
    local -i counter_config_line=0
    local -i flag_failed=0
    local -i flag_update_install_path=0
    local config_key
    local config_value

    existing_config_file_lines=$(wc -l 2>/dev/null < "$file_script_config") # NOTE: do not || return 1 here

    # If existing_config_file_lines is empty, create a default config file
    [[ -z $existing_config_file_lines ]] && {
        ((debug)) && DebugMessage "Generating a default config file at: \"$file_script_config\""
        if (CreateDefaultConfigFile); then
            ((debug)) && DebugMessage "CreateDefaultConfigFile returned success"
            echo "Default configuration created at \"$file_script_config\""
            if [[ -n ${EDITOR-} ]]; then
                ((debug)) && DebugMessage "EDITOR is set to: \"$EDITOR\""
                while :; do
                    read -rp "Would you like to open it with ${EDITOR}? " </dev/tty
                    case ${REPLY,,} in
                        ("y"|"yes") ($EDITOR "$file_script_config"); exit 0 ;;
                        ("n"|"no") exit 0 ;;
                        ("*") echo "Enter (y)es or (n)o" ;;
                    esac
                done
            else
                echo "EDITOR not set, default configuration created at \"$file_script_config\""
            fi
            exit 0
        else
            # NOTE: CreateDefaultConfigFile currently always returns 0
            ((debug)) && DebugMessage "CreateDefaultConfigFile returned failure status"
            return 1
        fi
    }

    ((debug)) && DebugMessage "file_script_config \"$file_script_config\" contains $existing_config_file_lines newlines"

    # Sanity checks
    [[ -z $file_script_config || ! -f $file_script_config || ! -w $file_script_config ]] && {
        ((debug)) && DebugMessage "file_script_config error (NULL, not a file, or not writeable)"
        return 1
    }

    # Begin parsing file_script_config
    while IFS= read -r --; do

        # Increment the line counter
        ((counter_config_line++))

        # Ignore lines that begin with a # (comments)
        [[ $REPLY =~ ^#.*$ ]] && { ((debug)) && DebugMessage "Ignoring line $counter_config_line (begins with a \"#\")"; continue; }

        # Ignore lines that contain one or more semi-colon ";". Anti-exploit measure.
        [[ $REPLY =~ ^.*\;+.*$ ]] && { ((debug)) && DebugMessage "Ignoring line $counter_config_line (contains one or more \";\")"; continue; }

        # Ignore lines containing potential escape sequences. Anti-exploit measure.
        [[ $REPLY =~ ^.*\\[[:digit:]]+\[.*$ ]] && { ((debug)) && DebugMessage "Ignoring line $counter_config_line (contains potential escape code)"; continue; }

        # Trim away inline comments
        if [[ $REPLY =~ ^.*#.*$ ]]; then
            ((debug)) && DebugMessage "Partially commented line $counter_config_line: \"$REPLY\""
            # remove the ' #' and everything to the right of it
            # NOTE: valid comments are preceded by at least one [[:blank:]]
            # BUG: this will mangle herestrings that contain comments
            REPLY=${REPLY%%[[:blank:]]#*}
        fi

        # Ignore lines that are empty
        [[ -z $REPLY ]] && { ((debug)) && DebugMessage "Ignoring line $counter_config_line (empty)"; continue; }

        # Ignore lines that don't contain exactly one = and also don't have characters on either side of the = sign. If there are characters on either
        # side of the = sign, they may not be spaces or tabs
        [[ $REPLY =~ ^[^=[:blank:]]+=[^=[:blank:]]+$ ]] || { ((debug)) && DebugMessage "Ignoring line $counter_config_line (improperly formatted)"; continue; }

        ((debug)) && DebugMessage "Potentially valid config line ($counter_config_line): \"$REPLY\""

        # Get the key (the characters to the left of the equals "=" sign)
        config_key=${REPLY%%=*}

        # Get the value (the characters to the right of the equals "=" sign)
        config_value=${REPLY#*=}

        ((debug)) && DebugMessage "config line $counter_config_line - Key: \"$config_key\" Value: \"$config_value\""

        # Expand any variables in the config using envsubst if possible and if not use eval
        # Skip expansion if the value doesn't contain one or more $
        # Simply put, envsubst can handle only simple environment variable expansion
        if [[ $config_value =~ ^.*[$]+.*$ ]]; then
            if [[ $config_value =~ ^.*:[+-=?]{1}.*$ ]]; then
                ((debug)) && DebugMessage "Using 'eval' to expand config_value: \"$config_value\""
                config_value=$(eval printf '%s' "$config_value")
                ((debug)) && DebugMessage "config_value expanded to: \"$config_value\""
            else
                if command -v envsubst &>/dev/null; then
                    ((debug)) && DebugMessage "Using 'envsubst' to expand config_value: \"$config_value\""
                    config_value=$(envsubst <<< "$config_value")
                    # If there is still a $ in config_value it contained a variable envsubst can't handle
                    [[ $config_value =~ ^.*\$+.*$ ]] && {
                        ((debug)) && DebugMessage "config_value still contains one or more $ after envsubst"
                        config_value=$(eval printf '%s' "$config_value")
                        ((debug)) && DebugMessage "config_value expanded again with 'eval' to: \"$config_value\""
                    }
                    ((debug)) && DebugMessage "config_value expanded to: \"$config_value\""
                else
                    ((debug)) && DebugMessage "Command 'envsubst' not available, using 'eval' to expand config_value: \"$config_value\""
                    config_value=$(eval printf '%s' "$config_value")
                    ((debug)) && DebugMessage "config_value expanded to: \"$config_value\""
                fi
            fi
        else
            # No $ were found, no expansion necessary
            ((debug)) && DebugMessage "Skipping expansion of config_value: \"$config_value\""
        fi

        # Validate values for recognized keys and set global variables accordingly
        case $config_key in
            (install_path)
                # if the value for install_path is the special value "auto", attempt to auto detect the steam install path
                # NOTE: If one is found/chosen the global variable override_default_install_path will be set accordingly.
                #       A value of NULL indicates a problem, error, or user chose manual configuration in which case
                #       the value will remain auto.
                [[ ${config_value,,} = "auto" ]] && {
                    ((debug)) && DebugMessage "$config_key is set to $config_value, Running DetectSteamInstallPath"
                    DetectSteamInstallPath
                    if [[ -n $override_default_install_path && ${override_default_install_path,,} != "auto" ]]; then
                        config_value=$override_default_install_path/compatibilitytools.d
                        flag_update_install_path=1
                    else
                        return 1
                    fi
                }
                if [[ -d $config_value && -w $config_value ]]; then
                    ((debug)) && DebugMessage "$config_value is a directory and the script has write permission to it"
                    install_path=$config_value
                    flag_update_install_path=1
                else
                    ((debug)) && DebugMessage "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((debug)) && DebugMessage "script has write permission to config_value"
                            install_path=$config_value
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                            flag_failed=1
                            flag_update_install_path=0
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                        flag_failed=1
                        flag_update_install_path=0
                    fi
                fi
            ;;
            #(config_path)
            #    if [[ -d $config_value && -w $config_value ]]; then
            #        ((debug)) && DebugMessage "$config_value is a directory and the script has write permission to it"
            #        script_config_path=$config_value
            #    else
            #        ((debug)) && DebugMessage "$config_value is not a valid path, attempting to create it"
            #        if mkdir -p -- "$config_value" &>/dev/null; then
            #            if [[ -w $config_value ]]; then
            #                ((debug)) && DebugMessage "script has write permission to config_value"
            #                script_config_path=$config_value
            #            else
            #                echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
            #                flag_failed=1
            #            fi
            #        else
            #            echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
            #            flag_failed=1
            #        fi
            #    fi
            #;;
            (cache_path)
                if [[ -d $config_value && -w $config_value ]]; then
                    ((debug)) && DebugMessage "$config_value is a directory and the script has write permission to it"
                    script_cache_path=$config_value
                else
                    ((debug)) && DebugMessage "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((debug)) && DebugMessage "script has write permission to config_value"
                            script_cache_path=$config_value
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                            flag_failed=1
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                        flag_failed=1
                    fi
                fi
            ;;
            (tmp_path) # temp_base_path
               if [[ -d $config_value && -w $config_value ]]; then
                    ((debug)) && DebugMessage "$config_value is a directory and the script has write permission to it"
                    temp_base_path=$config_value
                else
                    ((debug)) && DebugMessage "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((debug)) && DebugMessage "script has write permission to config_value"
                            temp_base_path=$config_value
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                            flag_failed=1
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                        flag_failed=1
                    fi
                fi
            ;;
            (rm_command)
                if (command -v -- "$config_value" &>/dev/null); then
                    command_rm=$config_value
                    ((debug)) && DebugMessage "command_rm set to: \"$command_rm\""
                else
                    ((debug)) && DebugMessage "command -v \"$config_value\" failed"
                    printf '%s\n%s\n' \
                                   "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\"" \
                                   "($LINENO) ParseConfigFile: If you don't want the script to use 'rm' then fix it"
                    command_rm='rm'
                fi
            ;;
            (latest_version_url)
                if curl -sLI -- "$config_value" &>/dev/null; then
                    latest_version_url=$config_value
                    ((debug)) && DebugMessage "latest_version_url set to: \"$latest_version_url\""
                else
                    echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                    flag_failed=1
                fi
            ;;
            (releases_url)
                if curl -sLI -- "$config_value" &>/dev/null; then
                    releases_url=$config_value
                    ((debug)) && DebugMessage "releases_url set to: \"$releases_url\""
                else
                    echo "($LINENO) ParseConfigFile: Invalid value for $config_key at line $counter_config_line: \"$config_value\""
                    flag_failed=1
                fi
            ;;
            (*)
                ((debug)) && DebugMessage "No key match for valid config ($counter_config_line): \"$REPLY\""
            ;;
        esac
    done < "$file_script_config"

    # Update install_path in the configuration file if necessary
    [[ $flag_update_install_path -eq 1 ]] && {
        [[ -n ${override_default_install_path-} ]] && {
            install_path=$override_default_install_path/compatibilitytools.d
            [[ -f $file_script_config ]] && (CreateBackup "$file_script_config")
            sed -i "s|install_path=auto|install_path=$install_path|" -- "$file_script_config"
        }
    }

    # If any crucial config options are empty (missing from config, except script_config_path)
    [[ -z ${install_path-} ]] && {
        echo "($LINENO) ParseConfigFile: Invalid/missing install_path ($file_script_config)"
        return 1
    }

    [[ -z ${temp_base_path-} ]] && {
        echo "($LINENO) ParseConfigFile: Invalid/missing temp_base_path ($file_script_config)"
        return 1
    }

    [[ -z ${script_config_path-} ]] && {
        echo "($LINENO) ParseConfigFile: Invalid/missing script_config_path (See InitializeGlobalVars)"
        return 1
    }

    [[ -z ${script_cache_path-} ]] && {
        echo "($LINENO) ParseConfigFile: Invalid/missing script_cache_path ($file_script_config)"
        return 1
    }

    # Debug report
    ((debug)) && DebugMessage "Install path set to: \"$install_path\""
    ((debug)) && DebugMessage "Temp path set to: \"$temp_base_path\""
    ((debug)) && DebugMessage "Config path set to: \"$script_config_path\""
    # NOTE: config_path is currently not configurable
    # update global variables that depend on this one
    #file_script_config=$script_config_path/$SCRIPT_FULL_NAME.conf
    #((debug)) && DebugMessage "file_script_config set to: \"$file_script_config\""
    #((debug)) && DebugMessage "file_sed_unminify_script set to: \"$file_sed_unminify_script\""

    ((debug)) && DebugMessage "Cache path set to: \"$script_cache_path\""
    # update global variables that depend on this one
    file_latest_json="$script_cache_path"/latest.json
    ((debug)) && DebugMessage "file_latest_json set to: \"$file_latest_json\""

    file_releases_json="$script_cache_path"/releases.json
    ((debug)) && DebugMessage "file_releases_json set to: \"$file_releases_json\""

    if [[ $flag_failed -eq 1 ]]; then
        ((debug)) && DebugMessage "One or more tasks failed"
        return 1
    else
        ((debug)) && DebugMessage "All tasks and checks passed"
        return 0
    fi
}

###############################################################################
# Purpose: "Clean" a specified version. Enables internal support for multiple
#          formats while still reporting with the original format.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  A "clean" version string with no trailing newline (stdout) (eg. 5.9-GE-5-ST)
# Return:  Always 0
CleanUpVersion() {

    local version=${1-}
    local -i length_characters=0

    [[ -z $version ]] && { ((debug)) && DebugMessage "version is NULL"; printf ''; return 1; }

    [[ $debug -eq 1 ]] && {
        length_characters=${#version}
        DebugMessage "Before: \"$version\""
    }

    # global upper case
    version=${version^^}

    # anchored left, remove a single "PROTON-" and anything to the left of it
    version=${version#*'PROTON-'}

    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    version=${version%'.TAR.GZ'*}

    [[ $debug -eq 1 ]] && {
        DebugMessage "After: \"$version\""
        [[ $length_characters -ne ${#version} ]] && DebugMessage "Removed $(( length_characters - ${#version} )) characters"
    }

    printf '%s' "$version"

    return 0
}

###############################################################################
# Purpose: Bash only primitive replacement for mktemp (file version)
# Input:   None
# Output:  A string containing a path and file with no trailing newline (stdout)
# Return:  0 (Success)
#          1 (Failure)
MkTempFile() {

    local temp_file

    [[ -d $temp_base_path && -w $temp_base_path ]] || { ((debug)) && DebugMessage "temp_base_path is not a valid path or no write access: \"$temp_base_path\""; return 1; }

    temp_file=$temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16)

    ((debug)) && DebugMessage "Created temp file at: \"$temp_file\""

    # Create the empty temp file
    printf '' > "$temp_file" || return 1

    # "Return" the path and filename,
    # meant to be captured using command substitution eg. sTEMPFILE=$(MkTemp)
    printf '%s' "$temp_file"

    return 0
}

###############################################################################
# Purpose: Bash only primitive replacement for mktemp (path version)
# Input:   None
# Output:  A string containing a path with no trailing newline (stdout)
# Return:  0 (Success)
#          1 (Failure)
MkTempPath() {

    local temp_path

    [[ -d $temp_base_path && -w $temp_base_path ]] || { ((debug)) && DebugMessage "temp_base_path is not a valid path or no write access: \"$temp_base_path\""; return 1; }

    temp_path=$temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16) || return 1

    ((debug)) && DebugMessage "Created temp path at: \"$temp_path\""

    # Create the path
    mkdir -p "$temp_path" &>/dev/null || return 1

    # "Return" the path and filename,
    # meant to be captured using command substitution eg. sTEMPFILE=$(MkTemp)
    printf '%s' "$temp_path"

    return 0
}

###############################################################################
# Purpose: Generate a pseudo-random alphanumeric string using only Bash
# Input:   1 (optional) An integer indicating the length of the sequence to generate
# Output:  A string containing the generated alphanumeric sequence (stdout)
# Return:  0 (Success)
#          1 (Failure)
# NOTE: Valid input length range 1-32767 (default: 10)
GenerateRandomAlphaNumericString() {

    local list
    local -i length=${1:-10}
    local result='' # NOTE: must be set to NULL
    local character
    local -i i

    list=$(printf '%s' {a..z}{0..9}{A..Z}) || return 1

    # If the length requested is outside sane upper and lower bounds, reset it
    [[ $length -lt 1 ]] && length=1
    [[ $length -gt 32767 ]] && length=32767

    # Loop length times
    for (( i=1; i<=length; i++ )); do

        # Randomly choose one offset of length one from list
        character=${list:$RANDOM%${#list}:1}

        # Randomly invert the case
        (( RANDOM % 2 )) && character=${character~}

        # Concatenate result and character
        result=${result}${character}

    done

    # "Return" the resulting string,
    # meant to be captured using command substitution
    # eg. sSTRING_OF_LENGTH_TEN=$(GenerateRandomAlphaNumericString 10)
    printf '%s' "$result"

    return 0
}

###############################################################################
# Purpose: Attempt to auto-detect the Steam installation path and set the
#          global variable override_default_install_path to it. That variable
#          is then read by ParseConfigFile to set install_path in the config
#          file. If multiple potential install paths are detected the user will
#          be prompted to choose one of them. If none/exit is chosen or an abort
#          occurs install_path will remain set to auto.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: ~/.steam/root/compatibilitytools.d                                   # proton-ge-custom install notes
#       /usr/share/steam/compatibilitytools.d
#       /usr/local/share/steam/compatibilitytools.d
# flatpak
#       ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/  # proton-ge-custom install notes
#       ~/.var/app/com.valvesoftware.Steam/.local/share/Steam
#       ~/.var/app/com.valvesoftware.Steam/.steam
# TODO: Colon-separated global paths in $STEAM_EXTRA_COMPAT_TOOLS_PATHS
#       ~/.steam/root/compatibilitytools.d (steam install folder symlink) || ~/.local/share/Steam/compatibilitytools.d
DetectSteamInstallPath () {

    local -i i=0
    local check_path
    local -a valid_paths
    local -a search_paths=("$HOME/.steam/root" \
                           "${XDG_DATA_HOME:-$HOME/.local/share/Steam}" \
                           "/usr/share/steam" \
                           "/usr/local/share/steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/data/Steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/.local/share/Steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/.steam")

    #sSTEAMSH=$(find / -xdev -type f -name "steam.sh" ! -path "/dev/*" ! -path "/proc/*" 2>/dev/null)
    #sSTEAMCOMPATTOOLSD=$(find / -xdev -type d -name "compatibilitytools.d" ! -path "/dev/*" ! -path "/proc/*" 2>/dev/null)

    # Report the set status of XDG vars
    # XDG_DATA_HOME
    if [[ ${XDG_DATA_HOME-unset} != "unset" ]]; then
        if [[ ${XDG_DATA_HOME-} != "$HOME/.local/share" ]]; then
            ((debug)) && DebugMessage "XDG_DATA_HOME is not set to the default: \"$XDG_DATA_HOME\""
        else
            ((debug)) && DebugMessage "XDG_DATA_HOME is set to: \"$XDG_DATA_HOME\""
        fi
    else
        ((debug)) && DebugMessage "XDG_DATA_HOME is unset"
    fi

    # XDG_CONFIG_HOME
    if [[ ${XDG_CONFIG_HOME-unset} != "unset" ]]; then
        if [[ ${XDG_CONFIG_HOME-} != "$HOME/.config" ]]; then
            ((debug)) && DebugMessage "XDG_CONFIG_HOME is not set to the default: \"$XDG_CONFIG_HOME\""
        else
            ((debug)) && DebugMessage "XDG_CONFIG_HOME is set to: \"$XDG_CONFIG_HOME\""
        fi
    else
        ((debug)) && DebugMessage "XDG_CONFIG_HOME is unset"
    fi

    # XDG_CACHE_HOME
    if [[ ${XDG_CACHE_HOME-unset} != "unset" ]]; then
        if [[ ${XDG_CACHE_HOME-} != "$HOME/.cache" ]]; then
            ((debug)) && DebugMessage "XDG_CACHE_HOME is not set to the default: \"$XDG_CACHE_HOME\""
        else
            ((debug)) && DebugMessage "XDG_CACHE_HOME is set to: \"$XDG_CACHE_HOME\""
        fi
    else
        ((debug)) && DebugMessage "XDG_CACHE_HOME is unset"
    fi

    # Search each known possible, existing Steam install path path for steam.sh
    #
    # ~/.steam/root/compatibilitytools.d
    ((debug)) && DebugMessage "search_paths: ${#search_paths[@]}"
    for check_path in "${search_paths[@]}"; do
        ((debug)) && DebugMessage "Checking \"$check_path\""
        if [[ -f $check_path/steam.sh ]]; then
            ((debug)) && DebugMessage "steam.sh found in $check_path"
            valid_paths+=("$check_path")
        else
            ((debug)) && DebugMessage "steam.sh not found in $check_path"
        fi
    done

    ((debug)) && DebugMessage "#valid_paths: ${#valid_paths[@]}"
    ((debug)) && DebugMessage "valid_paths[*]: ${valid_paths[*]}"

    if [[ ${#valid_paths[@]} -eq 0 ]]; then
        printf '%s\n%s\n%s\n' \
               "ERROR: Unable to detect Steam installation path" \
               "You will need to configure install_path manually in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        override_default_install_path=""

    # Prefer to use the symlink if two paths were found and one is a link to the other
    elif [[ ${#valid_paths[@]} -eq 1 ]] || [[ ${#valid_paths[@]} -eq 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]; then
        printf '%s\n%s\n%s\n' \
               "Steam install path detected as \"${valid_paths[0]}\"" \
               "If that path is incorrect, manually adjust install_path in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        override_default_install_path=${valid_paths[0]}

    # Multiple paths detected with or without the Steam home link pointing to one of them
    elif [[ ${#valid_paths[@]} -gt 1 && ! ${valid_paths[0]} -ef ${valid_paths[1]} ]] || [[ ${#valid_paths[@]} -gt 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]; then
        echo "Multiple Steam install paths detected:"
        for (( i=0; i < ${#valid_paths[@]}; i++ )); do
            echo "($(( i + 1 ))) ${valid_paths[i]}"
        done

        echo "Choose a path from above or type in exit/quit"
        while :; do
            read -rp "Enter a number from 1-${#valid_paths[@]}: " </dev/tty
            [[ $REPLY = @(exit|quit) ]] && {
                override_default_install_path=''
                break
            }
            REPLY=${REPLY//[!0-9]/} # Remove characters that are not {0..9}
            case $REPLY in
                (*[[:digit:]]*)
                    if [[ $REPLY -lt 1 || $REPLY -ge $(( ${#valid_paths[@]} + 1 )) ]]; then
                        echo "Invalid choice"
                    else
                        ((debug)) && DebugMessage "Setting override_default_install_path to \"${valid_paths[$((REPLY-1))]}\""
                        override_default_install_path=${valid_paths[$((REPLY-1))]}
                        printf '%s\n%s\n%s\n' \
                               "You have chosen the path \"$override_default_install_path\"" \
                               "If that is not correct adjust install_path in the configuration file accordingly" \
                               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
                        ((debug)) && DebugMessage "override_default_install_path set to \"$override_default_install_path\""
                        break
                    fi
                ;;
                (*) echo "Invalid choice" ;;
            esac
        done

        [[ -z $override_default_install_path ]] && {
            printf '%s\n%s\n' \
                   "You will need to manually set install_path in the configuration file" \
                   "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
            override_default_install_path="auto"
        }
    fi

    return 0
}

###############################################################################
# Purpose: Ensure critical paths exist and that the script has the required
#          permissions to each of them.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
SetupEnvironment() {

    local -i flag_failed=0

    # install_path
    if [[ -d $install_path ]]; then
        ((debug)) && DebugMessage "Found existing install_path at \"$install_path\""
        if [[ -w $install_path ]]; then
            ((debug)) && DebugMessage "Script has write access to install_path"
        else
            ((debug)) && DebugMessage "Script does not have write access to install_path"
            echo "Invalid install path: \"$install_path\""
            flag_failed=1
        fi
    elif [[ ! -d $install_path ]]; then
        ((debug)) && DebugMessage "install_path not found. Creating at \"$install_path\""
        if mkdir -p -- "$install_path" &>/dev/null; then
            ((debug)) && DebugMessage "Create install path succeeded"
        else
            ((debug)) && DebugMessage "Create install path failed"
            echo "Invalid install path: \"$install_path\""
            flag_failed=1
        fi
    fi

    # script_config_path
    if [[ -d $script_config_path ]]; then
        ((debug)) && DebugMessage "Found existing script_config_path at \"$script_config_path\""
        if [[ -w $script_config_path ]]; then
            ((debug)) && DebugMessage "Script has write access to script_config_path"
        else
            ((debug)) && DebugMessage "Script does not have write access to script_config_path"
            echo "Invalid config path: \"$script_config_path\""
            flag_failed=1
        fi
    elif [[ ! -d $script_config_path ]]; then
        ((debug)) && DebugMessage "script_config_path not found. Creating at \"$script_config_path\""
        if mkdir -p -- "$script_config_path" &>/dev/null; then
            ((debug)) && DebugMessage "Create config path succeeded"
        else
            ((debug)) && DebugMessage "Create config path failed"
            echo "Invalid config path: \"$script_config_path\""
            flag_failed=1
        fi
    fi

    # script_cache_path
    if [[ -d $script_cache_path ]]; then
        ((debug)) && DebugMessage "Found existing script_cache_path at \"$script_cache_path\""
        if [[ -w $script_cache_path ]]; then
            ((debug)) && DebugMessage "Script has write access to script_cache_path"
        else
            ((debug)) && DebugMessage "Script does not have write access to script_cache_path"
            echo "Invalid cache path: \"$script_cache_path\""
            flag_failed=1
        fi
    elif [[ ! -d $script_cache_path ]]; then
        ((debug)) && DebugMessage "script_cache_path not found. Creating at \"$script_cache_path\""
        if mkdir -p -- "$script_cache_path" &>/dev/null; then
            ((debug)) && DebugMessage "Create cache path succeeded"
        else
            ((debug)) && DebugMessage "Create cache path failed"
            echo "Invalid cache path: \"$script_cache_path\""
            flag_failed=1
        fi
    fi

    # file_script_config
    if [[ -f $file_script_config ]]; then
        ((debug)) && DebugMessage "Found existing file_script_config at \"$file_script_config\""
        if [[ -w $file_script_config ]]; then
            ((debug)) && DebugMessage "Script has write access to file_script_config"
        else
            ((debug)) && DebugMessage "Script does not have write access to file_script_config"
            echo "No write access to config file: \"$file_script_config\""
            flag_failed=1
        fi
        if [[ -r $file_script_config ]]; then
            ((debug)) && DebugMessage "Script has read access to file_script_config"
        else
            ((debug)) && DebugMessage "Script does not have read access to file_script_config"
            echo "No read access to config file: \"$file_script_config\""
            flag_failed=1
        fi
    elif [[ ! -f $file_script_config ]]; then
        ((debug)) && DebugMessage "file_script_config not found. Creating at \"$file_script_config\""
        if printf '' > "$file_script_config"; then
            ((debug)) && DebugMessage "Create script config file succeeded"
        else
            ((debug)) && DebugMessage "Create script config file failed"
            echo "Failed to create config file: \"$file_script_config\""
            flag_failed=1
        fi
    fi

    # temp_base_path
    if [[ -d $temp_base_path ]]; then
        ((debug)) && DebugMessage "Found existing temp_base_path at \"$temp_base_path\""
        if [[ -w $temp_base_path ]]; then
            ((debug)) && DebugMessage "Script has write access to temp_base_path"
        else
            ((debug)) && DebugMessage "Script does not have write access to temp_base_path"
            echo "Invalid tmp_path path: \"$temp_base_path\""
            flag_failed=1
        fi
    elif [[ ! -d $temp_base_path ]]; then
        ((debug)) && DebugMessage "temp_base_path not found. Creating at \"$temp_base_path\""
        if mkdir -p -- "$temp_base_path" &>/dev/null; then
            ((debug)) && DebugMessage "Create cache path succeeded"
        else
            ((debug)) && DebugMessage "Create cache path failed"
            echo "Invalid tmp_path path: \"$temp_base_path\""
            flag_failed=1
        fi
    fi

    # Remove 0 size file_latest_json
    [[ -f $file_latest_json ]] && {
        [[ $(stat -c '%s' -- "$file_latest_json" 2>/dev/null) -eq 0 ]] && {
            ((debug)) && DebugMessage "file_latest_json is size 0, removing"
            ($command_rm -- "$file_latest_json")
        }
    }

    # Remove 0 size file_releases_json
    [[ -f $file_releases_json ]] && {
        [[ $(stat -c '%s' -- "$file_releases_json" 2>/dev/null) -eq 0 ]] && {
            ((debug)) && DebugMessage "file_releases_json is size 0, removing"
            ($command_rm -- "$file_releases_json")
        }
    }

    if [[ $flag_failed -eq 0 ]]; then
        ((debug)) && DebugMessage "All tasks succeeded"
        return 0
    elif [[ $flag_failed -eq 1 ]]; then
        ((debug)) && DebugMessage "One or more tasks failed"
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Check for minimum required external commands for basic functionality
#          and report if any are missing.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
CheckRequirements() {

    local -i flag_failed=0
    local -a required_commands=(curl sed tar gzip stat wc)

    while IFS= read -r --; do
        [[ ${REPLY,,} == *is* ]] && { ((debug)) && DebugMessage "$REPLY"; continue; }
        [[ ${REPLY,,} == *"not found"* ]] && {
            REPLY=${REPLY#*:} # remove script_name:
            REPLY=${REPLY#*:} # remove lineno:
            # Remove a leading space if found
            [[ ${REPLY:0:1} = [[:blank:]] ]] && REPLY=${REPLY/#[[:blank:]]}
            echo "Required $REPLY"
            flag_failed=1
        }
    done < <(command -V -- "${required_commands[@]}" 2>&1)

    if [[ $flag_failed -eq 0 ]]; then
        ((debug)) && DebugMessage "All required commands found"
        return 0
    elif [[ $flag_failed -eq 1 ]]; then
        ((debug)) && DebugMessage "One or more required commands not found"
        return 1
    fi
}

###############################################################################
# Purpose: A simple helper function used only for testing. When provided two
#          files show a diff in a particular format on the console.
# Input:   1 (required) File A
#          2 (required) File B
# Output:  None
# Return:  Always 0
ShowConsoleDiff() {

    [[ $# -ne 2 ]] && { echo "It takes two to tango!"; return 1; }

    # iCOLUMNS=$(stty size)
    # iCOLUMNS=${iCOLUMNS##*[[:space:]]}
    if [[ $(shopt checkwinsize) =~ ^checkwinsize[[:blank:]]+off$ ]]; then
        shopt -s checkwinsize
        diff --color -csaW${COLUMNS} "$1" "$2"
        shopt -u checkwinsize
    else
        diff --color -csaW${COLUMNS} "$1" "$2"
    fi

    return 0
}

###############################################################################
# Purpose: Print a supplied message to stderr and prefix that message with the
#          line number that called this function followed by a function trace
#          that excludes "main". Similar to the caller built-in.
# Input:   1 (required) A string (the message to output)
# Output:  None
# Return:  Always 0
DebugMessage() {

    # If debug mode is not active, do nothing
    [[ $debug -eq 1 ]] || return 0
    [[ -z ${1-} ]] && { echo "($LINENO)[DebugMessage]: Parameter error (NULL)" 1>&2; return 1; }

    local -i i

    # Calling line number
    printf '%s' "(${BASH_LINENO[0]})[" 1>&2
    for (( i=$(( ${#FUNCNAME[@]} - 2 )); i>1; i-- )); do
        # Function trace (excluding 'main')
        printf '%s' "${FUNCNAME[i]}," 1>&2
    done
    # The last function in the function trace doesn't get a comma suffix
    printf '%s' "${FUNCNAME[i]}]: " 1>&2
    # Message
    printf '%s\n' "$1" 1>&2

    return 0
}

###############################################################################
# Purpose: Provide a basic diagnostic tool that reports environment information.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>&1; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip ps stat sed cmp sort envsubst printf

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: \"$PWD\""
    echo "SHELL: \"$SHELL\""
    echo "SHELLOPTS: \"$SHELLOPTS\""
    echo "SHLVL: \"$SHLVL\""
    echo "BASH_VERSINFO: \"${BASH_VERSINFO[*]}\""
    echo "BASH_VERSION: \"$BASH_VERSION\""
    echo "MACHTYPE: \"$MACHTYPE\""
    echo "OSTYPE: \"$OSTYPE\""
    echo "PROMPT_COMMAND: \"$PROMPT_COMMAND\""
    echo "LANG: \"$LANG\""
    echo "LC_MESSAGES: \"$LC_MESSAGES\""
    echo "LC_ALL: \"$LC_ALL\""
    echo "EUID: \"$EUID\""
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Purpose: Provide a function to test new features and/or changes independent
#          of the rest of the script.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Exactly -fzT invokes this function
# All hope abandon, ye who enter here!
ProvingGrounds() {

    [[ $integration_testing -eq 1 ]] || return 1

    exit
}

###############################################################################
# Purpose: Remove any temporary files/paths created by the script if debug mode
#          is not enabled
# Input:   None
# Output:  None
# Return:  Always 0
CleanUp() {

    local node

    # If SIGINT was caught, attempt to prevent the cleanup from being interupted
    [[ $flag_sigint_caught -eq 1 ]] && trap '' ABRT CHLD FPE INT QUIT TERM TSTP USR1 USR2 TRAP CONT HUP

    for node in "$temp_base_path/$TEMP_PREFIX"*; do
        # Paths
        [[ -d $node ]] && {
            ((debug)) && DebugMessage "Temporary path found at \"$node\""
            if [[ $debug -eq 1 ]]; then
                DebugMessage "Debug enabled. Temporary path not removed."
            else
                if rm -fr -- "$node" &>/dev/null; then
                    DebugMessage "Temporary path removed"
                else
                    echo "($LINENO) CleanUp: Failed to remove temporary path: \"$node\""
                fi
            fi
        }

        # Files
        [[ -f $node ]] && {
            ((debug)) && DebugMessage "Temp file found at \"$node\""
            if [[ $debug -eq 1 ]]; then
                DebugMessage "Debug enabled. Temporary file not removed."
            else
                if rm -f -- "$node" &>/dev/null; then
                    DebugMessage "Temporary file removed"
                else
                    echo "($LINENO) CleanUp: Failed to remove temporary file: \"$node\""
                fi
            fi
        }
    done

    # Handle the received SIGINT properly by terminating the script/process group with SIGINT
    [[ $flag_sigint_caught -eq 1 ]] && {
        # If the kill fails
        if ! kill -s SIGINT $$; then
            # Try the external command
            if ! $(which --skip-alias --skip-functions -- kill) -2 0; then
                kill -2 0
            fi
        fi
    }

    return 0
}

###############################################################################
# Purpose: Parse command line parameters using getopts and set global variables
#          according to what was requested.
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  getopts exist status (man getopts):
#          0  (An option, specified or unspecified by optstring, was found.)
#          >0 (The end of options was encountered or an error occurred.)
ParseParameters() {
    OPTERR=1 # make sure it's on
    while getopts 'zZThHflSs:i:d:R:r:NuUXv:V' sOPT; do
        case "$sOPT" in
            (h) show_help=1 ;;
            (H) show_usage=1 ;;
            (f) force=1 ;;
            (z) debug=1 ;;
            (T) if [[ $force -eq 1 ]] && [[ $debug -eq 1 ]]; then
                    integration_testing=1
                    ProvingGrounds
                fi
            ;;
            (Z)
                if [[ $force -eq 1 ]] && [[ $debug -eq 1 ]]; then
                    (ReportEnvironmentInfo)
                fi
            ;;
            (u) check_update=1 ;;
            (X) remove_install_path=1 ;;
            (N) remove_all_saved_packages=1 ;;
            (R)
                remove_installed_version=1
                remove_installed_version=$OPTARG
            ;;
            (r)
                remove_saved_package=1
                remove_saved_version=$OPTARG
            ;;
            (l) list_installed_versions=1 ;;
            (s)
                report_version_usage=1
                report_version=$OPTARG
            ;;
            (S) report_install_path_usage=1 ;;
            (d)
                download=1
                download_version=$OPTARG
            ;;
            (i)
                install=1
                install_version=$OPTARG
            ;;
            (U) update=1 ;;
            (V) verify=1 ;;
            (v)
                verify=1
                verify_version=$OPTARG
            ;;
            (":"|"?") return 1 ;;
        esac
    done
}

###############################################################################
# Purpose: Supervise and control the flow of the script depending on how it was invoked
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  0 (Success)
#          1 (An error occured)
Main() {

    # Parse script parameters and arguments, set global variables
    ParseParameters "$@" || exit 1

    # Report if debug mode is enabled
    ((debug)) && DebugMessage "Debug mode enabled"

    # If no parameters were supplied, show help
    # NOTE: Ignore force and debug flags
    if [[ $remove_install_path -eq 0 ]] && \
       [[ $remove_all_saved_packages -eq 0 ]] && \
       [[ $remove_installed_version -eq 0 ]] && \
       [[ $remove_saved_package -eq 0 ]] && \
       [[ $list_installed_versions -eq 0 ]] && \
       [[ $report_version_usage -eq 0 ]] && \
       [[ $report_install_path_usage -eq 0 ]] && \
       [[ $download -eq 0 ]] && \
       [[ $install -eq 0 ]] && \
       [[ $check_update -eq 0 ]] && \
       [[ $verify -eq 0 ]] && \
       [[ $show_help -eq 0 ]] && \
       [[ $show_usage -eq 0 ]] && \
       [[ $update -eq 0 ]]; then

        [[ $debug -eq 1 ]] && {
            if (IsSteamRunning); then
                DebugMessage "Steam is running"
            else
                DebugMessage "Steam is not running"
            fi
            DebugMessage "Nothing to do, showing help"
        }

        # Report latest version installed status
        #if GetLatestGEVersion; then
        #    if IsInstalled "$latest_version"; then
        #        echo "The latest version \"$latest_version\" is installed"
        #    else
        #        echo "The latest version \"$latest_version\" is not installed"
        #    fi
        #else
        #    echo "An error occured while checking for the latest release"
        #fi
        (ShowHelp)
        exit 0
    fi

    # show help and/or usage
    if [[ $show_help -eq 1 ]] && [[ $show_usage -eq 0 ]]; then
        (ShowHelp)
        exit 0
    elif [[ $show_help -eq 1 ]] && [[ $show_usage -eq 1 ]]; then
        (ShowHelp)
        (ShowUsage)
        exit 0
    elif [[ $show_help -eq 0 ]] && [[ $show_usage -eq 1 ]]; then
        (ShowUsage)
        exit 0
    fi

    if InitializeGlobalVars; then
        if (CheckRequirements); then
            if ParseConfigFile; then
                if (! SetupEnvironment); then
                    exit 1
                fi
            else
                exit 1
            fi
        else
            exit 1
        fi
    else
        exit 1
    fi

    (CreateSedUnminifyJSONscript)

    # checkupdate
    if [[ $check_update -eq 1 && $update -eq 0 ]]; then
        if GetLatestGEVersion; then
            if (IsInstalled "$latest_version"); then
                echo "The latest version \"$latest_version\" is installed"
            else
                echo "The latest version \"$latest_version\" is not installed"
            fi
        fi
    fi

    # remove install path
    if [[ $remove_install_path -eq 1 ]] && [[ $force -eq 1 ]]; then
        if (IsSteamRunning); then
            echo "Please close Steam before removing the install path"
        else
            (RemoveGEInstallPath)
        fi
    elif [[ $remove_install_path -eq 1 ]] && [[ $force -eq 0 ]]; then
        echo "-X must be combined with -f to confirm that you are sure"
    fi

    # remove saved packages
    if [[ $remove_all_saved_packages -eq 1 ]] && [[ $remove_install_path -eq 0 ]]; then
        (RemoveAllSavedPackages) # TODO: -f required?
    fi

    # Remove an installed version
    if [[ $remove_installed_version -eq 1 ]] && [[ $remove_install_path -eq 0 ]] && [[ $remove_all_saved_packages -eq 0 ]]; then
        (RemoveGEVersion "$remove_installed_version") # NOTE: sREMOVE_VERSION is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif [[ $remove_installed_version -eq 1 ]] && [[ $remove_install_path -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Remove a saved package
    if [[ $remove_saved_package -eq 1 ]] && [[ $remove_install_path -eq 0 ]] && [[ $remove_all_saved_packages -eq 0 ]]; then
        (RemoveSavedPackage "$remove_saved_version") # NOTE: sREMOVE_VERSION is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif [[ $remove_saved_package -eq 1 ]] && [[ $remove_install_path -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Download a package
    [[ $download -eq 1 ]] && {
        if (! DownloadGEPackage "$download_version"); then # NOTE: download_version is set in getops
            echo "Download failed"
        fi
    }

    # Check for new version and if it is not installed install it
    if [[ $update -eq 1 ]]; then
        if (UpdateSavedGELatestRelease); then
            if GetLatestGEVersion; then # set global variable latest_version
                if (IsInstalled "$latest_version") && [[ $force -eq 1 ]]; then # Latest version is installed and -f is supplied
                    if (RemoveGEVersion "$latest_version"); then
                        # TODO: Replace InstallGEVersion with UpdateGEVersion
                        if (InstallGEVersion); then # InstallGEVersion checks $update then $install_version and/or $latest_version
                            echo "Update succeeded"
                        else
                            echo "Update failed"
                        fi
                    fi
                elif (IsInstalled "$latest_version") && [[ $force -eq 0 ]]; then # Latest version is installed and -f was not supplied
                    echo "Latest version is already installed ($latest_version)"
                elif (! IsInstalled "$latest_version"); then # Latest version is not installed
                    echo "Latest version is not installed"
                    if (InstallGEVersion); then
                        echo "Update succeeded"
                        if (IsSteamRunning); then
                            echo "Restart Steam to use the new version"
                        fi
                    else
                        echo "Update failed"
                    fi
                fi
            else
                ((debug)) && DebugMessage "Update: GetLatestGEVersion returned failure status"
            fi
        else
            # GetLatestGEVersionInfo failed
            ((debug)) && DebugMessage "Update: GetLatestGEVersionInfo returned failure status"
            echo "Update failed"
        fi
        # Like purchasing a tribble, this is probably a bad idea
        [[ $install -eq 1 ]] && update=0 # Reset update to 0 so update and install can run in the same invocation
    fi

    # Install a package
    if [[ $install -eq 1 ]] && [[ $update -eq 0 ]]; then
        (InstallGEVersion "$install_version") # NOTE: install_version is set in getops
    fi

    # List installed versions
    [[ $list_installed_versions -eq 1 ]] && (ListInstalledGEVersions)

    # Report entire install path disk usage and file count
    [[ $report_install_path_usage -eq 1 ]] && (ReportGEDiskUsage)

    # Report disk usage and file count for a specific version
    [[ $report_version_usage -eq 1 ]] && (ReportGEDiskUsage "$report_version")

    # Run verify if remove install path and remove saved packages wasn't requested
    # TODO: add support to verify even if remove saved packages and/or remove install path was invoked
    #       so long as some sort of install was also requested. Additionally, maybe support installing a version
    #       that is not installed when verify is called and force mode is active.
    if [[ $verify -eq 1 ]] && [[ $remove_install_path -ne 1 && $remove_all_saved_packages -ne 1 ]]; then
        (VerifyGEInstall "${verify_version-}")
    fi

    return 0
}

###############################################################################
# Purpose: Run the function CleanUp on SIGEXIT
#          Save the exit status of the last executed command before invoking
#          the CleanUp function. Report both the saved exit status and the exit
#          status of CleanUp if debug mode is enabled.
trap 'real_exit_status=$?; ((debug)) && DebugMessage "Exit status (before CleanUp): $real_exit_status"; CleanUp; ((debug)) && DebugMessage "Exit status (after CleanUp): $?"; exit $real_exit_status' EXIT

###############################################################################
# Purpose: Run the function CleanUp if the process group received SIGINT
#          This needs to be a seperate trap to properly handle SIGINT.
trap 'flag_sigint_caught=1; CleanUp' INT

###############################################################################
# Wait...the end is just a new beginning? Always has been.

Main "$@"
