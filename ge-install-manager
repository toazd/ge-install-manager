#!/usr/bin/env bash
# vim: set ft=shell nowrap expandtab shiftwidth=4 tabstop=4 smarttab softtabstop=0
#
# repo:bash-misc/script-sloc ge-install-manager:
# 2615/3776 SLOC (69%) [SLOC/Comment:3.30], 793 comments (21%) [S:95%,I:4%] [Comment/SLOC:0.30], 402 empty (10%)
################################################################################
#                                                                              #
#      Toazd 2020 Unlicense https://unlicense.org/                             #
#                                                                              #
#      GloriousEggroll proton-ge-custom installation manager                   #
#      Easily manage proton-ge-custom installations                            #
#        https://github.com/GloriousEggroll/proton-ge-custom                   #
#                                                                              #
################################################################################
#                                                                              #
# "A common mistake that people make when trying to design something           #
# completely foolproof is to underestimate the ingenuity of complete fools."   #
#                                                                              #
#                   ~Douglas Adams, The Hitchhiker's Guide to the Galaxy       #
#                                                                              #
################################################################################

# -e  Exit immediately if a command exits with a non-zero status.
set +e # WARNING: DO NOT set -e

# -h Remember the location of commands as they are looked up. Default is on.
# -u Treat unset variables as an error when substituting. Default is off.
# -o pipefail The return value of a pipeline is the status of the last command
#             to exit with a non-zero status, or zero if no command exited with
#             a non-zero status. Default is off.
set -huo pipefail

################################################################################
# "Things that would be nice, but aren't required for main features" list
#   -Install function (currently automatic if any main function is used)
#   -Replace getopts with a custom parser
#   -support for using jq in addition to sed
################################################################################

# Initialize global variables
# NOTE: Script constants (read only variables) are all upper-case
declare -gr SCRIPT_VERSION=0.7.9
declare -gr SCRIPT_FULL_NAME=${0##*/}
declare -gr SCRIPT_CODENAME="Cochrane Bonaventure" # The Bonaventure (10281NCC), according to Montgomery Scott, "was the first ship to have warp drive installed."
declare -gr PROJECT_URL="https://github.com/toazd/ge-install-manager" # CheckForScriptUpdate
declare -gr CHECK_LATEST=0
declare -gr CURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
declare -gr CURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
declare -gr CURL_HEADER_USER_AGENT="User-Agent: toazd/$SCRIPT_FULL_NAME/$SCRIPT_VERSION"
declare -gr TEMP_PREFIX=${SCRIPT_FULL_NAME}.tmp.
# NOTE: Script global variables are all prefixed with g_
declare -g g_command_rm # Configuration file: rm_command
declare -g g_download_version=""
declare -g g_file_latest_json=""
declare -g g_file_releases_json=""
declare -g g_script_raw_url="https://raw.githubusercontent.com/toazd/ge-install-manager/master/ge-install-manager"
declare -g g_file_script_raw=""
declare -g g_script_config_path=${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME
declare -g g_file_script_config=$g_script_config_path/$SCRIPT_FULL_NAME.conf
declare -g g_file_sed_unminify_script=$g_script_config_path/unminify-JSON.sed
declare -g g_install_path="" # Configuration file: install_path
declare -g g_install_version=""
declare -g g_latest_version=""
declare -g g_latest_version_url="" # Configuration file: latest_version_url
declare -g g_override_default_install_path=""
declare -g g_releases_url="" # Configuration file: releases_url
declare -g g_remove_version=""
declare -g g_remove_saved_version=""
declare -g g_report_version=""
declare -g g_script_cache_path="" # Configuration file: cache_path
declare -g g_temp_base_path=/tmp # Configuration file: temp_path
declare -g g_verify_version=""
declare -g g_show_release_notes_version=""
declare -gi g_check_update=0
declare -gi g_verbose=0
declare -gi g_download=0
declare -gi g_flag_sigint_caught=0
declare -gi g_force=0
declare -gi g_install=0
declare -gi g_integration_testing=0
declare -gi g_list_installed_versions=0
declare -gi g_real_exit_status=0
declare -gi g_remove_all_saved_packages=0
declare -gi g_remove_installed_version=0
declare -gi g_remove_install_path=0
declare -gi g_remove_saved_package=0
declare -gi g_report_install_path_usage=0
declare -gi g_report_version_usage=0
declare -gi g_show_help=0
declare -gi g_show_usage=0
declare -gi g_size_bytes_sed_unminify_script=146
declare -gi g_update=0
declare -gi g_verify=0
declare -gi g_releases_update_interval=3600 # (seconds) 60 minutes
declare -gi g_script_update_interval=43200 # (seconds) 12 hours
declare -gi g_list_available_versions=0
declare -gi g_show_release_notes=0
declare -gi g_show_all_release_notes=0
declare -gi g_uninstall_script=0
declare -gi g_script_update_check=0
declare -gi g_automated_mode=0

# Bash escape sequences
# https://www.shellcheck.net/wiki/SC2034
# shellcheck disable=SC2034
{
declare -g g_color_red="\033[1;31m"
declare -g g_color_green="\033[1;32m"
declare -g g_color_yellow="\033[1;33m"
declare -g g_color_blue="\033[1;34m"
declare -g g_color_magenta="\033[1;35m"
declare -g g_color_cyan="\033[1;36m"
declare -g g_color_white="\033[1;37m"
declare -g g_color_reset="\033[m"
}

################################################################################
# Purpose: Print the help text to stderr
# Input:   None
# Output:  None
# Return:  Always 0
ShowHelp() {

    cat <<HELP_HEREDOC 1>&2

    $SCRIPT_FULL_NAME  v$SCRIPT_VERSION "$SCRIPT_CODENAME"

    Configuration file: $g_script_config_path/$SCRIPT_FULL_NAME.conf

    Required:       Bash 3.2+, curl, sed, tar, gzip, stat, wc, touch, file
    Optional:       date, du, pgrep, sort, cmp, envsubst, trash

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
                      Saved package sizes are also checked (backports)
    -L            - List all releases available to install
    -n <version>  - Show release notes for <version>
                      Combined with -N, -n will be ignored
    -N            - Show release notes for all versions
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
    -r <version>  - Remove saved package <version> (proton-ge tarball)
    -V            - Verify each installation using its saved package
                      Combined with -v, -V will be ignored
    -v <version>  - Verify <version> using its saved package
    -d <version>  - Download and save the package for <version>
    -D            - Remove cache and config files created by this script
                      To also remove all proton-ge-custom installations, use -XD.
    -x            - Remove all saved packages (proton-ge tarballs)
    -X            - Remove the entire install path
                      NOTE: Saved packages are currently stored in the installation path
    -f            - Force install, upgrade, or remove
                      Combined with -U and/or -i, remove saved package and download a new copy
    -A            - Automated mode (skip/disable certain prompts)
                      Skips prompting to edit a newly created config file
                      Skips prompt for creating a symlink to the script
    -z            - Enable verbose output mode (to stderr)
                      Format: (calling line)[function trace]: message

HELP_HEREDOC

    return 0
}

################################################################################
# Purpose: Print the usage text to stderr
# Input:  None
# Output: None
# Return: Always 0
ShowUsage() {

     cat <<USAGE_HEREDOC 1>&2
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$SCRIPT_FULL_NAME -Hh
        ./$SCRIPT_FULL_NAME -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$SCRIPT_FULL_NAME -lSui 5.9-GE-3-ST
        ./$SCRIPT_FULL_NAME -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$SCRIPT_FULL_NAME -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable verbose mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$SCRIPT_FULL_NAME -s 5.6-GE-3-ST -S
        ./$SCRIPT_FULL_NAME -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$SCRIPT_FULL_NAME -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./ge-install-manager -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter and argument will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ/-fzT will exit irrespective of other parameters
      Show help,
      Show usage,
      Check for latest release,
      Show all releases available,
      Show release notes for all versions,
      Show release notes for a version,
      Remove install path,
      Remove saved packages (if remove install path is not active),
      Uninstall script (remove g_script_cache_path g_script_config_path),
      Remove installed version (if remove install path is not active),
      Remove saved package (if remove install path is not active),
      Download,
      Update,
      Install,
      List installed,
      Report install path disk usage,
      Report specific version disk usage
      Verify

USAGE_HEREDOC

    return 0
}

################################################################################
# Purpose: Check the access time of a specified file and determine whether the
#          specified interval has elapsed.
# Input:   1 (required) File to check
#          2 (required) Interval in seconds
# Output:  None
# Return:  0 (The specified interval has elapsed since the last access, or an error occured)
#          1 (The specified interval has not elapsed since the last access)
CheckAccessTime() {

    local -i current_seconds=0 last_check_seconds=0 interval=${2:-0}
    local file=${1-}

    # If the file doesn't exist, return success (it needs to be created)
    [[ ! -f $file ]] && return 0

    [[ -z $file || ! -r $file || $interval -lt 1 ]] && { ((g_verbose)) && vMsg "Parameter error (file: $file interval: $interval" r; exit 1; }

    ((g_verbose)) && vMsg "Checking $file (interval: $interval)"

    # Using the access time of file, determine if the specified interval has elapsed or not
    current_seconds=$(date +%s)
    last_check_seconds=$(stat -c '%X' -- "$file") # --cached=never not available on Ubuntu 20.04.1 LTS
    if (( (current_seconds - last_check_seconds) <= interval ))
    then
        ((g_verbose)) && vMsg "Access denied. $(( interval - (current_seconds - last_check_seconds) )) seconds remaining." y
        return 1
    else
        ((g_verbose)) && vMsg "Access granted. Access was restored $(( (current_seconds - last_check_seconds) - interval )) seconds ago." g
        return 0
    fi

    return 0
}

################################################################################
# Purpose: Compare and report if the size of the remote version of this script
#          does not match the size of the local version of this script.
# Input:   None
# Output:  None
# Return:  0 (local and remote sizes are equal) Update not available
#          1 (local and remote sizes do not match) Update available
CheckForScriptUpdate() {

    local -i local_script_size_bytes=0 remote_script_size_bytes=0

    (( g_script_update_check )) || return 0

    ((g_verbose)) && vMsg "Checking $g_file_script_raw"
    if CheckAccessTime "$g_file_script_raw" "$g_script_update_interval"
    then
        if [[ -f $g_file_script_raw ]]
        then
            CreateBackup "$g_file_script_raw"
            ($g_command_rm -- "$g_file_script_raw")
        fi
        if ! RequestURL "$g_script_raw_url" "$g_file_script_raw"
        then
            ((g_verbose)) && vMsg "RequestURL returned failure" r
            [[ -f $g_file_script_raw ]] && ($g_command_rm -- "$g_file_script_raw")
            return 0
        fi
    else
        ((g_verbose)) && vMsg "CheckAccessTime returned failure" y
    fi

    # If RequestURL failed, skip the checks
    [[ ! -f $g_file_script_raw ]] && return 0

    local_script_size_bytes=$(stat -c '%s' "$(realpath "$0" 2> /dev/null)" 2> /dev/null)
    remote_script_size_bytes=$(stat -c '%s' "$(realpath "$g_file_script_raw" 2> /dev/null)" 2> /dev/null)

    if ((g_verbose))
    then
        vMsg "Local script size bytes : $local_script_size_bytes"
        vMsg "Remote script size bytes: $remote_script_size_bytes"
    fi

    return $(( (local_script_size_bytes != remote_script_size_bytes) ? 1 : 0 ))
}

################################################################################
# Purpose: Check for minimum required external commands for basic functionality
#          and report if any are missing.
# Input:   None
# Output:  None
# Return:  0 (Success) All required commands were found
#          1 (Failure) Any one required command was not found
# TODO Add checks for optional commands and report features that won't work if
#      any are not found.
CheckRequirements() {

    local cur_cmd=''
    local -i flag_failed=0 flag_apt=0 flag_pacman=0 flag_dnf=0
    local -a required_commands=(curl sed tar gzip stat wc touch file)

    # Detect package managers for basic missing command advice
    command -v pacman > /dev/null && { ((g_verbose)) && vMsg "pacman found" g; flag_pacman=1; }
    command -v apt > /dev/null && { ((g_verbose)) && vMsg "apt found" g; flag_apt=1; }
    command -v dnf > /dev/null && { ((g_verbose)) && vMsg "dnf found" g; flag_dnf=1; }

    while IFS= read -r --
    do
        # Report the command path if it is found
        if [[ ${REPLY,,} == *'is'* ]]
        then
            ((g_verbose)) && vMsg "$REPLY" y
            continue
        fi

        # Report if a command is not found
        if [[ ${REPLY,,} == *'not found'* ]]
        then
            REPLY=${REPLY#*:} # remove script_name:
            REPLY=${REPLY#*:} # remove lineno:
            # Remove a leading space if found
            [[ ${REPLY:0:1} = [[:space:]] ]] && REPLY=${REPLY/#[[:space:]]}

            # Remove all but the current command
            cur_cmd=${REPLY#*": "}
            cur_cmd=${cur_cmd%": "*}

            # Give basic install advice depending on which package manager is found
            if (( flag_apt == 1 && flag_pacman == 0 && flag_dnf == 0 ))
            then
                echo "Required $REPLY (sudo apt install $cur_cmd -y)"
            elif (( flag_apt == 0 && flag_pacman == 0 && flag_dnf == 1 ))
            then
                echo "Required $REPLY (sudo dnf install $cur_cmd -y)"
            elif (( flag_apt == 0 && flag_pacman == 1 && flag_dnf == 0  ))
            then
                echo "Required $REPLY (sudo pacman -Syu $cur_cmd)"
            else
                echo "Required $REPLY"
            fi
            flag_failed=1
        fi
    done < <(command -V -- "${required_commands[@]}" 2>&1)

    if ((g_verbose))
    then
        if ((flag_failed))
        then
            vMsg "One or more requirements not met" r
        else
            vMsg "All requirements satisfied" g
        fi
    fi

    return $(( flag_failed ? 1 : 0 ))
}

################################################################################
# Purpose: Remove any temporary files/paths created by the script
# Input:   None
# Output:  None
# Return:  0 (Always) Unless SIGINT was caught (then it's value is carried over)
#                     which defaults to 0 on my system (varies by environment).
CleanUp() {

    local node

    # If SIGINT was caught, attempt to prevent the cleanup from being interupted
    ((g_flag_sigint_caught)) && trap '' ABRT CHLD FPE INT QUIT TERM TSTP USR1 USR2 TRAP CONT HUP

    if [[ $g_verbose -eq 0 ]]
    then
        for node in "$g_temp_base_path/$TEMP_PREFIX"*
        do
            # Paths
            if [[ -d $node ]]
            then
                if rm -fr -- "$node" > /dev/null
                then
                    ((g_verbose)) && vMsg "Removed temporary path: $node" g
                else
                    vMsg "Failed to remove temporary path: $node" r
                fi
            fi

            # Files
            if [[ -f $node ]]
            then
                if rm -f -- "$node" > /dev/null
                then
                    ((g_verbose)) && vMsg "Removed temporary file: $node" g
                else
                    vMsg "Failed to remove temporary file: $node" r
                fi
            fi
        done
    fi

    # Handle the received SIGINT properly by terminating the script/process group with SIGINT
    if ((g_flag_sigint_caught))
    then
        kill -s SIGINT $$ || kill -2 0
    fi

    return 0
}

################################################################################
# Purpose: When invoked, "clean" a version string stored in the variable version.
# Input:   None
# Output:  None
# Return:  0 (Success) Always
# NOTE: This function takes advantage of Bash's dynamic scoping
CleanUpVersion() {

    # $version must be set in the calling function
    [[ -z $version ]] && { ((g_verbose)) && vMsg "version is NULL" r; printf ''; return 1; }

    ((g_verbose)) && vMsg "Before: \"$version\""

    # global remove spaces/tabs
    version=${version//[[:space:]]}

    # global upper case
    version=${version^^}

    # anchored left, remove a single "PROTON-" and anything to the left of it
    version=${version//'PROTON-'}

    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    version=${version//'.TAR.GZ'*}

    # Remove any :
    version=${version//':'}

    # Fix for Proton-5.0-GE-1-no-mouse-coord
    version=${version//'-NO-MOUSE-COORD'/'-no-mouse-coord'}
    [[ $version = '5.0-GE-1' ]] && version='5.0-GE-1-no-mouse-coord'

    ((g_verbose)) && vMsg "After: \"$version\""

    return 0
}

################################################################################
# Purpose: Backup a file/path in tar.gz format supporting upto a configurable
#          number (n) of backups with a basename (sans extension) suffix of _n.
#          The newest backup is the lowest index (n) and the oldest backup is
#          the highest index (n). The backups are stored in the parent path of
#          the file/path to be backed up.
# Input:   1 (required) The file or path to backup
# Output:  None
# Return:  0 Success
#          1 Failure
CreateBackup() {

    local backup_target=${1-} backup_target_basename backup_target_path backup_index file
    local -i max_backups=3 backups_counter=0 flag_rename_backups=0
    local -a files_existing_backups

    shopt -s nullglob dotglob

    [[ -z $backup_target ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    ((g_verbose)) && vMsg "Backup requested for $backup_target"

    # Check that backup_target is either an existing file or an existing path
    if [[ ! -f $backup_target ]]
    then
        ##((g_verbose)) && vMsg "backup_target is not a file"
        if [[ ! -d $backup_target ]]
        then
            ((g_verbose)) && vMsg "Parameter error (not a file or a path)" r
            return 1
        fi
    fi

    # If a relative file/path was given
    if [[ ${backup_target:0:1} != "/" || ${backup_target:0:2} == "./" ]]
    then
        ##((g_verbose)) && vMsg "Resolving relative path"
        backup_target=$(realpath -- "$backup_target" 2> /dev/null)
    fi

    # If backup_target is a file, get the path to it
    if [[ ! -d $backup_target && -f $backup_target ]]
    then
        backup_target_path=${backup_target%/*}
    else
        # If its a path, get the parent path of backup_target
        backup_target_path=$(realpath -- "$(dirname -- "$backup_target" 2> /dev/null)" 2> /dev/null)
    fi

    backup_target_basename=${backup_target##*/}

    # Determine the basename suffix to use {1..$max_backups}
    for file in "$backup_target_path/$backup_target_basename"_?.tar.gz
    do
        if [[ $file =~ ^.*[^_]_[[:digit:]]{1}\.tar\.gz$ ]]
        then
            backup_index=${file##*_}
            backup_index=${backup_index/%.tar.gz}
            ((g_verbose)) && vMsg "backup_index is $backup_index"
            if [[ $backup_index =~ ^[[:digit:]]+$ ]]
            then
                ((backups_counter++))
                files_existing_backups+=("$file")
                ##((g_verbose)) && vMsg "Valid backup file found at $file" g
                if ((backup_index == 1))
                then
                    ##((g_verbose)) && vMsg "Index 1 found, existing backups will be renamed" y
                    flag_rename_backups=1
                fi
            fi
        fi
    done
    ##((g_verbose)) && vMsg "Found $backups_counter backups"

    if ((flag_rename_backups))
    then
        backup_index=$backups_counter
        if ((backup_index >= max_backups))
        then
            # Remove the oldest (highest index) backup until max_backups is reached
            while ((backup_index >= max_backups))
            do
                if ($g_command_rm -- "${files_existing_backups[backup_index-1]}")
                then
                    ##((g_verbose)) && vMsg "Removed highest index greater than $max_backups: ${files_existing_backups[backup_index-1]}"
                    backup_index=$((backup_index - 1))
                else
                    vMsg "Failed to remove backup file ${files_existing_backups[backup_index-1]}" r
                    return 1
                fi
            done
        fi

        # Rename existing backups, leaving room for a new index 1 (increment each existing index by +1)
        for ((backup_index; backup_index>=1; backup_index--))
        do
            if ! mv -- "${files_existing_backups[backup_index-1]}" "${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"; then
                vMsg "Failed to rename backup file: ${files_existing_backups[backup_index-1]}" r
                return 1
            fi
        done
    fi

    if tar -C "$backup_target_path" -cf "$backup_target_path/${backup_target_basename}_1.tar.gz" -z "$backup_target_basename"
    then
        ((g_verbose)) && vMsg "Created new backup at $backup_target_path/${backup_target_basename}_1.tar.gz" g
        return 0
    else
        ((g_verbose)) && vMsg "Backup failed: $backup_target_path/${backup_target_basename}_1.tar.gz" r
        return 1
    fi

    return 0
}

################################################################################
# Purpose: If g_file_script_config is not found, create a default
# Input:   None
# Output:  None
# Return:  0 Success
#          1 (Failure) mkdir returned failure status.
CreateDefaultConfigFile() {

    local rm_command path

    # If the config path doesn't exist, create it
    path=$(dirname "$g_file_script_config")
    if [[ ! -d $path ]]
    then
        if ! mkdir -p -- "$path"
        then
            vMsg "Failed to create config file path at $path" r
            return 1
        fi
    fi

    cat <<DEFAULT_CONFIG > "$g_file_script_config" # This section is subject to expansion
#
# ${SCRIPT_FULL_NAME} v${SCRIPT_VERSION} Default configuration file
#
# Quick start format:
# #comment
# key=value #comment
#
# Lines begining with an octothorpe "#" are considered comment lines and are ignored.
# Any characters that follow a space and an octothorpe " #" are considered comments.
# Empty lines and lines that begin with space/tab are ignored.
# Lines that contain one or more semi-colon(s) ";" will be ignored.
# Lines that contain potential escape sequences are ignored.
# A key with a null value and a value with a null key are ignored (eg. "key=" and "=value").
#
# Paths (install, cache, and tmp) do not have to exist but
# the script will need write permission to create them for you.
#
# When install_path is set to the special value "auto", the script will
# attempt to auto-detect the Steam installation path.
#
# Environment variables and script global variables will be expanded.
# \$SCRIPT_FULL_NAME is a script global variable that is always set to the basename of the script.
# Setting tmp_path to the same path as install_path is currently not supported (eg. tmp_path=\$g_install_path).
#
# Do not quote variables outside parameter expansions (:+, :-, :=, or :?) unless
# you want the quotes included in the value.
#
DEFAULT_CONFIG

    cat <<"DEFAULT_CONFIG" >> "$g_file_script_config" # This section is not subject to expansion

# Default install path
install_path=auto

# Default cache path
cache_path=${XDG_CACHE_HOME:-$HOME/.cache}/$SCRIPT_FULL_NAME

# Default URL used to retrieve 'latest' JSON
latest_version_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest

# Default URL used to retrieve 'releases' JSON
releases_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases

# Default temporary file path
tmp_path=/tmp

DEFAULT_CONFIG

    # If trash is found (trash-cli), use it instead of rm
    if command -v trash > /dev/null
    then
        rm_command='trash'
    else
        rm_command='rm'
    fi

    cat <<DEFAULT_CONFIG >> "$g_file_script_config" # This section is subject to variable expansion
# Default command used instead of rm (for removing all but temporary files)
# NOTE: Any command and its parameters that support the last parameter being either a file or a path is supported
rm_command=$rm_command
DEFAULT_CONFIG

    return 0
}

################################################################################
# Purpose: If the sed script g_file_sed_unminify_script is not found or it's size
#          in bytes does not match an expected value, create/overwrite it
# Input:   None
# Output:  None
# Return:  0 (Success) sed script was created successfully or already exists
#          1 (Failure) Failed to create the sed script at g_file_sed_unminify_script
CreateSedUnminifyJSONscript() {

    if [[ ! -f $g_file_sed_unminify_script ]] || (($(stat -c '%s' -- "$g_file_sed_unminify_script") != g_size_bytes_sed_unminify_script))
    then
        cat <<"END_OF_SED_SCRIPT" > "$g_file_sed_unminify_script"
## begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s|","|"\n"|g
## end minimum required for ge-install-manager
END_OF_SED_SCRIPT

        # Report that the file was created successfuly and whether or not it is the correct size
        if [[ -f $g_file_sed_unminify_script ]]
        then
            if (($(stat -c '%s' -- "$g_file_sed_unminify_script") == g_size_bytes_sed_unminify_script))
            then
                ((g_verbose)) && vMsg "sed script created at $g_file_sed_unminify_script" g
            else
                ((g_verbose)) && vMsg "sed script at $g_file_sed_unminify_script wrong size" r
                ($g_command_rm -- "$g_file_sed_unminify_script")
            fi
        else
            vMsg "Failed to create sed script at $g_file_sed_unminify_script" r
            return 1
        fi
    fi

    return 0
}

################################################################################
# Purpose: Attempt to auto-detect the Steam installation path and set the
#          global variable g_override_default_install_path to it. That variable
#          is then read by ParseConfigFile to set g_install_path in the config
#          file. If multiple potential install paths are detected the user will
#          be prompted to choose one of them. If none/exit is chosen or an abort
#          occurs install_path will remain set to auto (which triggers this function
#          being called from ParseConfigFile).
# Input:   None
# Output:  None
# Return:  0 (Success) Always
#
# NOTE: ~/.steam/root/compatibilitytools.d                                   # proton-ge-custom install notes
#       /usr/share/steam/compatibilitytools.d
#       /usr/local/share/steam/compatibilitytools.d
# flatpak
#       ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/  # proton-ge-custom install notes
#       ~/.var/app/com.valvesoftware.Steam/.local/share/Steam
#       ~/.var/app/com.valvesoftware.Steam/.steam
#       ~/.steam/root/compatibilitytools.d (steam install folder symlink) || ~/.local/share/Steam/compatibilitytools.d
# TODO: Colon-separated global paths in $STEAM_EXTRA_COMPAT_TOOLS_PATHS
# BUG: The script needs write access to the installation path (eg. /usr/share/steam) and the script
#      will not run as root.
DetectSteamInstallPath () {

    local check_path
    local -i i=0
    local -a valid_paths=()
    local -a search_paths=("$HOME/.steam/root" \
                           "${XDG_DATA_HOME:-$HOME/.local/share/Steam}" \
                           "/usr/share/steam" \
                           "/usr/local/share/steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/data/Steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/.local/share/Steam" \
                           "$HOME/.var/app/com.valvesoftware.Steam/.steam")

    # Report the set status of XDG vars
    #
    # XDG_DATA_HOME
    ##if [[ ${XDG_DATA_HOME-unset} != 'unset' ]]
    ##then
    ##    ##((g_verbose)) && vMsg "XDG_DATA_HOME: $XDG_DATA_HOME"
    ##else
    ##    ##((g_verbose)) && vMsg "XDG_DATA_HOME is unset" y
    ##fi

    ### XDG_CONFIG_HOME
    ##if [[ ${XDG_CONFIG_HOME-unset} != 'unset' ]]
    ##then
    ##    ##((g_verbose)) && vMsg "XDG_CONFIG_HOME: $XDG_CONFIG_HOME"
    ##else
    ##    ##((g_verbose)) && vMsg "XDG_CONFIG_HOME is unset" y
    ##fi

    ### XDG_CACHE_HOME
    ##if [[ ${XDG_CACHE_HOME-unset} != 'unset' ]]
    ##then
    ##    ##((g_verbose)) && vMsg "XDG_CACHE_HOME: $XDG_CACHE_HOME"
    ##else
    ##    ##((g_verbose)) && vMsg "XDG_CACHE_HOME is unset"
    ##fi

    # Search each known possible Steam install path path for steam.sh
    # NOTE: If steam.sh is found the path containing it is considered valid
    #
    # ~/.steam/root/compatibilitytools.d

    ##((g_verbose)) && vMsg "search_paths: ${#search_paths[@]}"

    for check_path in "${search_paths[@]}"
    do
        ##((g_verbose)) && vMsg "Checking $check_path"
        if [[ -f $check_path/steam.sh ]]
        then
            ((g_verbose)) && vMsg "steam.sh found in $check_path" g
            valid_paths+=("$check_path")
        else
            ((g_verbose)) && vMsg "steam.sh not found in $check_path" y
        fi
    done

    ##((g_verbose)) && vMsg "#valid_paths: ${#valid_paths[@]}"
    ##((g_verbose)) && vMsg "valid_paths[*]: ${valid_paths[*]}"

    if ((${#valid_paths[@]} == 0))
    then
        vMsg "ERROR: Unable to detect Steam installation path" r
        printf '%s\n%s\n' \
               "You will need to configure install_path manually in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        g_override_default_install_path='auto'
        return 1

    # Prefer to use the symlink if two paths were found and one is a link to the other
    elif ((${#valid_paths[@]} == 1)) || [[ ${#valid_paths[@]} -eq 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]
    then
        printf '%s\n' "Steam install path detected as ${valid_paths[0]}"
        g_override_default_install_path=${valid_paths[0]}

    # Multiple paths detected with or without the Steam home link pointing to one of them
    elif [[ ${#valid_paths[@]} -gt 1 && ! ${valid_paths[0]} -ef ${valid_paths[1]} ]] || [[ ${#valid_paths[@]} -gt 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]
    then
        echo "Multiple Steam install paths detected:"
        for (( i=0; i < ${#valid_paths[@]}; i++ ))
        do
            echo "($(( i + 1 ))) ${valid_paths[i]}"
        done

        echo "Choose a path from above or enter exit/quit"
        while ((! ${GEIM_TESTS-0} ))
        do
            read -rp "Enter a number from 1-${#valid_paths[@]}: " </dev/tty
            if [[ $REPLY = @(exit|quit) ]]
            then
                g_override_default_install_path=''
                break
            fi
            REPLY=${REPLY//[!0-9]/} # Remove characters that are not a digit
            case $REPLY in
                (*[[:digit:]]*)
                    if ((REPLY < 1 || REPLY >= $(( ${#valid_paths[@]} + 1 ))))
                    then
                        echo "Invalid choice"
                    else
                        ##((g_verbose)) && vMsg "Setting g_override_default_install_path to ${valid_paths[$((REPLY-1))]}"
                        g_override_default_install_path=${valid_paths[$((REPLY-1))]}
                        printf '%s\n%s\n%s\n' \
                               "You have chosen the path $g_override_default_install_path" \
                               "If that is not correct then change install_path in the configuration file" \
                               "(default: ${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
                        ((g_verbose)) && vMsg "g_override_default_install_path set to $g_override_default_install_path" g
                        break
                    fi
                ;;
                (*)
                    echo "Invalid choice"
                ;;
            esac
        done

        if [[ -z $g_override_default_install_path ]]
        then
            printf '%s\n%s\n' \
                   "You will need to manually set install_path in the configuration file" \
                   "(default: ${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
            g_override_default_install_path="auto"
            ((g_verbose)) && vMsg "g_override_default_install_path set to $g_override_default_install_path" g
        fi
    fi

    return 0
}

################################################################################
# Purpose: Using curl, download a proton-ge-custom release package to a
#          temporary path and if the download size matches the expected size
#          copy it to g_install_path
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = (Success) The package was downloaded and extracted to the install
#                        path successfully.
#          1 = (Failure) QueryGEAttribute returned 1, the downloaded package size
#                        did not match the expected size, there is not enough
#                        free space on g_temp_base_path to download the package,
#                        the server responded "Not Found" or "API limit exceeded",
#                        copying the package from g_temp_base_path to the install
#                        path failed, or curl returned failure.
DownloadGEPackage() {

    local version=${1-} temp_path temp_package package_download_url
    local -i temp_base_path_remaining_bytes=0 install_path_remaining_bytes=0 expected_size_bytes=0 downloaded_package_size_bytes=0

    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    # Get the download URL from the saved latest/releases JSON
    package_download_url=$(QueryGEAttribute "$version" "browser_download_url")

    # If QueryGEAttribute returned success but the URL is NULL, abort
    [[ -z $package_download_url ]] && return 1

    # Get the expected package size in bytes from the saved latest/releases JSON
    expected_size_bytes=$(QueryGEAttribute "$version" "size")

    # If QueryGEAttribute returned success and size is not only one or more digits, abort
    [[ $expected_size_bytes =~ ^[[:digit:]]+$ ]] || return 1

    # If a saved package already exists for the requested version
    if [[ -f $g_install_path/Proton-$version.tar.gz ]]
    then
        if (( $(stat -c '%s' "$g_install_path/Proton-$version.tar.gz") == expected_size_bytes )) && ((! g_force))
        then
            echo "A saved package for Proton-$version already exists and it is the expected size ($expected_size_bytes bytes)"
            return 0
        elif (( $(stat -c '%s' "$g_install_path/Proton-$version.tar.gz") != expected_size_bytes )) || ((g_force))
        then
            echo "Force mode is enabled. Existing saved package for Proton-$version will be replaced"
            if ($g_command_rm -- "$g_install_path/Proton-$version.tar.gz")
            then
                ((g_verbose)) && vMsg "Saved package removed: $g_install_path/Proton-$version.tar.gz" g
            else
                vMsg "Failed to remove saved package: $g_install_path/Proton-$version.tar.gz" r
                return 1
            fi
        fi
    fi

    # Create a temporary path for the package
    temp_path=$(MkTempPath)

    # Define the temporary package name
    temp_package=$temp_path/Proton-${version}.tar.gz

    # Get the bytes remaining on the temp path
    temp_base_path_remaining_bytes=$(SpaceRemaining "$g_temp_base_path" "b")

    # Get the bytes remaining on the install path
    install_path_remaining_bytes=$(SpaceRemaining "$g_install_path" "b")

    # Check if there is enough free space to copy the package to g_install_path
    if ((expected_size_bytes > install_path_remaining_bytes))
    then
        printf "%s\n%s\n" \
               "WARNING: Not enough free space at $g_install_path" \
               "Need at least $expected_size_bytes bytes but there is only $install_path_remaining_bytes bytes free"
        return 1
    fi

    # If there is not enough free space remaining on the temp_path file system
    # TODO: Use a different path as a fallback?
    if ((temp_base_path_remaining_bytes < expected_size_bytes))
    then
        ((g_verbose)) && vMsg "$temp_base_path_remaining_bytes bytes remaining on $g_temp_base_path"
        printf "%s\n%s\n%s\n" \
               "WARNING: Not enough free space on temp_path: $g_temp_base_path" \
               "Need at least $expected_size_bytes bytes but there is only $temp_base_path_remaining_bytes bytes free" \
               "Free up space or change temp_path in the configuration file"
        return 1
    fi

    # Attempt to retrieve the package with curl
    echo "Downloading $package_download_url"
    if curl -# -L "$package_download_url" -o "$temp_package" 2>&1
    then
        # Get the downloaded file size in bytes
        downloaded_package_size_bytes=$(stat -c '%s' -- "$temp_package")
        ((g_verbose)) && vMsg "downloaded_package_size_bytes: $downloaded_package_size_bytes"

        # Not found
        if ((downloaded_package_size_bytes == 9))
        then
            vMsg "Server responded \"Not Found\" for version $version" r
            CleanUp
            return 1
        fi

        # Github API request rate limit exceeded
        if ((downloaded_package_size_bytes == 248))
        then
            vMsg "Github API request rate limit exceeded. Try again later." r
            CleanUp
            return 1
        fi

        # Check if the the package size and expected size are equal
        if ((downloaded_package_size_bytes == $(QueryGEAttribute "$version" "size")))
        then
            echo "Downloaded package is the expected size ($expected_size_bytes bytes)"
        else
            printf '%s\n%s\n%s\n' \
                   "Downloaded file size and expected size do not match" \
                   "Downloaded file: $downloaded_package_size_bytes bytes" \
                   "Expected size  : $expected_size_bytes bytes"
           CleanUp
           return 1
        fi

        # Copy the package from the temporary path to g_install path
        ##((g_verbose)) && vMsg "Copying package $temp_package to $g_install_path"
        if cp -- "$temp_package" "$g_install_path"
        then
            ((g_verbose)) && vMsg "$temp_package copied to $g_install_path" g
            echo "Copy package to install path succeeded"
            CleanUp
        else
            ((g_verbose)) && vMsg "Failed to copy $temp_package to $g_install_path" r
            echo "Copy package to install path failed"
            CleanUp
            return 1
        fi
    else
        # curl returned >0
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Extract a Proton-ge-custom package (.tar.gz) to g_install path or
#          optionally to a specified path.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (optional) The path to extract the package to (default: g_install_path)
# Output:  None
# Return:  0 = Success
#          1 = Failure
ExtractGEPackage() {

    local version=${1-} extract_file extract_path

    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    # Define the package name to extract
    extract_file=$g_install_path/Proton-${version}.tar.gz

    # Define the path to extract the package to
    extract_path=${2:-$g_install_path}
    [[ ! -d $extract_path && -w $extract_path ]] && { ((g_verbose)) && vMsg "Parameter error (not a valid path)" r; return 1; }

    # Display "Extracting" with trailing dots indicating the extraction progress
    printf '%s' "Extracting $extract_file to $extract_path"
    if tar --checkpoint=.10000 -C "$extract_path" -xzf "$extract_file" 2> /dev/null
    then
        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extraction failed"

        # If the extraction failed, remove the partially extracted path
        if [[ -d $extract_path/Proton-${version} ]]
        then
            if ($g_command_rm -- "$extract_path/Proton-${version}")
            then
                ##((g_verbose)) && vMsg "Removal succeeded"
                echo "Removed failed extraction path at $extract_path/Proton-${version}"
            else
                vMsg "Failed to remove partial extraction path: $extract_path/Proton-${version}" r
            fi
        fi
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Generate a pseudo-random alphanumeric string using only Bash
# Input:   1 (optional) An integer indicating the length of the sequence to generate
# Output:  A string containing the generated alphanumeric sequence (stdout)
# Return:  0 Success
#          1 (Failure) printf returned failure status
# NOTE: Valid input length range 1-32767 (default: 10)
GenerateRandomAlphaNumericString() {

    local char_list="abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" char result=""
    local -i length=${1:-10}

    # If the length requested is outside sane upper and lower bounds, reset it
    (( length < 1 )) && length=1
    (( length > 32767 )) && length=32767

    # Loop length times
    while (( ${#result} < length ))
    do
        # Randomly choose one offset of length one from char_list
        char=${char_list:$((RANDOM%62)):1}

        # Concatenate result and char
        result=${result}${char}
    done

    # "Return" the resulting string,
    # meant to be captured using command substitution
    # eg. sSTRING_OF_LENGTH_TEN=$(GenerateRandomAlphaNumericString 10)
    printf '%s' "$result"

    return 0
}

################################################################################
# Purpose: Set the global variable g_latest_version to the latest version
#          which is retrieved from the name member of the assets object in
#          the local file g_file_latest_json.
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = (Failure) UpdateCachedGEReleases returned 1, or a match was not
#                        found in g_file_latest_json.
#
GetLatestGEVersion() {

    local version

    g_latest_version=''

    if UpdateCachedGEReleases; then
        while IFS= read -r -- || [[ -n $REPLY ]]
        do
            # WARNING: Do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST"
            #          for matching. The version extracted from them (eg. 5.9-GE-5-ST) is not
            #          always the same as the version extracted from browser_download_url
            # NOTE: The regex must match all 3 of the following potential formats:
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name": "Proton-5.9-GE-5-ST.tar.gz"
            if [[ $REPLY =~ ^[[:space:]]*\"name\":[[:space:]]*\"Proton-.*\.tar\.gz\".*$ ]]
            then
                REPLY=${REPLY%\"*}
                version=${REPLY##*\"}
                ##((g_verbose)) && vMsg "version: $version"
                CleanUpVersion
                g_latest_version=$version
                ((g_verbose)) && vMsg "g_latest_version: $g_latest_version"
                break
            fi
        done < "$g_file_latest_json"
        if [[ -z $g_latest_version ]]
        then
            ((g_verbose)) && vMsg "g_latest_version is NULL (no match or not found)" r
            return 1
        fi
    else
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status" y
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Install a requested proton-ge-custom release version or install the
#          latest version. If g_force=1 and a saved package exists for the
#          requested version the package will be removed and a new one will be
#          downloaded.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = (Failure) The requested version failed to download or failed to
#                        extract to the install path.
InstallGEVersion() {

    local version=${1-} package_size=''

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    CleanUpVersion

    ##[[ -n $version ]] && ((g_verbose)) && vMsg "Checking for $version"

    # If the requested version is already installed
    if IsInstalled "$version"
    then
        # If force mode is on
        if ((g_force))
        then
            # If Steam is running, avoid undefined behavior
            if IsSteamRunning
            then
                echo "Please close Steam before re-installing a version"
                return 1
            # If Steam is not running, remove the install
            # NOTE: The re-install is handled below
            else
                echo "Forcing re-install of version Proton-$version"
                echo "Removing install at $g_install_path/Proton-${version}"
                if ($g_command_rm -r -- "$g_install_path/Proton-${version}")
                then
                    echo "Install removed"
                else
                    echo "Remove failed"
                    return 1
                fi
            fi
        # If force mode is off, nothing else to do
        else
            echo "Version Proton-$version is already installed"
            return 0
        fi
    fi

    # If a saved package exists for the requested version
    if [[ -f $g_install_path/Proton-${version}.tar.gz ]]
    then
        # If force mode is on, remove the package
        if ((g_force))
        then
            echo "Removing saved package $g_install_path/Proton-${version}.tar.gz"
            if ($g_command_rm -- "$g_install_path/Proton-${version}.tar.gz")
            then
                echo "Package removed"
            else
                echo "Removing package failed"
                return 1
            fi
        # If force mode is off, use the saved package
        else
            echo "Using saved package: $g_install_path/Proton-${version}.tar.gz"

            # Check that the size of the package is the expected size
            package_size=$(QueryGEAttribute "$version" "size")
            [[ -z $package_size ]] && { ((g_verbose)) && vMsg "Unable to determine expected package size" y; }

            if ((g_verbose))
            then
                vMsg "package_size      : $package_size"
                vMsg "saved_package_size: $(stat -c '%s' -- "$g_install_path/Proton-${version}.tar.gz")"
            fi

            if [[ -n $package_size ]] && (( $(stat -c '%s' -- "$g_install_path/Proton-${version}.tar.gz") != package_size ))
            then
                echo "Saved package is not the expected size, a new one will be downloaded"
                if RemoveSavedPackage "$version"
                then
                    echo "Removed package for $version"
                else
                    echo "WARNING: Remove package for $version failed"
                    return 1
                fi
            else
                if ExtractGEPackage "$version"
                then
                    echo "Installation of version Proton-$version was successful"
                    IsSteamRunning && echo "Restart steam to use the new version"
                    return 0
                else
                    echo "Installation of version Proton-$version failed"
                    return 1
                fi
            fi
        fi
    fi

    # Download a new package and extract it.
    if DownloadGEPackage "$version"
    then
        if ExtractGEPackage "$version"
        then
            echo "Installation of version Proton-$version was successful"
            IsSteamRunning && echo "Restart steam to use the new version"
            return 0
        else
            echo "Installation of version Proton-$version failed"
            return 1
        fi
    else
        echo "Version $version not found"
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Check if a version is installed
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Yes/True
#          1 No/False
IsInstalled() {

    local version=${1-}

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    # Fix for Proton-5.0-GE-1-no-mouse-coord.tar.gz
    version=${version//'-NO-MOUSE-COORD'/}
    version=${version//'-no-mouse-coord'}

    version=${version//'Proton-'}
    version=${version//'proton-'}

    ((g_verbose)) && vMsg "Checking $version at $g_install_path/Proton-${version}"

    if [[ -d $g_install_path/Proton-${version} ]] && [[ -f "$g_install_path/Proton-${version}/version" ]]
    then
        # NOTE: versioning within the file version (inside an installed package path) is not consistent
        while IFS= read -r -- || [[ -n $REPLY ]]
        do
            if [[ -n $REPLY ]]
            then
                ((g_verbose)) && vMsg "Found $version" g
                return 0
            else
                ((g_verbose)) && vMsg "$version not found" y
                return 1
            fi
        done < "$g_install_path/Proton-${version}/version"
    else
        return 1
    fi

    # NOTE: Do not return 0 here
}

################################################################################
# Purpose: Detect if a specified JSON file is minified or not.
# Input:   1 (required) A JSON file
# Output:  None
# Return:  0 Yes/True
#          1 No/False
IsJSONminified() {

    local file_json=${1-}
    local -i counter_lines=0

    [[ -z $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    [[ ! -f $file_json || ! -r $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (not a file and/or not readable)" r; return 1; }

    # Get the number of newlines in the file
    counter_lines=$(wc -l -- < "$file_json")
    ((g_verbose)) && vMsg "counter_lines: $counter_lines"

    # 0 is the actual value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added or if in the future
    # minified JSON is returned that has 1 newline.
    if ((g_verbose))
    then
        if ((counter_lines <= 1))
        then
            vMsg "minified"
        else
            vMsg "not minified"
        fi
    fi

    return $(( (counter_lines <= 1) ? 0 : 1 ))
}

################################################################################
# Purpose: Check if Steam is running
# Input:   None
# Output:  None
# Return:  0 (Yes/True) A Steam process was detected, or an error occured.
#          1 (No/False) A Steam process was not detected.
IsSteamRunning() {

    local steam_pids=''
    local -i flag_found_steam=0

    # This feature requires pgrep
    command -v pgrep > /dev/null || { ((g_verbose)) && vMsg "pgrep not found" r; return 1; }

    if (( $(pgrep -i steam | wc -l) > 0 ))
    then
        # steam
        steam_pids=$(pgrep -ix steam)
        if [[ -n $steam_pids ]]
        then
            flag_found_steam=1
            ((g_verbose)) && vMsg "steam found at PID(s): ${steam_pids//$'\n'/' '}"
        fi

        # steamwebhelper
        ##steamwebhelper_pids=$(pgrep -ix steamwebhelper)
        ##[[ -n $steamwebhelper_pids ]] && {
        ##    ((g_verbose)) && vMsg "steamwebhelper process found at PID(s): ${steamwebhelper_pids//$'\n'/' '}"
        ##}
    fi

    ((g_verbose)) && { ((flag_found_steam)) || vMsg "steam process not found"; }

    return $(( flag_found_steam ? 0 : 1 ))
}

################################################################################
# Purpose: Parse g_file_releases_json and print all the versions that are
#          are available to install.
# Input:   None
# Output:  None
# Return:  0 (Success) UpdateCachedGEReleases returned success
#          1 (Failure) UpdateCachedGEReleases returned failure, zero lines were
#                      read from g_file_latest_json, or zero version matches
#                      occurred.
ListAvailableGEVersions() {

    local line_releases value_release_notes_url=''
    local -i flag_url_found=0 flag_version_found=0 line_counter=0 version_counter=0

    if UpdateCachedGEReleases
    then
        while IFS= read -r -- line_releases || [[ -n $line_releases ]] # NOTE: g_file_releases_json does not always have a trailing blank line
        do
            ((line_counter++))
            [[ -z $line_releases ]] && continue

            # Match a release notes URL and store it in value_release_notes_url
            # "html_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/5.9-GE-5-ST"
            # "html_url":  "https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/5.9-GE-5-ST"
            # "html_url":   "https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/5.9-GE-5-ST",
            if [[ $line_releases =~ ^[[:space:]]*\"html_url\":[[:space:]]*\"https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/.*$ ]]
            then
                flag_url_found=1
                line_releases=${line_releases%\"*}
                value_release_notes_url=${line_releases##*\"}
                continue
            else
                [[ -z $value_release_notes_url ]] && flag_url_found=0
            fi

            # NOTE: The regex must match all 3 of the following potential formats:
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name": "Proton-5.9-GE-5-ST.tar.gz"
            if [[ $line_releases =~ ^[[:space:]]*\"name\":[[:space:]]*\"Proton-.*\.tar\.gz\".*$ ]]
            then
                line_releases=${line_releases%.tar.gz*}
                line_releases=${line_releases#*Proton-}
                if ((flag_url_found))
                then
                    if [[ -n $value_release_notes_url ]]
                    then
                        if (( ${GEIM_TESTS-0} ))
                        then
                            echo "Proton-${line_releases}"
                        else
                            # If there are enough columns
                            if (( ${COLUMNS:-0} > 112 ))
                            then
                                # Add whitespace to make things easier to read
                                while (( ${#line_releases} <= (30-7) )) # minus the length of Proton-
                                do
                                    line_releases="${line_releases} " # "pad" with a space
                                done
                                echo "Proton-${line_releases} $value_release_notes_url"
                            else
                                # Don't print the URL if there isn't enough room or if COLUMNS was unset/NULL
                                if (( ${COLUMNS:-0} < 80 ))
                                then
                                    echo "Proton-${line_releases}"
                                else
                                    # Columns between 81 and 112
                                    # Use an alternative format that prints the version and the
                                    # release URL on seperate lines
                                    printf "%s:\n%s\n" "Proton-${line_releases}" "$value_release_notes_url"
                                fi
                            fi
                        fi
                    else
                        echo "Proton-${line_releases} (URL not found)"
                    fi
                else
                    echo "Proton-${line_releases} (URL not found)"
                fi
                ((version_counter++))
                continue
            fi
        done < "$g_file_releases_json"

        ((line_counter == 0)) && { ((g_verbose)) && vMsg "Zero lines found" r; return 1; }
        ((version_counter == 0)) && { ((g_verbose)) && vMsg "Zero version matches" r; return 1; }
    else
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status" y
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Print the currently installed Proton-ge-custom versions, saved
#          packages, and their individual disk usage to stdout.
# Input:   None
# Output:  None
# Return:  0 (Success) Always
ListInstalledGEVersions() {

    local node installed_version_disk_usage saved_package_disk_usage saved_packages_total_disk_usage size_bytes expected_size_bytes
    local -i i=0

    ##((g_verbose)) && vMsg "Install path: $g_install_path"

    echo "Installed version(s)"
    for node in "$g_install_path"/Proton-*
    do
        if [[ -d $node ]]
        then
            ((i++))
            # Get the disk usage of the package in human readable format
            IFS=$'\t' read -r -- installed_version_disk_usage path < <(du -sh -- "$node")
            printf '%s\n' "  ${node##*/} ($installed_version_disk_usage)"
        fi
    done
    ((i)) || echo "  None found"

    echo "Saved package(s)"
    i=0
    for node in "$g_install_path"/Proton-*.tar.gz
    do
        if [[ -f $node ]]
        then
            ((i++))
            size_bytes=$(stat -c '%s' -- "$node")
            expected_size_bytes=$(QueryGEAttribute "${node##*/}" "size")
            if [[ -n $expected_size_bytes ]] && ((size_bytes != expected_size_bytes))
            then
                echo "  ${node##*/} (WARNING: Size [$size_bytes] is not the expected size [$expected_size_bytes])"
            else
                IFS=$'\t' read -r -- saved_package_disk_usage path < <(du -h -- "$node")
                printf '%s\n' "  ${node##*/} ($saved_package_disk_usage)"
            fi
        fi
    done

    # Report total disk usage for saved packages if two or more were found
    if ((i >= 2))
    then
        while IFS=$'\t' read -r -- size path
        do
            [[ $path = "total" ]] && saved_packages_total_disk_usage=$size
        done < <(du -csh -- "$g_install_path/"*.tar.gz)
        echo "Saved packages total: $saved_packages_total_disk_usage"
    elif ((i == 0))
    then
        echo "  None found"
    fi

    return 0
}

################################################################################
# Purpose: Bash only primitive replacement for mktemp (file version)
# Input:   None
# Output:  A string containing a path and file with no trailing newline (stdout)
# Return:  0 Success
#          1 (Failure) g_temp_base_path does not exist or is not writeable.
MkTempFile() {

    local temp_file

    temp_file=$g_temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16) || return 1

    ((g_verbose)) && vMsg "Created temp file at $temp_file" g

    # Create the empty temp file
    : > "$temp_file"

    # "Return" the path and filename,
    printf '%s' "$temp_file"

    return 0
}

################################################################################
# Purpose: Bash only primitive replacement for mktemp (path version)
# Input:   None
# Output:  A string containing a path with no trailing newline (stdout)
# Return:  0 Success
#          1 (Failure) g_temp_base_path does not exist or is not writeable.
MkTempPath() {

    local temp_path

    temp_path=$g_temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16) || return 1

    ((g_verbose)) && vMsg "Created temp path at $temp_path" g

    # Create the path
    mkdir -p "$temp_path" &> /dev/null

    # "Return" the path and filename,
    printf '%s' "$temp_path"

    return 0
}

################################################################################
# Purpose: Parse the config file set in the global variable g_file_script_config,
#          validate recognized key/value pairs and then set/reset global
#          variables accordingly.
# Input:   None
# Output:  None
# Return:  0 Success
#          1 (Failure) An invalid value was encountered during key/value validation
#                      or if after parsing the config file a crucial global variable
#                      is empty.
# NOTE: Runs DetectSteamInstallPath if g_install_path is set to the special value "auto"
ParseConfigFile() {

    local config_key config_value
    local -i existing_config_file_lines=0 counter_config_line=0 flag_failed=0 flag_update_install_path=0

    existing_config_file_lines=$(wc -l 2> /dev/null < "$g_file_script_config") # NOTE: do not || return 1 here

    ##((g_verbose)) && vMsg "existing_config_file_lines: $existing_config_file_lines"

    # If existing_config_file_lines is empty or g_file_script_config doesn't exist, create a default config file
    if [[ -z $existing_config_file_lines || ! -f $g_file_script_config ]]
    then
        ##((g_verbose)) && vMsg "Generating a default config file at: $g_file_script_config"
        if CreateDefaultConfigFile
        then
            ##((g_verbose)) && vMsg "CreateDefaultConfigFile returned success" g
            echo "Default configuration created at $g_file_script_config"
            if (( ! g_automated_mode )) && [[ -n ${EDITOR-} ]] && ((! ${GEIM_TESTS:-0}))
            then
                ##((g_verbose)) && vMsg "EDITOR is set to: $EDITOR"
                while :
                do
                    read -rp "Would you like to open it with ${EDITOR}? " </dev/tty
                    case ${REPLY,,} in
                        (y|yes)
                            $EDITOR "$g_file_script_config"
                            echo "Configuration file location: $g_file_script_config"
                            break
                        ;;
                        (n|no)
                            break
                        ;;
                        (*)
                            echo "Enter (y)es or (n)o"
                        ;;
                    esac
                done
            fi
        else
            vMsg "Failed to create default config file at: $g_file_script_config" r
            return 1
        fi
    fi

    # Sanity checks
    if [[ -z $g_file_script_config || ! -f $g_file_script_config || ! -w $g_file_script_config ]]
    then
        ((g_verbose)) && vMsg "g_file_script_config error (NULL, not a file, or not writeable)" r
        return 1
    fi

    # Begin parsing g_file_script_config
    while IFS= read -r -- || [[ -n $REPLY ]]
    do

        # Increment the line counter
        ((counter_config_line++))

        # Ignore lines that begin with a # (comments)
        [[ $REPLY =~ ^#.*$ ]] && continue

        # Ignore lines that contain one or more semi-colon ";". Anti-exploit measure.
        [[ $REPLY =~ ^.*\;+.*$ ]] && continue

        # Ignore lines containing potential escape sequences. Anti-exploit measure.
        [[ $REPLY =~ ^.*\\[[:digit:]]+\[.*$ ]] && continue

        # Trim away inline comments
        if [[ $REPLY =~ ^.*#.*$ ]]
        then
            # remove the ' #' and everything to the right of it
            # NOTE: valid comments are preceded by at least one [[:space:]]
            # BUG: this will mangle herestrings that contain comments
            REPLY=${REPLY%%[[:space:]]#*}
        fi

        # Ignore lines that are empty
        [[ -z $REPLY ]] && continue

        # Ignore lines that don't contain exactly one = and also don't have characters on either side of the = sign.
        # If there are characters on either side of the = sign, they may not be spaces or tabs
        [[ $REPLY =~ ^[^=[:blank:]]+=[^=[:blank:]]+$ ]] || continue

        # Get the key (the characters to the left of the equals "=" sign)
        config_key=${REPLY%%=*}

        # Get the value (the characters to the right of the equals "=" sign)
        config_value=${REPLY#*=}

        # Expand any variables in the config using envsubst or eval
        # Skip expansion if the value doesn't contain one or more $
        if [[ $config_value =~ ^.+[$]+.+$ ]]
        then
            if [[ $config_value =~ ^.+:[+-=?]{1}.+$ ]]
            then
                config_value=$(eval printf '%s' "$config_value")
            else
                if command -v envsubst > /dev/null
                then
                    config_value=$(envsubst <<< "$config_value")

                    # If there is still a $ in config_value it contained a variable envsubst couldn't expand
                    if [[ $config_value =~ ^.*\$+.*$ ]]
                    then
                        config_value=$(eval printf '%s' "$config_value")
                    fi
                else
                    config_value=$(eval printf '%s' "$config_value")
                fi
            fi
        fi

        # Validate values for recognized keys and set global variables accordingly
        case $config_key in
            (install_path)
                # If the value for install_path is the special value "auto", attempt to auto detect the steam install path
                # NOTE: If one is found/chosen the global variable g_override_default_install_path will be set accordingly.
                #       A value of NULL indicates a problem, error, or user chose manual configuration in which case
                #       the value will remain auto.
                if [[ ${config_value,,} = "auto" ]]
                then
                    DetectSteamInstallPath
                    if [[ -n $g_override_default_install_path && ${g_override_default_install_path,,} != "auto" ]]
                    then
                        config_value=$g_override_default_install_path/compatibilitytools.d
                        flag_update_install_path=1
                    fi

                    [[ ${g_override_default_install_path,,} = "auto" ]] && exit 1
                fi

                if [[ -d $config_value && -w $config_value ]]
                then
                    g_install_path=$config_value
                    flag_update_install_path=1
                else
                    if mkdir -p -- "$config_value" > /dev/null
                    then
                        if [[ -w $config_value ]]
                        then
                            g_install_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                            flag_failed=1
                            flag_update_install_path=0
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                        flag_failed=1
                        flag_update_install_path=0
                    fi
                fi
            ;;
            (cache_path)
                if [[ -d $config_value && -w $config_value ]]
                then
                    # If cache_path would = g_install_path
                    ((g_verbose)) && [[ $config_value -ef $g_install_path ]] && vMsg "cache_path is the same as g_install_path" y
                    g_script_cache_path=$config_value
                else
                    if mkdir -p -- "$config_value" > /dev/null
                    then
                        if [[ -w $config_value ]]
                        then
                            g_script_cache_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                            flag_failed=1
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                        flag_failed=1
                    fi
                fi
            ;;
            (tmp_path) # g_temp_base_path
                # If tmp_path would = g_install_path (would cause issues with VerifyGEInstall)
                if [[ $config_value -ef $g_install_path ]]
                then
                    vMsg "Setting tmp_path and g_install_path to the same path is not supported" r
                    flag_failed=1
                fi
                if [[ -d $config_value && -w $config_value ]]
                then
                    g_temp_base_path=$config_value
                else
                    if mkdir -p -- "$config_value" > /dev/null
                    then
                        if [[ -w $config_value ]]
                        then
                            g_temp_base_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                            flag_failed=1
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                        flag_failed=1
                    fi
                fi
            ;;
            (rm_command)
                if (command -v -- "$config_value" > /dev/null)
                then
                    g_command_rm=$config_value
                else
                    ((g_verbose)) && vMsg "command -v $config_value failed" r
                    vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                    vMsg "If you don't want the script to use 'rm' then fix it" y
                    g_command_rm='rm'
                fi
            ;;
            (latest_version_url)
                if curl -sLI -- "$config_value" > /dev/null
                then
                    g_latest_version_url=$config_value
                else
                    vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                    flag_failed=1
                fi
            ;;
            (releases_url)
                if curl -sLI -- "$config_value" > /dev/null
                then
                    g_releases_url=$config_value
                else
                    vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" r
                    flag_failed=1
                fi
            ;;
            (*)
                ((g_verbose)) && vMsg "No key match for valid config ($counter_config_line): $REPLY" y
            ;;
        esac
    done < "$g_file_script_config"

    # Update install_path in the configuration file if necessary
    if ((flag_update_install_path))
    then
        if [[ -n ${g_override_default_install_path-} ]]
        then
            g_install_path=$g_override_default_install_path/compatibilitytools.d
            [[ -f $g_file_script_config ]] && CreateBackup "$g_file_script_config"
            # Update install_path in the config file
            if ! sed -i "s|install_path=auto|install_path=$g_install_path|" -- "$g_file_script_config"
            then
                flag_failed=1
            fi
        fi
    fi

    # If any crucial config options are empty (missing from config, except g_script_config_path)
    [[ -z ${g_install_path-} ]] && { vMsg "Missing g_install_path ($g_file_script_config)" r; return 1; }
    [[ -z ${g_temp_base_path-} ]] && { vMsg "Missing g_temp_base_path ($g_file_script_config)" r; return 1; }
    # A warning in case the default global variable is manually changed
    [[ -z ${g_script_config_path-} ]] && { vMsg "Missing g_script_config_path" r; return 1; }
    [[ -z ${g_script_cache_path-} ]] && { vMsg "Missing g_script_cache_path ($g_file_script_config)" r; return 1; }

    # Update global variables
    g_file_latest_json="$g_script_cache_path"/latest.json
    g_file_script_raw=$g_script_cache_path/$SCRIPT_FULL_NAME.update
    g_file_releases_json="$g_script_cache_path"/releases.json

    # Verbose report
    if ((g_verbose))
    then
        vMsg "Install path set to: ${g_install_path-}" y
        vMsg "Temp path set to: ${g_temp_base_path-}" y
        vMsg "Config path set to: ${g_script_config_path-}" y # NOTE: config_path is currently not configurable
        vMsg "Cache path set to: ${g_script_cache_path-}" y
        vMsg "g_command_rm set to: ${g_command_rm-}" y
        vMsg "g_latest_version_url set to: ${g_latest_version_url-}" y
        vMsg "g_releases_url set to: ${g_releases_url-}" y
        vMsg "g_file_latest_json set to: ${g_file_latest_json-}" y
        vMsg "g_file_script_raw set to: ${g_file_script_raw-}" y
        vMsg "g_file_releases_json set to: ${g_file_releases_json-}" y
    fi

    return $(( flag_failed ? 1 : 0 ))
}

################################################################################
# Purpose: Parse command line parameters using getopts and set global variables
#          according to what was requested.
# Input:   1 (required) "$@" (all script positional parameters)
# Output:  None
# Return:  getopts exit status
#          0  (An option, specified or unspecified by optstring, was found.)
#          >0 (The end of options was encountered or an error occurred.)
ParseParameters() {
    OPTERR=1 # make sure it's on
    while getopts 'zZThHflLn:NSs:i:d:DR:r:xuUXv:VA' sOPT
    do
        case "$sOPT" in
            (h)
                g_show_help=1
            ;;
            (H)
                g_show_usage=1
            ;;
            (f)
                g_force=1
            ;;
            (z)
                g_verbose=1
            ;;
            (T)
                if [[ $g_force -eq 1 && $g_verbose -eq 1 ]]
                then
                    g_integration_testing=1
                    ProvingGrounds
                    exit $?
                fi
            ;;
            (Z)
                if [[ $g_force -eq 1 && $g_verbose -eq 1 ]]
                then
                    ReportEnvironmentInfo
                elif [[ $g_force -eq 0 && $g_verbose -eq 1 ]]
                then # -zZ
                    printf "%s: illegal option -- Z (did you mean -fzZ?)\n" "$0"
                    exit 0
                elif [[ $g_force -eq 0 && $g_verbose -eq 0 ]]
                then # -Z
                    printf "%s: illegal option -- Z\n" "$0"
                    exit 0
                fi
            ;;
            (u)
                g_check_update=1
            ;;
            (D)
                g_uninstall_script=1
            ;;
            (X)
                g_remove_install_path=1
            ;;
            (x)
                g_remove_all_saved_packages=1
            ;;
            (R)
                g_remove_installed_version=1
                g_remove_version=$OPTARG
            ;;
            (r)
                g_remove_saved_package=1
                g_remove_saved_version=$OPTARG
            ;;
            (l)
                g_list_installed_versions=1
            ;;
            (L)
                g_list_available_versions=1
            ;;
            (n)
                g_show_release_notes=1
                g_show_release_notes_version=$OPTARG
            ;;
            (N)
                g_show_all_release_notes=1
            ;;
            (s)
                g_report_version_usage=1
                g_report_version=$OPTARG
            ;;
            (S)
                g_report_install_path_usage=1
            ;;
            (d)
                g_download=1
                g_download_version=$OPTARG
            ;;
            (i)
                g_install=1
                g_install_version=$OPTARG
            ;;
            (U)
                g_update=1
            ;;
            (V)
                g_verify=1
            ;;
            (v)
                g_verify=1
                g_verify_version=$OPTARG
            ;;
            (A)
                g_automated_mode=1
            ;;
            (":"|"?") return 1 ;;
        esac
    done
}

################################################################################
# Purpose: Provide a function to test new features and/or changes independent
#          of the rest of the script.
# Input:   None
# Output:  None
# Return:  0 (Success) Always
# NOTE: Exactly -fzT invokes this function
# All hope abandon, ye who enter here!
ProvingGrounds() {

    ((g_integration_testing)) || return 1

    if CheckRequirements
    then
        if ParseConfigFile
        then
            if ! SetupEnvironment
            then
                exit 1
            fi
        else
            exit 1
        fi
    else
        exit 1
    fi
    vMsg "Setup succeeded" g

    # Tests
    if IsInstalled "5.1-ge-1"
    then
        echo "Is installed"
    else
        echo "Is not installed"
    fi

}

################################################################################
# Purpose: A wrapper for QueryJSONAttribute that provides a single function call
#          to retrieve values from keys/attributes in both g_file_latest_json and
#          g_file_releases_json.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (required) A supported attribute name (refer to QueryJSONAttribute)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 (Failure) A value was not found for the requested attribute or an error occured.
QueryGEAttribute() {

    local version=${1-} key=${2-} value

    if [[ -z $version || -z $key || $# -ne 2 ]]
    then
        ((g_verbose)) && vMsg "Parameter error 1: $version 2: $key \$#: $#" r
        return 1
    fi

    CleanUpVersion

    if ! UpdateCachedGEReleases
    then
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status" y
        ##return 1
    fi

    if [[ -f $g_file_releases_json ]]
    then
        ##((g_verbose)) && {
        ##    vMsg "Checking $g_file_releases_json"
        ##    vMsg "For $key of version $version"
        ##}

        value=$(QueryJSONAttribute "$g_file_releases_json" "$version" "$key")
        ((g_verbose)) && vMsg "QueryJSONAttribute returned: \"$value\"" g
    fi

    # Disabled (releases contains latest)
    if ((${CHECK_LATEST:-0}))
    then
        # If value is still empty/NULL check g_file_latest_json
        if [[ -z $value ]] && [[ -f $g_file_latest_json ]]
        then
            ##((g_verbose)) && {
            ##    vMsg "Checking $g_file_latest_json"
            ##    vMsg "For $key of version $version"
            ##}

            # Search g_file_latest_json
            value=$(QueryJSONAttribute "$g_file_latest_json" "$version" "$key")
            ((g_verbose)) && vMsg "QueryJSONAttribute returned: \"$value\"" g
        fi
    fi

    if [[ -n $value ]]
    then
        printf '%s' "$value"
        return 0
    else
        printf ''
        return 1
    fi

    return 1
}

################################################################################
# Purpose: Retrieve a supported attribute value from a specified JSON file
# Input:   1 (required) JSON file
#          2 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          3 (required) A supported attribute name (size or browser_download_url)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 (Failure) A value was not found for the requested attribute or an error occured.
#
# NOTE This function relies on the JSON being structured in a precise, predictable order
# Example order of attributes expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE: The default media-type requested is "application/vnd.github.v3.text+json" and
#       the current sed script also reformats the body_text section to plain text. Those
#       choices were made to more easily support (eventually) showing release notes.
QueryJSONAttribute() {

    local file_json=${1-} version=${2-} key=${3-} value_browser_url=''
    local -i counter_lines=0 flag_version_found=0 flag_size_found=0 value_size_bytes=0

    # If the number of parameters is not exactly three, the second parameter is not a regular file, or any of the three parameters are empty
    if [[ $# -ne 3 ]] || [[ ! -f $file_json ]] || [[ -z $file_json || -z $version || -z $key ]]
    then
        ((g_verbose)) && vMsg "Parameter error 1: $1 2: $2 3: $3 \$#: $#" r
        return 1
    fi

    # Check if the key/attribute requested is currently supported
    if [[ ${key,,} != @(size|browser_download_url) ]]
    then
        ((g_verbose)) && vMsg "Parameter error (unsupported key requested)" r
        return 1
    fi

    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "version is NULL" r; return 1; }

    ##((g_verbose)) && vMsg "Searching in $file_json"

    while IFS= read -r -- || [[ -n $REPLY ]]
    do
        ((counter_lines++))
        # version match
        # version example: 5.9-GE-5-ST
        # NOTE: must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        if ((! flag_version_found))
        then
            if [[ $REPLY =~ ^.*\"name\":[[:space:]]*\"Proton-${version}\.tar\.gz\".*$ ]]
            then
                flag_version_found=1
                ##((g_verbose)) && vMsg "REPLY: $REPLY"
                ((g_verbose)) && vMsg "name match: $counter_lines"
                continue
            fi
        fi

        # NOTE: must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        if ((flag_version_found && ! flag_size_found))
        then
            if [[ ${REPLY,,} =~ ^.*\"size\":[[:space:]]*[[:digit:]]+.*$ ]]
            then
                flag_size_found=1
                ##line_size_found=$counter_lines
                if ((g_verbose))
                then
                    vMsg "size match: $counter_lines"
                    vMsg "line: $REPLY"
                fi
                REPLY=${REPLY//[[:space:]]}
                REPLY=${REPLY#*'size":'}
                REPLY=${REPLY%%','*}
                ##((g_verbose)) && vMsg "REPLY: $REPLY"
                value_size_bytes=${REPLY//[!0-9]/} # Remove all characters that are not digits
                ##((g_verbose)) && vMsg "value_size_bytes: $value_size_bytes"
                continue
            fi
        fi

        # NOTE: must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        if ((flag_version_found && flag_size_found))
        then
            if [[ $REPLY =~ ^.*\"browser_download_url\":[[:space:]]*\".*Proton-${version}\.tar\.gz\".*$ ]]
            then
                ##flag_browserurl_found=1
                ##line_browserurl_found=$counter_lines
                ((g_verbose)) && vMsg "browser_download_url match: $counter_lines"
                ##((g_verbose)) && vMsg "REPLY: $REPLY"
                REPLY=${REPLY//[[:space:]]} # Remove all spaces/tabs
                REPLY=${REPLY/#*\"browser_download_url\":\"} # Trim the unneeded left side
                value_browser_url=${REPLY%%\"*} # Trim the unneeded right side
                ##((g_verbose)) && vMsg "value_browser_url: $value_browser_url"
                break
            fi
        fi
    done < "$file_json"

    # Print the value of the requested attribute to stdout
    if [[ -n $value_size_bytes && -n $value_browser_url ]]
    then
        case ${key,,} in
            (size)
                printf '%s' "$value_size_bytes"
            ;;
            (browser_download_url)
                printf '%s' "$value_browser_url"
            ;;
            (*)
                printf ''
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Run sed using the script g_file_sed_unminify_script (generated by the
#          function CreateSedUnminifyJSONscript) on a specified file.
# Input:   1 (required) A JSON file (minified and not minified are both supported)
# Output:  None
# Return:  0 Success
#          1 Failure
ReformatJSONUsingSed() {

    local file_json=${1-} file_type=''

    [[ -z $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }
    [[ -f $file_json ]] || { ((g_verbose)) && vMsg "Parameter error (not a file)" r; return 1; }

    # Try to avoid running the unminify script on non-JSON data
    file_type=$(file -b "$file_temp" 2> /dev/null)

    ##((g_verbose)) && { vMsg "file_json: $file_json"; vMsg "file_type: $file_type"; vMsg "g_file_sed_unminify_script: $g_file_sed_unminify_script"; }

    # If the file type is not json, don't run the script on it
    [[ ${file_type,,} == *'json'* ]] || { ((g_verbose)) && vMsg "File type is not JSON: $file_type"; return 0; }

    if [[ -w $file_json ]]
    then
        if sed -i --file="$g_file_sed_unminify_script" "$file_json"
        then
            ##((g_verbose)) && vMsg "sed returned success" g
            return 0
        else
            ((g_verbose)) && vMsg "sed returned failure" r
            return 1
        fi
    else
        vMsg "No write access to $file_json" r
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Remove all saved packages in g_install_path
# Input:   None
# Output:  None
# Return:  0 (Success) All packages or zero packages were removed.
#          1 (Failure) g_command_rm returned >0 for any one package.
RemoveAllSavedPackages() {

    local package
    local -i success_counter=0 failure_counter=0

    ##((g_verbose)) && vMsg "Install path: $g_install_path"

    for package in "$g_install_path"/Proton-*.tar.gz
    do
        if [[ -f $package ]]
        then
            if ($g_command_rm -- "$package")
            then
                echo "Removed $package"
                ((success_counter++))
            else
                echo "Remove $package failed"
                ((failure_counter++))
            fi
        fi
    done

    if ((success_counter == 0))
    then
        echo "0 packages removed"
    elif ((success_counter == 1))
    then
        echo "$success_counter package removed"
    elif ((success_counter > 1))
    then
        echo "$success_counter packages removed"
    fi

    ((failure_counter)) && echo "Failed to remove $failure_counter package(s)"

    return $(( failure_counter ? 1 : 0 ))
}

################################################################################
# Purpose: Remove g_install_path
# Input:   None
# Output:  None
# Return:  0 (Success) The install path was successfully removed and the install
#                      path was subsequently successfully recreated.
#          1 (Failure) g_command_rm returned >0 removing the install path or
#                      mkdir returned failure re-creating the install path failed.
RemoveGEInstallPath() {

    local disk_usage="error"

    disk_usage=$(du -sh -- "$g_install_path" 2>/dev/null)

    if ($g_command_rm -rf -- "$g_install_path")
    then
        echo "Removed $g_install_path (${disk_usage%%[[:space:]]*})"
        ##((g_verbose)) && vMsg "Recreating install path at $g_install_path"

        # Re-create the g_install_path in case a requested subsequent script function needs it
        if ! mkdir -p -- "$g_install_path" > /dev/null
        then
            vMsg "Failed to re-create install path at $g_install_path" r
            return 1
        fi
    else
        vMsg "Removal of install path $g_install_path failed" r
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Remove an installed Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
RemoveGEVersion() {

    local version=${1-} remove_path disk_usage='err'

    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    # Define the path that will be removed
    remove_path=$g_install_path/Proton-${version}

    ##((g_verbose)) && { vMsg "Requested version: $version"; vMsg "remove_path: $remove_path"; }

    # Remove the path if it exists
    if [[ -d $remove_path ]]
    then
        if ! IsSteamRunning
        then
            # Get the disk usage in human readable format
            disk_usage=$(du -sh -- "$remove_path" 2> /dev/null)
            disk_usage=${disk_usage%[[:space:]]*}
            if ($g_command_rm -rf -- "$remove_path" > /dev/null)
            then
                echo "Removed path $remove_path ($disk_usage)"
            else
                echo "Failed to remove $remove_path"
                return 1
            fi
        else
            echo "Please close Steam before removing an install path"
            return 1
        fi
    else
        echo "Install path not found for version $version"
    fi

    return 0
}

################################################################################
# Purpose: Remove a saved package for a specified Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 (Failure) g_command_rm returned >0 status, no write permission to
#                      remove the requested path, or a package for the requested
#                      version does not exist.
RemoveSavedPackage() {

    local version=${1-} package

    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    # Define the package path and name that will be removed
    package=$g_install_path/Proton-${version}.tar.gz

    if [[ -f $package ]]
    then
        if [[ -w $package ]]
        then
            if ($g_command_rm -- "$package")
            then
                echo "Removed $package"
                return 0
            else
                echo "Failed to remove version $version ($g_command_rm returned >0)"
                return 1
            fi
        else
            echo "Failed to remove version $version (no write permission)"
            return 1
        fi
    else
        echo "A saved package for version $version does not exist at $g_install_path"
        return 0
    fi

    return 0
}

################################################################################
# Purpose: Provide a basic diagnostic tool that reports environment information.
# Input:   None
# Output:  None
# Return:  0 (Success) Always
# NOTE: Exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    vMsg "Script version: $SCRIPT_VERSION" y

    echo "###############################################################################"

    uname -a

    echo "###############################################################################"

    declare -p --

    echo "###############################################################################"

    stty -a

    echo "###############################################################################"

    env -v

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V -- du find wc curl tar gzip pgrep stat sed cmp sort envsubst printf

    echo "###############################################################################"

    shopt -p

    echo "###############################################################################"

    echo "PWD: ${PWD-}"
    echo "SHELL: ${SHELL-}"
    echo "SHELLOPTS: ${SHELLOPTS-}"
    echo "SHLVL: ${SHLVL-}"
    echo "BASH_VERSINFO: ${BASH_VERSINFO[*]-}"
    echo "BASH_VERSION: ${BASH_VERSION-}"
    echo "MACHTYPE: ${MACHTYPE-}"
    echo "OSTYPE: ${OSTYPE-}"
    echo "PROMPT_COMMAND: ${PROMPT_COMMAND-}"
    echo "LANG: ${LANG-}"
    echo "LC_MESSAGES: ${LC_MESSAGES-}"
    echo "LC_ALL: ${LC_ALL-}"
    echo "EUID: ${EUID-}"
    echo "GROUPS: ${GROUPS[*]-}"

    echo "###############################################################################"

    exit 0
}

################################################################################
# Purpose: Print the disk usage and file count for g_install_path and/or a
#          specified version to stdout.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 (Failure) version not found
ReportGEDiskUsage() {

    local version=${1-} file_counter path disk_usage="0"

    CleanUpVersion

    # Set the path to be reported based on whether a version was provided or not
    if [[ -z $version ]]
    then
        # Report the file count and disk usage for g_install_path
        if [[ -d $g_install_path ]]
        then
            disk_usage=$(du -sh -- "$g_install_path")
            file_counter=$(find "$g_install_path" -type f | wc -l)
            echo "Install path report"
            printf "  Path: %s\n  Files: %s\n  Disk usage: %s\n" \
                   "$g_install_path" \
                   "$file_counter" \
                   "${disk_usage%%[[:space:]]*}"
        else
            ##((g_verbose)) && vMsg "Path: $g_install_path" y
            echo "Version $version not found"
            return 1
        fi
    fi

    # If a version was supplied as a parameter, report only for that version
    if [[ -n $version ]]
    then
        # Report the file count and disk usage for a specific version
        path=$g_install_path/Proton-${version//'5.0-GE-1-no-mouse-coord'/'5.0-GE-1'}
        if [[ -d $path ]]
        then
            disk_usage=$(du -sh -- "$path")
            file_counter=$(find "$path" -type f | wc -l)
            echo "Version $version report"
            printf "  Path: %s\n  Files: %s\n  Disk usage: %s\n" \
                   "$path" \
                   "$file_counter" \
                   "${disk_usage%%[[:space:]]*}"
        else
            ##((g_verbose)) && vMsg "Path: $path" y
            echo "Version $version not found"
            return 1
        fi
    fi

    return 0
}

################################################################################
# Purpose: Use curl -z to request a specified URL. If the remote URL has an mtime
#          newer than the specified file, write the response to a temporary file.
#          Check the temporary file for basic response errors and if none are found
#          copy the temporary file to the specified file. Used to update
#          g_file_latest_json and g_file_releases_json only if the remote file
#          has been modified.
# Input:   1 (required) A URL (g_latest_version_url or g_releases_url)
#          2 (required) A file (does not have to exist)
# Output:  None
# Return:  0 Success
#          1 (Failure) Curl returned failure, the server responded "Not Found" or
#                      Github API request rate limit exceeded, or a failure occured
#                      trying to copy the temporary file to the specified file.
RequestURL() {

    local requested_url=${1-} file_local=${2-} file_temp data_type=''
    local -i downloaded_package_size_bytes=0

    file_temp=$(MkTempFile)

    [[ -z $requested_url || -z $file_local || $# -ne 2 ]] && ((g_verbose)) && vMsg "Parameter error (NULL or not exactly two)" r

    [[ ! -f $file_temp || ! -w $file_temp ]] && ((g_verbose)) && vMsg "Parameter error (temp file not a file or not writeable)" r

    ##((g_verbose)) && vMsg "Checking remote file against $file_local"

    if curl -sz "$file_local" \
            -H "$CURL_HEADER_USER_AGENT" \
            -H "$CURL_HEADER_CONTENT_TYPE" \
            -H "$CURL_HEADER_GITHUB_MEDIATYPE" \
            -L "$requested_url" \
            -o "$file_temp" 2> /dev/null
        then

        # Force an update to the access time of file_local
        if ! touch -ac -- "$file_local"
        then
            ((g_verbose)) && vMsg "Failed to update access time for $file_local" r
        fi

        # Use file -b to help determine the type of data received
        data_type=$(file -b "$file_temp" 2> /dev/null)

        ((g_verbose)) && vMsg "curl returned data_type: $data_type" g

        if (($(stat -c '%s' -- "$file_temp")))
        then
            if [[ -f $file_temp && -r $file_temp ]]
            then

                # Check the temporary file contents for some basic error responses
                # Not found
                downloaded_package_size_bytes=$(stat -c '%s' -- "$file_temp")
                if ((downloaded_package_size_bytes == 9))
                then
                    vMsg "Server responded 'Not Found'" r
                    CleanUp
                    return 1
                fi

                # Github API request rate limit exceeded
                if ((downloaded_package_size_bytes == 248))
                then
                    vMsg "Github API request rate limit exceeded. Try again later." r
                    CleanUp
                    return 1
                fi

                # If IsJSONminified returns success and the data type is json, run the
                # unminify script on the file.
                if [[ ${data_type,,} == *'json'* ]]
                then
                    if IsJSONminified "$file_temp"
                    then
                        if ! ReformatJSONUsingSed "$file_temp"
                        then
                            ((g_verbose)) && vMsg "ReformatJSONUsingSed returned failure" r
                            return 1
                        fi
                    fi
                else
                    ((g_verbose)) && vMsg "Data type is not JSON"
                fi

                # If the local file already exists, create a backup first
                [[ -f $file_local ]] && CreateBackup "$file_local"
                if cp -f -- "$file_temp" "$file_local"
                then
                    ##((g_verbose)) && vMsg "Copied $file_temp to $file_local" g
                    return 0
                else
                    vMsg "Failed to copy $file_temp to $file_local" r
                    return 1
                fi
            else
                vMsg "file_temp not found or not readable: $file_temp" r
                return 1
            fi
        else
            # remote file is not newer if curl returns success and the response is NULL
            ##((g_verbose)) && vMsg "Remote file is not newer"
            return 0
        fi
    else
        ((g_verbose)) && vMsg "curl returned failure" r
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Ensure critical paths exist and that the script has the required
#          permissions to each of them. Additionally, in case the shebang is
#          changed from /usr/bin/env bash, aliases for commands used by the
#          script are checked and unset if needed to avoid potential undefined
#          behavior.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
SetupEnvironment() {

    local -i flag_failed=0 count_success=0 count_failed=0
    local -a check_alias_commands=(curl sed tar gzip stat wc date du pgrep sort cmp envsubst trash file)

    # Check for and unset existing aliases for commands used in the script
    # that could cause undefined behavior
    # NOTE: This is not needed so long as the shebang remains /usr/bin/env bash
    for check_alias in "${check_alias_commands[@]}"
    do
        result=$(alias "$check_alias" 2>&1)
        if [[ $result == *"${check_alias}="* && $result != *'not found'* ]]
        then
            ##((g_verbose)) && vMsg "Found alias for $check_alias: $result" y
            vMsg "WARNING: Alias detected for $check_alias (it will be unset to avoid undefined behavior)" y
            if ! unalias "$check_alias"
            then
                ((g_verbose)) && vMsg "unalias $check_alias failed" r
                flag_failed=1
            fi
            count_failed=$(( count_failed + 1 ))
            continue
        fi
        ##((g_verbose)) && vMsg "No alias found for $check_alias" g
        count_success=$(( count_success + 1 ))
    done
    ##((g_verbose)) && vMsg "Checked for $(( count_success + count_failed )) aliases"

    # g_install_path
    if [[ -d $g_install_path ]]
    then
        ##((g_verbose)) && vMsg "Found existing install path at $g_install_path" g
        [[ ! -w $g_install_path ]] && { vMsg "No write access to: $g_install_path" r; flag_failed=1; }
    elif [[ ! -d $g_install_path ]]
    then
        if ! mkdir -p -- "$g_install_path" > /dev/null
        then
            vMsg "Failed to create: $g_install_path" r
            flag_failed=1
        fi
    fi

    # g_script_config_path
    if [[ -d $g_script_config_path ]]
    then
        [[ ! -w $g_script_config_path ]] && { vMsg "No write access to: $g_script_config_path" r; flag_failed=1; }
    elif [[ ! -d $g_script_config_path ]]
    then
        if ! mkdir -p -- "$g_script_config_path" > /dev/null
        then
            vMsg "Failed to create: $g_script_config_path" r
            flag_failed=1
        fi
    fi

    # g_script_cache_path
    if [[ -d $g_script_cache_path ]]
    then
        [[ ! -w $g_script_cache_path ]] && { vMsg "No write access to: $g_script_cache_path" r; flag_failed=1; }
    elif [[ ! -d $g_script_cache_path ]]
    then
        if ! mkdir -p -- "$g_script_cache_path" > /dev/null
        then
            vMsg "Failed to create: $g_script_cache_path" r
            flag_failed=1
        fi
    fi

    # g_file_script_config
    if [[ -f $g_file_script_config ]]
    then
        [[ ! -r $g_file_script_config ]] && { vMsg "No read access to: $g_file_script_config" r; flag_failed=1; }
        [[ ! -w $g_file_script_config ]] && { vMsg "No write access to: $g_file_script_config" r; flag_failed=1; }
    elif [[ ! -f $g_file_script_config ]]
    then
        if ! printf '' > "$g_file_script_config"
        then # NOTE: Do not : > here
            vMsg "Failed to create: $g_file_script_config" r
            flag_failed=1
        fi
    fi

    # g_temp_base_path
    if [[ -d $g_temp_base_path ]]
    then
        [[ ! -w $g_temp_base_path ]] && { vMsg "Invalid tmp_path path: $g_temp_base_path" r; flag_failed=1; }
    elif [[ ! -d $g_temp_base_path ]]
    then
        if ! mkdir -p -- "$g_temp_base_path" > /dev/null
        then
            vMsg "Failed to create: $g_temp_base_path" r
            flag_failed=1
        fi
    fi

    # Remove 0 size g_file_latest_json
    if [[ -f $g_file_latest_json ]]
    then
        if (( $(stat -c '%s' -- "$g_file_latest_json" 2> /dev/null) == 0 ))
        then
            ((g_verbose)) && vMsg "Removing 0 size g_file_latest_json" y
            if ! rm -f -- "$g_file_latest_json"
            then
                flag_failed=1
            fi
        fi
    fi

    # Remove 0 size g_file_releases_json
    if [[ -f $g_file_releases_json ]]
    then
        if (( $(stat -c '%s' -- "$g_file_releases_json" 2> /dev/null) == 0 ))
        then
            ((g_verbose)) && vMsg "Removing 0 size g_file_releases_json" y
            if ! rm -f -- "$g_file_releases_json"
            then
                flag_failed=1
            fi
        fi
    fi

    # Remove 0 size g_file_script_raw
    if [[ -f $g_file_script_raw ]]
    then
        if (( $(stat -c '%s' -- "$g_file_script_raw" 2> /dev/null) == 0 ))
        then
            ((g_verbose)) && vMsg "Removing 0 size g_file_script_raw" y
            if ! rm -f -- "$g_file_script_raw"
            then
                flag_failed=1
            fi
        fi
    fi

    if ((g_verbose))
    then
        vMsg "g_install_path set to      : $g_install_path"
        vMsg "g_script_config_path set to: $g_script_config_path"
        vMsg "g_script_cache_path set to : $g_script_cache_path"
        vMsg "g_file_script_config set to: $g_file_script_config"
        vMsg "g_temp_base_path set to    : $g_temp_base_path"
    fi

    # Create the sed script used to unminify JSON responses if it is not present
    CreateSedUnminifyJSONscript

    return $(( flag_failed ? 1 : 0 ))
}

################################################################################
# Purpose: Print release notes (body_text) for a specified version or all versions
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 (Success)
#          1 (Failure) Zero lines were read from g_file_latest_json, zero version
#                      matches occurred, or UpdateCachedGEReleases returned failure
ShowGEReleaseNotes() {

    local version=${1-} line_releases='' value_release_notes_url=''
    local -i flag_version_found=0 flag_show_all_versions=1 flag_url_found=0 flag_end=0 line_counter=0 version_counter=0

    # Determine whether to show all versions or a specified version
    if [[ -n ${version-} ]]
     then
        CleanUpVersion
        flag_show_all_versions=0
        ((g_verbose)) && vMsg "Getting release notes for version $version" g
    else
        ((g_verbose)) && vMsg "Showing release notes for all versions" g
        version=".*"
    fi

    if ! UpdateCachedGEReleases
    then
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status" y
    fi

    while IFS= read -r -- line_releases || [[ -n $line_releases ]]
    do
        ((line_counter++))
        [[ -z $line_releases ]] && continue

        #((g_verbose)) && vMsg "Checking: $line_releases"

        # Match a release URL and store it in value_release_notes_url
        # "html_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/5.9-GE-5-ST"
        # "html_url":  "https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/5.9-GE-5-ST"
        # "html_url":   "https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/5.9-GE-5-ST",
        if [[ ${line_releases//[[:space:]]} =~ ^.*\"html_url\":\"https://github.com/GloriousEggroll/proton-ge-custom/releases/tag/.*$ ]]
        then
            flag_url_found=1
            ##((g_verbose)) && vMsg "URL match ($line_counter): $line_releases"
            line_releases=${line_releases//[[:space:]]}
            line_releases=${line_releases//'",'}
            value_release_notes_url=${line_releases/#*'"html_url":"'}
            continue
        fi

        # NOTE: The regex must match all 3 of the following potential formats:
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name": "Proton-5.9-GE-5-ST.tar.gz"
        if ((flag_url_found))
        then
            #((g_verbose)) && vMsg "Checking regex: ^[[:space:]]*\"name\":[[:space:]]*\"Proton-${version}\.tar\.gz\".*$"
            if [[ ${line_releases//[[:space:]]} =~ ^.*\"name\":\"Proton-${version}\.tar\.gz\".*$ ]]
            then
                ((version_counter++))
                flag_version_found=1
                ((g_verbose)) && vMsg "Version match ($line_counter): $line_releases"
                flag_url_found=0
                line_releases=${line_releases//[[:space:]]}
                line_releases=${line_releases/#*'"name":"'}
                line_releases=${line_releases//'",'}
                line_releases=${line_releases//'.tar.gz'}
                echo "$line_releases  ($value_release_notes_url)"
                continue
            fi
        fi

        if ((flag_version_found))
        then
            # "body_text":"7-28-2020:
            if [[ ${line_releases//[[:space:]]} =~ ^.*\"body_text\":\".*$ ]]
            then
                [[ ${line_releases//[[:space:]]} == *\" ]] && { ((g_verbose)) && vMsg "body_text end marker found: $line_counter"; flag_end=1; }

                ##((g_verbose)) && vMsg "body_text before ($line_counter): $line_releases"

                # Fix if sed unminify script doesn't run (to process body_text)
                line_releases=${line_releases/#*'"body_text": "'}
                line_releases=${line_releases/#*'"body_text":"'}
                line_releases=${line_releases/#*'"body_text" : "'}
                line_releases=${line_releases/#*'"body_text" :"'}
                line_releases=${line_releases//'\n'/$'\n'}
                line_releases=${line_releases//'\"'/'"'}
                ((flag_end)) && line_releases=${line_releases%\"*}

                # Remove leading spaces
                while [[ ${line_releases:0:1} = [[:space:]] ]]
                do
                    line_releases=${line_releases:1}
                done

                ##((g_verbose)) && vMsg "body_text after ($line_counter): $line_releases"

                printf '%s\n' "$line_releases"
                continue
            fi
        fi

        ((flag_end)) && printf '\n'

        # If only showing a single version, break after all info for it has been printed
        if ((flag_end && ! flag_show_all_versions))
        then
            ##((g_verbose)) && vMsg "Breaking out of loop ($line_counter)"
            flag_end=0
            break
        fi
    done < "$g_file_releases_json"

    # Report if read read 0 lines
    if ((line_counter == 0))
    then
        ((g_verbose)) && vMsg "Zero lines read" r
        return 1
    fi

    # Report if no matches were found
    if ((version_counter == 0))
    then
        ((g_verbose)) && vMsg "Zero matches found" r
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Given a file/path (filesystem) and a unit (binary prefix), use stat
#          to calculate the remaining space on a filesystem by multiplying
#          the filesystem block size by the number of remaining blocks and
#          return the value in the unit requested.
# Input:   1 (required) File/path on the filesystem to check
#          1 (required) Binary prefix (see case below for supported formats)
# Output:  Integer value representing the space remaining in the unit requested
#          NOTE: Bash arithmatic is used because this script does not require
#                   the precision afforded by bc/etc.
# Return:  Return value of printf
# NOTE: bash arithmatic supports upto 1024^6/1024**6 (exbibyte)
# TODO: Add a third, optional parameter to request calculations using bc
SpaceRemaining() {

    local file_system=${1-} binary_prefix=${2-}
    local -i power_of=0 space_remaining=0

    [[ -z $file_system || -z $binary_prefix ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)" r; return 1; }

    [[ ! -d $file_system ]] && { ((g_verbose)) && vMsg "Parameter error (not a directory)" r; return 1; }

    case ${binary_prefix,,} in
        (b|byte|bytes) power_of=0; binary_prefix='bytes'; ;;
        (k|kib|kibi|kibibyte) power_of=1; binary_prefix='KiB' ;;
        (m|mib|mebi|mebibyte) power_of=2; binary_prefix='MiB' ;;
        (g|gib|gibi|gibibyte) power_of=3; binary_prefix='GiB' ;;
        (t|tib|tebi|tebibyte) power_of=4; binary_prefix='TiB' ;;
        (p|pib|pebi|pebibyte) power_of=5; binary_prefix='PiB' ;;
        (e|eib|exbi|exbibyte) power_of=6; binary_prefix='EiB' ;;
    esac

    # NOTE: stat --cached=never not available on Ubuntu 20.04.1 LTS
    space_remaining=$(( ($(stat -L -c '%s' -f -- "$file_system" 2>&1) * $(stat -L -c '%a' -f -- "$file_system" 2>&1)) / ( 1024 ** power_of ) ))

    ((g_verbose)) && vMsg "$space_remaining $binary_prefix remaining on $file_system"

    printf '%s' "$space_remaining"

    return
}

################################################################################
# Purpose: Remove g_script_cache_path g_script_config_path
# Input:   None
# Output:  None
# Return:  0 (Success) Both paths were successfully removed
#          1 (Failure) Failed to remove either path
UninstallScript() {

    local cache_size='error' config_size='error'
    local -i flag_failed=0

    cache_size=$(du -sh -- "$g_script_cache_path" 2> /dev/null)
    config_size=$(du -sh -- "$g_script_config_path" 2> /dev/null)

    if ((g_force))
    then
        # g_script_cache_path
        if ($g_command_rm -rf -- "$g_script_cache_path")
        then
            echo "Removed $g_script_cache_path (${cache_size%[[:space:]]*})"
        else
            vMsg "Failed to remove $g_script_cache_path" r
            flag_failed=1
        fi

        # g_script_config_path
        if ($g_command_rm -rf -- "$g_script_config_path")
        then
            echo "Removed $g_script_config_path (${config_size%[[:space:]]*})"
        else
            vMsg "Failed to remove $g_script_config_path" r
            flag_failed=1
        fi

        # Remove symlinks to this script
        if [[ -e "$HOME/.local/bin/$SCRIPT_FULL_NAME" ]]
        then
            if rm -f -- "$HOME/.local/bin/$SCRIPT_FULL_NAME"
            then
                printf '%s\n' "Removed symlink at $HOME/.local/bin/$SCRIPT_FULL_NAME"
            else
                printf '%s\n' "Removal of symlink at $HOME/.local/bin/$SCRIPT_FULL_NAME failed. Manual removal required."
            fi
        fi
        if [[ -e "/usr/local/sbin/$SCRIPT_FULL_NAME" ]]
        then
            if sudo rm -if -- "/usr/local/sbin/$SCRIPT_FULL_NAME"
            then
                printf '%s\n' "Removed dead symlink at /usr/local/sbin/$SCRIPT_FULL_NAME"
            else
                printf '%s\n' "Removal of dead symlink at /usr/local/sbin/$SCRIPT_FULL_NAME failed. Manual removal required."
            fi
        fi
    else
        vMsg "Force mode must be enabled for this feature" y
    fi

    return $(( flag_failed ? 1 : 0 ))

}


################################################################################
# Purpose: Call the RequestURL function to update both g_file_latest_json and
#          g_file_releases_json if the remote versions are newer and a
#          configurable interval has passed.
# Input:   None
# Output:  None
# Return:  0 = (Success) Both files were successfully updated or the access
#                        interval has not passed for both files.
#          1 = (Failure) RequestURL returned 1 for either file.
UpdateCachedGEReleases() {

    local flag_requesturl_failure=0

    ##((g_verbose)) && {
    ##    vMsg "g_latest_version_url: $g_latest_version_url"
    ##    vMsg "g_file_latest_json: $g_file_latest_json"
    ##}

    # Check the access time of the local file and if the interval has passed
    # call RequestURL to update the file (if the remote version is newer).
    if CheckAccessTime "$g_file_latest_json" "$g_releases_update_interval"
    then
        if ! RequestURL "$g_latest_version_url" "$g_file_latest_json"
        then
            flag_requesturl_failure=1
        fi
    fi

    ##((g_verbose)) && {
    ##    vMsg "g_releases_url: $g_releases_url"
    ##    vMsg "g_file_releases_json: $g_file_releases_json"
    ##}

    # Check the access time of the local file and if the interval has passed
    # call RequestURL to update the file (if the remote version is newer).
    if CheckAccessTime "$g_file_releases_json" "$g_releases_update_interval"
    then
        if ! RequestURL "$g_releases_url" "$g_file_releases_json"
        then
            flag_requesturl_failure=1
        fi
    fi

    if ((flag_requesturl_failure))
    then
        ((g_verbose)) && vMsg "RequestURL returned failure status" y
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Check for the latest version and if it is not installed install it
#          If force mode is active and the latest version is already installed,
#          it will first be removed and then re-installed.
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = Failure
UpdateGEVersion() {

    # Get the latest g_file_latest_json if the remote file is newer
    if GetLatestGEVersion
    then
        # Latest version is installed and force mode is not active
        if IsInstalled "$g_latest_version" && ((! g_force))
        then
            echo "The latest version Proton-${g_latest_version} is installed"
        # Latest version is installed and force mode is active
        elif ((g_force)); then
            # NOTE: InstallGEVersion also verifys that force mode is active
            if InstallGEVersion "$g_latest_version"
            then
                echo "Update to $g_latest_version succeeded"
            else
                echo "Update to $g_latest_version failed"
                return 1
            fi
        # Latest version is not installed
        else
            echo "The latest version $g_latest_version is not installed"
            if InstallGEVersion "$g_latest_version"
            then
                echo "Update to $g_latest_version succeeded"
            else
                echo "Update to $g_latest_version failed"
                return 1
            fi
        fi
    else
        # GetLatestGEVersionInfo failed
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status" y
        echo "Update to $g_latest_version failed"
        return 1
    fi

    return 0
}

################################################################################
# Purpose: Verify all installed versions or a specified version by comparing
#          each file from the saved package to the installed file and report
#          the number of files that match, are missing, and don't match to stdout.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 Failure
# NOTE: __pycache__ (inside the proton-ge-custom installation folder) folders
#       are created at runtime and will not be present in the saved packages.
# NOTE: bash 5+ is required for EPOCHSECONDS
# NOTE: bash 4.2+ is required for printf $()T
VerifyGEInstall() {

    local version=${1-} node path temp_path file_extracted file_installed saved_cmp_alias=''
    local -i expected_size_bytes=0 temp_base_path_remaining_bytes=0 match_counter=0 missing_counter=0 mismatch_counter=0 files_arrays_count_match=0 total_files=0 counter_extracted=0 counter_installed=0 start_time_seconds=0 end_time_seconds=0 progress_percent=0 prev_progress=1 flag_missing_command=0
    local -a files_extracted files_installed

    [[ -n $version ]] && CleanUpVersion

    # If g_temp_base_path = g_install_path
    # WARNING: Setting g_temp_base_path and g_install_path to the same path would cause
    #          this function to overwrite installed versions and then attempt
    #          to compare those extracted files (and any others already there) to themselves.
    if [[ $g_temp_base_path -ef $g_install_path ]]
    then
        vMsg "Setting tmp_path and install_path to the same path is not supported" r
        return 1
    fi

    # Required external commands
    if ! command -v cmp > /dev/null
    then
        echo "Command cmp is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v sort > /dev/null
    then
        echo "Command sort is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v date > /dev/null
    then
        echo "Command date is required to use this function"
        flag_missing_command=1
    fi

    # If any one required command is missing
    ((flag_missing_command)) && return 1

    # Check for install paths that don't have a saved package, download if missing
    for node in "$g_install_path/Proton-"*
    do
        if [[ -d $node ]]
        then
            # Fix for Proton-5.0-GE-1-no-mouse-coord
            [[ ${node##*/} = 'Proton-5.0-GE-1' ]] && node=${node//'Proton-5.0-GE-1'/'Proton-5.0-GE-1-no-mouse-coord'}

            # Verify that it is installed
            if IsInstalled "${node##*/}"
            then
                # If no saved package exists for this version
                if [[ ! -f $g_install_path/${node##*/}.tar.gz ]]
                then
                    echo "Package not found for installed version ${node##*/}"
                    if ! DownloadGEPackage "${node##*/Proton-}"
                    then
                        return 1
                    fi
                fi
            fi
        fi
    done

    # For each saved package available, check each file in the package against the installed file
    for node in "$g_install_path"/Proton-${version:-*}.tar.gz
    do
        [[ -z $node ]] && continue
        if [[ -f $node ]]
        then
            version=${node##*/}
            CleanUpVersion
            ##((g_verbose)) && vMsg "Found a package for version $version" g
            if ! IsInstalled "$version"
            then
                ##((g_verbose)) && vMsg "Version $version is not installed"
                continue
            else
                ##((g_verbose)) && vMsg "Version $version is installed" g

                # Check for enough free space on the filesystem that contains tmp_path
                IFS=$'\t' read -r -- expected_size_bytes path < <(du -bs -- "$g_install_path/Proton-${version//-no-mouse-coord}")
                temp_base_path_remaining_bytes=$(SpaceRemaining "$g_temp_base_path" "b")

                ##((g_verbose)) && {
                ##    vMsg "$version extracted size: $expected_size_bytes bytes"
                ##    vMsg "$g_temp_base_path remaining bytes: $temp_base_path_remaining_bytes"
                ##}

                if ((expected_size_bytes > temp_base_path_remaining_bytes))
                then
                    vMsg "WARNING: Not enough free space at $g_temp_base_path to continue" r
                    CleanUp
                    return 1
                fi

                # Reset for each package to check
                CleanUp
                temp_path=$(MkTempPath)
                match_counter=0
                mismatch_counter=0
                missing_counter=0
                progress_percent=0
                prev_progress=1
                total_files=0
                counter_extracted=0
                counter_installed=0
                files_installed=()
                files_extracted=()

                # Extract the package to a temporary path
                if ! ExtractGEPackage "$version" "$temp_path"
                then
                    return 1
                fi

                # Create two indexed arrays, each containing a seperate list of files,
                # one from the extracted path and the other from the installed path
                echo "Indexing files to compare"

                # Array of extracted files
                while IFS= read -r file_extracted
                do
                    [[ -n $file_extracted ]] && files_extracted+=("$file_extracted")
                done < <(find "$temp_path/Proton-${version}/" -type f ! -iwholename '*__pycache__*' 2> /dev/null | LC_ALL=C sort)

                # Array of installed files
                while IFS= read -r file_installed
                do
                    [[ -n $file_installed ]] && files_installed+=("$file_installed")
                done < <(find "$g_install_path/Proton-${version}/" -type f ! -iwholename '*__pycache__*' 2> /dev/null | LC_ALL=C sort)

                # Report the number of files found in each path
                echo "Found ${#files_extracted[@]} (extracted) and ${#files_installed[@]} (installed) files"

                # Based on array element sizes, decide on a method to compare files
                # The faster method is a one-to-one comparison of each array element.
                # The slower method takes each element of the extracted array and then searches through
                # the entire installed array until it finds a matching file name.
                if (( ${#files_extracted[@]} != ${#files_installed[@]} ))
                then
                    ##echo "Using slower method for comparing"
                    files_arrays_count_match=0
                else
                    ##echo "Using faster method for comparing"
                    files_arrays_count_match=1
                fi

                printf '%s\033[s' "Comparing files"

                # Begin comparing, using the faster method
                # If the number of elements match
                if ((files_arrays_count_match == 1))
                then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"
                    do
                        cmp -s -- "${files_extracted[counter_extracted]}" "${files_installed[counter_extracted]}"
                        case $? in
                            (0) ((match_counter++)) ;;
                            (1) ((mismatch_counter++)) ;;
                            (2) ((missing_counter++)) ;;
                        esac

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))

                        # Only update the progress_percent when it actually changes
                        ((progress_percent != prev_progress)) && printf '\033[u\033[s%s' "... ${progress_percent}%"
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)

                # Begin comparing, using the slower method
                elif ((files_arrays_count_match == 0))
                then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"
                    do
                        # Strip away the part of the path that is different for the current file
                        sCOMPARE_EXTRACTED=${files_extracted[counter_extracted]/#$temp_path\/}
                        for counter_installed in "${!files_installed[@]}"
                        do
                            # Strip away the part of the path that is different for the current file
                            sCOMPARE_INSTALLED=${files_installed[counter_installed]/#$g_install_path\/}
                            if [[ $sCOMPARE_INSTALLED = "$sCOMPARE_EXTRACTED" ]]
                            then
                                cmp -s -- "${files_installed[counter_installed]}" "${files_extracted[counter_extracted]}"
                                case $? in
                                    (0) ((match_counter++)) ;;
                                    (1) ((mismatch_counter++)) ;;
                                    (2) ((missing_counter++)) ;;
                                esac
                                unset 'files_installed[counter_installed]'
                            fi
                        done

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))

                        # Only update the progress_percent when it actually changes
                        ((progress_percent != prev_progress)) && printf '\033[u\033[s%s' "... ${progress_percent}%"
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)
                fi

                # Restore saved cmp alias
                if [[ -n $saved_cmp_alias ]]
                then
                    ##echo "Restoring saved alias for command cmp"
                    if ! $saved_cmp_alias
                    then
                        vMsg "Failed to restore alias for 'cmp'" r
                    fi
                fi

                printf "\033[u\033[0K%s\n" ". Finished in $(( end_time_seconds - start_time_seconds )) seconds."

                # Report
                echo "$match_counter files match. $missing_counter files are missing. $mismatch_counter do not match."

                if ((match_counter > 0 && missing_counter == 0 && mismatch_counter == 0))
                then
                    echo "Installation for version $version appears ok"
                    ((g_verbose)) && vMsg "$version appears ok"
                elif ((missing_counter > 0 || mismatch_counter > 0))
                then
                    printf '%s\n%s\n' \
                           "WARNING: Version $version has missing or potentially corrupt files." \
                           "${0##*/} -R $version -i $version to reinstall it (add -f to download a new package)"
                    if ((g_verbose))
                    then
                        vMsg "Something appears wrong with: $version" r
                        vMsg "match_counter               : $match_counter" y
                        vMsg "missing_counter             : $missing_counter" y
                        vMsg "mismatch_counter            : $mismatch_counter" y
                    fi
                fi
            fi
        fi
    done

    return 0
}

################################################################################
# Purpose: Print a supplied message to stderr and prefix that message with the
#          line number that called this function followed by a function trace
#          that excludes "main". Similar to the caller Bash built-in.
# Input:   1 (required) A string (the message to output)
#          2 (optional) Message type (color) [g]reen (success), [y]ellow (warning),
#                       [r]ed (Failure), [b]lue (info)
# Output:  None
# Return:  0 (Success) Always
vMsg() {

    local msg=${1-} type=${2:-b} # default color: blue/info
    local -i i=0

    [[ -z ${msg-} ]] && { echo "($LINENO)[vMsg]: Parameter error (NULL)" 1>&2; return 1; }

    # Disable color output for test script (stderr is redirected to a log file)
    # shellcheck disable=SC2034
    if (( ${GEIM_TESTS-0} ))
    then
        g_color_red=''
        g_color_green=''
        g_color_yellow=''
        g_color_blue=''
        g_color_magenta=''
        g_color_cyan=''
        g_color_white=''
        g_color_reset=''
    fi

    # Calling line number
    printf "${g_color_cyan}%s${g_color_green}%s${g_color_cyan}%s${g_color_reset}" "(" "${BASH_LINENO[0]}" ")[" 1>&2

    # Count backwards iterating through the elements of the FUNCNAME array, skipping the 'last' two.
    for (( i=$(( ${#FUNCNAME[@]} - 2 )); i>1; i-- ))
    do
        # Print the function name from the array with a comma suffix
        printf "${g_color_magenta}%s${g_color_cyan}%s${g_color_reset}" "${FUNCNAME[i]}" "," 1>&2
    done

    # Don't print a comma at the end of the last function
    printf "${g_color_magenta}%s${g_color_cyan}%s${g_color_reset}" "${FUNCNAME[i]}" "]: " 1>&2

    # Message with color based on type (default: blue/info)
    case ${type,,} in
        (b|blue|i|info)
            # Blue / Info
            printf "${g_color_blue}%s${g_color_reset}\n" "$msg" 1>&2
        ;;
        (g|green|s|success)
            # Green / Success
            printf "${g_color_green}%s${g_color_reset}\n" "$msg" 1>&2
        ;;
        (y|yellow|w|warning)
            # Yellow / Warning
            printf "${g_color_yellow}%s${g_color_reset}\n" "$msg" 1>&2
        ;;
        (r|red|e|error|f|failure)
            # Red / Error
            printf "${g_color_red}%s${g_color_reset}\n" "$msg" 1>&2
        ;;
    esac

    return 0
}

################################################################################
# Purpose: Supervise and control the flow of the script depending on how it was invoked
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  0 (Success)
#          1 (Failure) A called function returned failure (>0)
Main() {

    local caller=${0:-}

    # Do not run as root
    if (( ! $(id -u) )) || [[ $EUID -eq 0 ]]
    then
        echo "This script requires non-root effective permissions"
        exit 1
    fi

    # Parse script parameters and arguments, set global variables
    if ! ParseParameters "$@"
    then
        ((g_verbose)) && vMsg "ParseParameters returned failure status"
        exit 1
    fi

    # Report if verbose mode is enabled
    ((g_verbose)) && vMsg "$SCRIPT_FULL_NAME v$SCRIPT_VERSION verbose mode enabled" g

    # If no parameters were supplied, show help
    # If -z was supplied report some basic information
    # Enables invoking the script with only -z (eg. "ge-install-manager -z") to check
    # basic requirements and report if any are not found
    if [[ ${1-unset} = 'unset' || -z $1 ]] || [[ ${#1} -eq 2 && $1 = '-z' ]]
    then
        CheckRequirements # Print any required commands that are not found
        ShowHelp
        exit 0
    fi

    # Print help
    if ((g_show_help))
    then
        CheckRequirements
        ShowHelp
    fi

    # Print usage
    if ((g_show_usage))
    then
        CheckRequirements
        ShowUsage
    fi

    # If ShowHelp and/or ShowUsage was invoked, exit
    ((g_show_help || g_show_usage)) && exit 0

    # Check command requirements and set global variables
    if CheckRequirements
    then
        if ParseConfigFile
        then
            if ! SetupEnvironment
            then
                exit 1
            fi
        else
            exit 1
        fi
    else
        exit 1
    fi

    # Ask to create a symlink in ~/.local/bin or /usr/local/sbin if automated mode is off, it is part of PATH, and it doesn't exist already
    # If the user chooses no, create an empty file "nolocalbin"/"nolocalsbin" in g_script_cache_path to ensure we don't ask again
    if (( ! g_automated_mode )) && [[ $caller != *'bin'*"$SCRIPT_FULL_NAME" ]] && [[ ! -e "$HOME/.local/bin/$SCRIPT_FULL_NAME" || ! -e "/usr/local/sbin/$SCRIPT_FULL_NAME" ]]
    then
        # ~/.local/bin
        if [[ $PATH == *'.local/bin'* && ! -e "$HOME/.local/bin/$SCRIPT_FULL_NAME" && ! -e "/usr/local/sbin/$SCRIPT_FULL_NAME" && ! -e "$g_script_cache_path"/nolocalbin ]]
        then
            while :
            do
                read -rp "Would you like to create a symlink to this script ($(realpath "$0")) at $HOME/.local/bin/$SCRIPT_FULL_NAME? " </dev/tty
                case ${REPLY,,} in
                    (y|yes)
                        mkdir -p "$HOME/.local/bin"
                        if ln -s "$(realpath "$caller")" "$HOME/.local/bin/$SCRIPT_FULL_NAME"
                        then
                            printf '%s\n' "Symlink created successfully"
                        else
                            printf '%s\n' "Symlink creation failed"
                        fi
                        break
                    ;;
                    (n|no)
                        if touch "$g_script_cache_path"/nolocalbin
                        then
                            printf '%s\n' "You will not be asked again. Removing $g_script_cache_path/nolocalbin or running the uninstall function (-D) will reset this."
                        fi
                        break
                    ;;
                    (*)
                        printf '%s\n' "Enter (y)es or (n)o"
                    ;;
                esac
            done
        fi

        # /usr/local/sbin
        if [[ $PATH == *'usr/local/sbin'* && ! -e "/usr/local/sbin/$SCRIPT_FULL_NAME" && ! -e "$HOME/.local/bin/$SCRIPT_FULL_NAME" && ! -e "$g_script_cache_path"/nolocalsbin ]]
        then
            while :
            do
                read -rp "Would you like to create a symlink to this script ($(realpath "$0")) at /usr/local/sbin/$SCRIPT_FULL_NAME (this will require sudo)? " </dev/tty
                case ${REPLY,,} in
                    (y|yes)
                        mkdir -p "$HOME/.local/bin"
                        if sudo ln -s "$(realpath "$caller")" "/usr/local/sbin/$SCRIPT_FULL_NAME"
                        then
                            printf '%s\n' "Symlink created successfully"
                        else
                            printf '%s\n' "Symlink creation failed"
                        fi
                        break
                    ;;
                    (n|no)
                        touch "$g_script_cache_path"/nolocalsbin
                        printf '%s\n' "You will not be asked again. Removing $g_script_cache_path/nolocalsbin or running the uninstall function (-D) will reset this."
                        break
                    ;;
                    (*)
                        printf '%s\n' "Enter (y)es or (n)o"
                    ;;
                esac
            done
        fi
    fi

    # If -u and/or -U are used, check for a script update and report
    if ((g_check_update || g_update))
    then
        if (( g_script_update_check ))
        then
            if CheckForScriptUpdate
            then
                ((g_verbose)) && vMsg "The latest version of the script is running" g
            else
                echo "There is a script update available ($PROJECT_URL)"
            fi
        else
            ((g_verbose)) && vMsg "Script update skipped due to global config g_script_update_check" y
        fi
    fi

    # Check if the latest release is installed
    if ((g_check_update && ! g_update))
    then
        if GetLatestGEVersion
        then
            if IsInstalled "$g_latest_version"
            then
                echo "The latest version Proton-${g_latest_version} is installed"
            else
                echo "The latest version Proton-${g_latest_version} is not installed"
            fi
        fi
    fi

    # Print versions available to install
    ((g_list_available_versions)) && ListAvailableGEVersions

    # Print release notes for all release versions
    if ((g_show_all_release_notes))
    then
        if ! ShowGEReleaseNotes && [[ -z ${version-} ]]
        then
            echo "Release notes unavailable"
        fi
    fi

    # Print release notes for a specified version
    if ((g_show_release_notes && ! g_show_all_release_notes)) && [[ -n $g_show_release_notes_version ]]
    then
        if ! ShowGEReleaseNotes "$g_show_release_notes_version"
        then
            echo "Release notes unavailable"
        fi
    fi

    # Remove install path if force mode is active
    if ((g_remove_install_path && g_force))
    then
        if IsSteamRunning
        then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    # If remove install path was requested but force mode is not active
    elif ((g_remove_install_path && ! g_force))
    then
        echo "-f must be combined with -X to confirm that you are sure"
    fi

    # Remove all saved packages if remove install path was not requested
    if ((g_remove_all_saved_packages && ! g_remove_install_path && g_force))
    then
        RemoveAllSavedPackages
    elif ((g_remove_all_saved_packages && ! g_remove_install_path && ! g_force))
    then
        echo "-f must be combined with -x to confirm that you are sure"
    fi

    # Uninstall the script (remove all files created by it, excluding saved packages/installed versions)
    if ((g_uninstall_script && g_force))
    then
        UninstallScript
    elif ((g_uninstall_script && ! g_force))
    then
        echo "-f must be combined with -D to confirm that you are sure"
    fi

    # Remove an installed version if remove install path was not requested
    if ((g_remove_installed_version && ! g_remove_install_path))
    then
        RemoveGEVersion "$g_remove_version" # NOTE: g_remove_version is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif ((g_remove_installed_version))
    then
        echo "Remove installed version skipped (remove install path was requested)"
    fi

    # Remove a saved package if both remove install path and remove all saved packages was not requested
    if ((g_remove_saved_package && ! g_remove_install_path && ! g_remove_all_saved_packages))
    then
        RemoveSavedPackage "$g_remove_saved_version" # NOTE: g_remove_version is set in getops
    elif ((g_remove_saved_package))
    then
        echo "Remove saved package skipped (remove install path or remove all saved packages was requested)"
    fi

    # Download a package
    ((g_download)) && {
        if ! DownloadGEPackage "$g_download_version"
        then # NOTE: g_download_version is set in getops
            echo "Download failed"
        fi
    }

    # Update to the latest release
    ((g_update)) && UpdateGEVersion

    # Install a package
    ((g_install)) && InstallGEVersion "$g_install_version" # NOTE: g_install_version is set in getops

    # List installed versions
    ((g_list_installed_versions)) && ListInstalledGEVersions

    # Report entire g_install path disk usage and file count
    ((g_report_install_path_usage)) && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    ((g_report_version_usage)) && ReportGEDiskUsage "$g_report_version"

    # Run verify if remove install path and remove saved packages wasn't requested
    # TODO: add support to verify even if remove saved packages and/or remove install path was invoked
    #       so long as some sort of install was also requested. Additionally, maybe support installing a version
    #       that is not installed when verify is called and force mode is active.
    ((g_verify && ! g_remove_install_path && ! g_remove_all_saved_packages)) && VerifyGEInstall "${g_verify_version-}"

    return 0
}

################################################################################
# Purpose: Run the function CleanUp on SIGEXIT
#          Save the exit status of the last executed command before invoking
#          the CleanUp function and exit with that status instead.
trap 'g_real_exit_status=$?; CleanUp; exit $g_real_exit_status' EXIT

################################################################################
# Purpose: Run the function CleanUp if the process group received SIGINT
#          This needs to be a seperate trap to properly handle SIGINT.
trap 'g_flag_sigint_caught=1; CleanUp' INT

################################################################################
# Call the function Main and pass it all of the positional parameters

Main "$@"

# "The last ever dolphin message was misinterpreted as a surprisingly
#  sophisticated attempt to do a double-backwards-somersault through a hoop
#  whilst whistling the ‘Star Spangled Banner’, but in fact the message was
#  this: So long and thanks for all the fish."
#                      ~Douglas Adams, The Hitchhiker's Guide to the Galaxy
