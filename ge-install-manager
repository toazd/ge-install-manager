#!/usr/bin/env bash
#shellcheck disable=SC2155
# https://github.com/koalaman/shellcheck/wiki/SC2155

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Maybe "geim" would be better?                                         #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

set +e # WARNING DO NOT set -e

###############################################################################
# Global variables
sSCRIPT_VERSION="0.7.1"
sSCRIPT_CODENAME="Cochrane Bonaventure"
sGE_INSTALL_PATH="$HOME"/.steam/root/compatibilitytools.d
# JSON data sources
sGE_LATEST_VERSION_URL="https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest"
sGE_RELEASES_URL="https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases"
# HTML data sources
# https://github.com/GloriousEggroll/proton-ge-custom/releases
# https://github.com/GloriousEggroll/proton-ge-custom/tags
sFILE_LATEST_JSON="$sGE_INSTALL_PATH/latest.json"
sFILE_RELEASES_JSON="$sGE_INSTALL_PATH/releases.json"
# NOTE using a custom user-agent as recommended by the api docs, causes the response to be minified JSON of which this script is incompatible with
#sCURL_HEADER_USERAGENT="User-Agent: ge-install-manager/0.7.1"
sCURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
sGE_LATEST_VERSION=''
sCOMMAND_RM="rm" # command 'trash' replaces 'rm' if it is found
# some script functionality depends on the following being initiaized as 0
iFORCE=0
iDEBUG=0
iDOWNLOAD=0
iINSTALL=0
iREMOVE=0
iUPDATE=0
iFINAL_CLEANUP=0
iREMOVE_INSTALL_PATH=0
iREMOVE_SAVED_PACKAGES=0
iLIST_INSTALLED_GE_VERSIONS=0
iREPORT_VERSION_USAGE=0
iREPORT_INSTALL_PATH_USAGE=0
iSHOW_HELP=0
iSHOW_USAGE=0
iCHECK_UPDATE=0
OPTERR=1 # make sure it's on

###############################################################################
# TODO
ShowHelp() {
    cat <<END_OF_HELP

    $(basename "$0")  v$sSCRIPT_VERSION "$sSCRIPT_CODENAME"

    Required:       Bash 3.2+(TBD), curl, tar, gzip, stat
    Optional:       du, find, and wc (for -s|-S)
                    ps (is steam running)
                    trash (used instead of rm)

    Install path:          $sGE_INSTALL_PATH
    Latest version URL:    $sGE_LATEST_VERSION_URL
    Releases URL:          $sGE_RELEASES_URL

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
                      Combine with -f to also remove the saved package or to remove a package
                      if the install path was already removed for <version>
    -d <version>  - Download the package for <version> and save it to the install path
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      -f is also required to confirm that you are sure
    -f            - Force install, upgrade, or remove
                      Combined with -u and/or -i, remove saved package and download a new copy
    -z            - Enable debug mode
                      Enable extra output messages and preserve any temporary files created

END_OF_HELP

    return 0
}

###############################################################################
# TODO
ShowUsage() {
    cat <<END_OF_USAGE
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle, Report environment info (-fzZ), Show help,
      Show usage, Debug toggle, Check for latest release, Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Download, Update, Install, List installed,
      Report install path usage,
      Report specific version usage

END_OF_USAGE

    return 0
}

###############################################################################
# Sets the global variable sGE_LATEST_VERSION to the latest version
# TODO *might* want to check releases if latest fails.
GetLatestGEVersion() {

    # WARNING DO NOT make this local
    sGE_LATEST_VERSION=''

    if UpdateSavedGELatestRelease; then
        while IFS= read -r; do
            # WARNING do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST",
            #         they are not always the same name as the package
            # "name": "Proton-5.9-GE-5-ST.tar.gz",
            [[ $REPLY =~ ^.*\"name\":[[:space:]]\"Proton-.*\.tar\.gz\",$ ]] && {
                ((iDEBUG)) && echo "$LINENO GetLatestGEVersion: matched line \"$REPLY\"" 1>&2
                sGE_LATEST_VERSION=${REPLY#*[[:space:]]\"name\":[[:space:]]\"Proton-}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION%.tar.gz\",}
                ((iDEBUG)) && echo "$LINENO GetLatestGEVersion: sGE_LATEST_VERSION set to \"$sGE_LATEST_VERSION\"" 1>&2
                break
            }
        done < "$sFILE_LATEST_JSON"

        [[ -z $sGE_LATEST_VERSION ]] && {
            ((iDEBUG)) && echo "$LINENO GetLatestGEVersion: interal error, sGE_LATEST_VERSION is sNULL" 1>&2
            return 1
        }
    else
        ((iDEBUG)) && echo "$LINENO GetLatestGEVersion: UpdateSavedGELatestRelease returned failure status" 1>&2
        return 1
    fi

    return 0
}

###############################################################################
# Retrieve "latest" JSON from sGE_LATEST_VERSION_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGELatestRelease() {

    local sGE_LATEST_RELEASE_JSON=''

    ((iDEBUG)) && echo "$LINENO UpdateSavedGELatestRelease: checking if \"$sGE_LATEST_VERSION_URL\" is newer than \"$sFILE_LATEST_JSON\"" 1>&2
    sGE_LATEST_RELEASE_JSON=$(curl -sz "$sFILE_LATEST_JSON" -H "$sCURL_HEADER_GITHUB_MEDIATYPE" -L "$sGE_LATEST_VERSION_URL" -o - 2>/dev/null)

    if [[ -z $sGE_LATEST_RELEASE_JSON ]]; then
        ((iDEBUG)) && echo "$LINENO UpdateSavedGELatestRelease: curl returned NULL (remote mtime is not newer than saved mtime)" 1>&2
        if [[ ! -f $sFILE_LATEST_JSON ]]; then
            echo "$LINENO UpdateSavedGELatestRelease: No new release found and $sFILE_LATEST_JSON not found. Is \"$sGE_LATEST_VERSION_URL\" a valid URL?" 1>&2
            return 1
        fi
    elif [[ -n $sGE_LATEST_RELEASE_JSON ]]; then
        ((iDEBUG)) && echo "$LINENO UpdateSavedGELatestRelease: curl response was not empty (remote mtime is newer than saved mtime)" 1>&2
        [[ -f $sFILE_LATEST_JSON.bak ]] && $sCOMMAND_RM "$sFILE_LATEST_JSON".bak
        [[ -f $sFILE_LATEST_JSON ]] && mv "$sFILE_LATEST_JSON" "$sFILE_LATEST_JSON".bak
        printf '%s' "$sGE_LATEST_RELEASE_JSON" > "$sFILE_LATEST_JSON"
    fi

    return 0
}

###############################################################################
# Retrieve "releases" JSON from sGE_RELEASES_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGEReleases() {

    local sGE_RELEASES_JSON=''

    # BUG updates to download_count in remote releases cause curl -z to download a new version much more often than is needed
    ((iDEBUG)) && echo "$LINENO UpdateSavedGEReleases: checking if \"$sGE_RELEASES_URL\" is newer than \"$sFILE_RELEASES_JSON\"" 1>&2
    sGE_RELEASES_JSON=$(curl -sz "$sFILE_RELEASES_JSON" -H "$sCURL_HEADER_GITHUB_MEDIATYPE" -L "$sGE_RELEASES_URL" -o - 2>/dev/null)

    if [[ -z $sGE_RELEASES_JSON ]]; then
        ((iDEBUG)) && echo "$LINENO UpdateSavedGEReleases: curl returned NULL (remote mtime is not newer than saved mtime)" 1>&2
        if [[ ! -f $sFILE_RELEASES_JSON ]]; then
            echo "$LINENO UpdateSavedGEReleases: No new release and $sFILE_RELEASES_JSON not found. Is \"$sGE_RELEASES_URL\" a valid URL?" 1>&2
            return 1
         fi
    elif [[ -n $sGE_RELEASES_JSON ]]; then
        ((iDEBUG)) && echo "$LINENO UpdateSavedGEReleases: curl response was not empty (remote mtime is newer than saved mtime)" 1>&2
        [[ -f $sFILE_RELEASES_JSON.bak ]] && $sCOMMAND_RM "$sFILE_RELEASES_JSON".bak
        [[ -f $sFILE_RELEASES_JSON ]] && mv "$sFILE_RELEASES_JSON" "$sFILE_RELEASES_JSON".bak
        printf '%s' "$sGE_RELEASES_JSON" > "$sFILE_RELEASES_JSON"
    fi

    return 0
}

###############################################################################
# Attempt to download a package (Proton*.tar.gz) using a tmp path.
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
DownloadGEPackage() {

    local sVERSION=$(CleanUpVersion "$1")
    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "$LINENO RemoveGEVersion: sVERSION is null" 1>&2
        return 1
    }
    local sTMP_DIR=$(mktemp -qd --tmpdir "$(basename "$0" .sh)".tmp.XXXXXXXXXX)
    local sTMP_PACKAGE=$sTMP_DIR/Proton-${sVERSION}.tar.gz
    local sGE_DOWNLOAD_URL=$(QueryGEAttribute "$sVERSION" "browser_download_url")
    local sSIZE_BYTES=''

    [[ -z $sGE_DOWNLOAD_URL ]] && {
        ((iDEBUG)) && "$LINENO DownloadGEPackage: sVERSION is NULL" 1>&2
        return 1
    }

    echo "Downloading \"$sGE_DOWNLOAD_URL\""
    if curl -# -L "$sGE_DOWNLOAD_URL" -o "$sTMP_PACKAGE"; then
        sSIZE_BYTES=$(stat -c '%s' "$sTMP_PACKAGE")
        ((iDEBUG)) && echo "$LINENO DownloadGEPackage: Package size in bytes: $sSIZE_BYTES" 1>&2
        if [[ $sSIZE_BYTES -eq 9 ]] && [[ $(cat "$sTMP_PACKAGE" 2>/dev/null) = "Not Found" ]]; then
            echo "$LINENO DownloadGEPackage: remote package for version \"$sVERSION\" not found"
            CleanUp
            return 1
        # TODO attempt download again automagically? how to tell if it's a transient problem or not?
        fi
        if [[ $sSIZE_BYTES = "$(QueryGEAttribute "$sVERSION" "size")" ]]; then
            echo "Downloaded package size matches the expected size"
        else
            printf '%s\n%s\n' \
                   "$LINENO DownloadGEPackage: downloaded file size and expected size do not match" \
                   "$LINENO DownloadGEPackage: (\"$sSIZE_BYTES\" != \"$(QueryGEAttribute "$sVERSION" "size")\")" 1>&2
           CleanUp
           return 1
        fi
        ((iDEBUG)) && echo "$LINENO DownloadGEPackage: Copying package \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\"" 1>&2
        if cp "$sTMP_PACKAGE" "$sGE_INSTALL_PATH"; then
            ((iDEBUG)) && echo "$LINENO DownloadGEPackage: Package copied successfully" 1>&2
            echo "Download succeeded"
            CleanUp
        else
            ((iDEBUG)) && echo "$LINENO DownloadGEPackage: Copy package \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\" failed" 1>&2
            echo "Download failed"
            CleanUp
            return 1
        fi
    else
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Install a GE version using either a saved package or downloading a new one
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
# NOTE sINSTALL_VERSION is set in getops when -i is invoked
# NOTE If -u and -i are both invoked, the update will run first and then the install, if needed
InstallGEVersion() {

    local sVERSION=''

    if [[ $iUPDATE -eq 1 ]]; then
        [[ -z $sGE_LATEST_VERSION ]] && GetLatestGEVersion || return 1
        sVERSION=$sGE_LATEST_VERSION
    elif [[ $iUPDATE -eq 0 ]]; then
        sVERSION=${sINSTALL_VERSION:-$(CleanUpVersion "$1")}
    else
        sVERSION=$(CleanUpVersion "$1")
        echo "$LINENO InstallGEVersion: error detecting install mode"
        return 1
    fi

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "$LINENO InstallGEVersion: sVERSION is null" 1>&2
        return 1
    }

    # Re-install a version that is already installed
    if IsInstalled "$sVERSION"; then
        if [[ $iFORCE -eq 0 ]]; then
            echo "\"$sVERSION\" is already installed"
            return 0
        elif [[ $iFORCE -eq 1 ]]; then
            if IsSteamRunning; then
                echo "Please close Steam before re-installing a version that is already installed"
                return 1
            else
                echo "Forcing re-install of version \"$sVERSION\""
            fi
        fi
    fi

    # if a saved package exists and force mode is not active
    if [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 0 ]]; then
        echo "Using saved package: \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if ExtractGEPackage "$sVERSION"; then
            return 0
        else
            return 1
        fi
    # if a saved package exists and force mode is active
    elif [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 1 ]]; then
        echo "Removing saved package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if $sCOMMAND_RM "$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz"; then
            echo "Package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz removed\""
        else
            echo "Removing package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\" failed"
            return 1
        fi
    fi

    # If a saved package for this version doesn't exist or it was removed, download it and install it
    if DownloadGEPackage "$sVERSION"; then
        if ExtractGEPackage "$sVERSION"; then
            echo "Installation of version \"$sVERSION\" was successful"
            return 0
        else
            echo "Installation of version \"$sVERSION\" failed"
            return 1
        fi
    else
        echo "Version \"$sVERSION\" not found"
        return 1
    fi

    return 0
}

###############################################################################
# Removes an installed version path and package (if -f is also supplied)
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE supports removing the package specified by version even if that version is not installed
#      when the -f parameter is combined with -R
RemoveGEVersion() {

    local sVERSION=$(CleanUpVersion "$1")
    local sREMOVE_PATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
    local sREMOVE_PACKAGE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz
    local sSIZE=0

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "$LINENO RemoveGEVersion: sVERSION is null" 1>&2
        return 1
    }

    if ! IsInstalled "$sVERSION"; then
        echo "Version \"$sVERSION\" is not installed"
        return 1
    fi

    ((iDEBUG)) && echo "$LINENO RemoveGEVersion: Removing \"$sREMOVE_PATH\"" 1>&2
    # If force is enabled, remove the path and the package
    if [[ $iFORCE -eq 1 ]]; then
        ((iDEBUG)) && echo "$LINENO RemoveGEVersion: force is enabled" 1>&2
        # Remove the path if it exists
        [[ -d $sREMOVE_PATH ]] && {
            if ! IsSteamRunning; then
                sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
                sSIZE=${sSIZE%[[:space:]]*}
                if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                    echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
                else
                    echo "Failed to remove \"$sREMOVE_PATH\""
                    return 1
                fi
            else
                echo "Please close Steam before removing an install path"
                return 1
            fi
        }
        # Remove the package if it exists
        [[ -f $sREMOVE_PACKAGE ]] && {
            sSIZE=$(du -h "$sREMOVE_PACKAGE" 2>/dev/null)
            sSIZE=${sSIZE%[[:space:]]*}
            if $sCOMMAND_RM -f "$sREMOVE_PACKAGE" >/dev/null; then
                echo "Removed package \"$sREMOVE_PACKAGE\" (${sSIZE:-'error'})"
            else
                echo "Failed to remove package \"$sREMOVE_PACKAGE\""
                return 1
            fi
        }
    # If force is not enabled, remove only the install path for sVERSION
    elif [[ $iFORCE -eq 0 ]]; then
        ((iDEBUG)) && echo "$LINENO RemoveGEVersion: force is not enabled" 1>&2
        # Remove the path if it exists
        [[ -d $sREMOVE_PATH ]] && {
            if ! IsSteamRunning; then
                sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
                sSIZE=${sSIZE%[[:space:]]*}
                if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                    echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
                else
                    echo "Failed to remove \"$sREMOVE_PATH\""
                    return 1
                fi
            else
                echo "Please close Steam before removing an install path"
                return 1
            fi
        }
    fi

    return 0
}

###############################################################################
# Extracts a saved package (Proton-*.tar.gz) in the install path to the install path
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
ExtractGEPackage() {

    local sVERSION=$(CleanUpVersion "$1")
    local sEXTRACT_FILE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "$LINENO ExtractGEPackage: sVERSION is null" 1>&2
        return 1
    }

    printf '%s' "Extracting"
    if tar --checkpoint=.10000 -C "$sGE_INSTALL_PATH" -xzf "$sEXTRACT_FILE" 2>/dev/null; then
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        printf '\r\033[0K%s\n' "Package extraction failed"
        [[ -d $sGE_INSTALL_PATH/Proton-${sVERSION} ]] && {
            ((iDEBUG)) && echo "$LINENO ExtractGEPackage: Removing failed extraction path \"$sGE_INSTALL_PATH/Proton-${sVERSION}\"" 1>&2
            if $sCOMMAND_RM -rf "$sGE_INSTALL_PATH/Proton-${sVERSION}"; then
                ((iDEBUG)) && echo "$LINENO ExtractGEPackage: Removal succeeded" 1>&2
            else
                echo "Failed to remove path of failed extraction: \"$sGE_INSTALL_PATH/Proton-${sVERSION}\""
                # TODO update/remove message when install verification is updated
                echo "This script may interpret it as a valid install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# List the currently installed GE versions and any saved packages
ListInstalledGEVersions() {

    local iCOUNT=0
    local sNODE=''
    #local sEXTRACTED_VERSION=''

    ((iDEBUG)) && echo "$LINENO ListInstalledGEVersions: Install path: \"$sGE_INSTALL_PATH\"" 1>&2

    echo "Installed version(s):"
    for sNODE in "$sGE_INSTALL_PATH"/*; do
        if [[ -d $sNODE ]]; then
            #sEXTRACTED_VERSION=$(cat "$sNODE"/version 2>/dev/null)
            #sEXTRACTED_VERSION=${sEXTRACTED_VERSION#*[[:blank:]]}
            #if [[ -z $sEXTRACTED_VERSION ]] || [[ $sEXTRACTED_VERSION = "file not found" ]]; then sEXTRACTED_VERSION="error: version file not found"; fi
            #echo "  ${sNODE##*/} ($sEXTRACTED_VERSION)"
            echo "  ${sNODE##*/}"
            ((iCOUNT++))
        fi
    done
    [[ $iCOUNT -eq 0 ]] && echo "None found"

    echo "Saved package(s):"
    sNODE=''
    iCOUNT=0
    for sNODE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sNODE ]]; then
            if [[ $iDEBUG -eq 1 ]]; then
                echo "  ${sNODE##*/} (size: $(stat -c '%s' "$sNODE"), expected size: $(QueryGEAttribute "${sNODE##*/}" "size"))"
            else
                echo "  ${sNODE##*/}"
            fi
            ((iCOUNT++))
        fi
    done
    [[ $iCOUNT -eq 0 ]] && echo "None found"

    return 0
}

###############################################################################
# Report disk usage and file counts for the install path and/or a specified installed version
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
ReportGEDiskUsage() {

    local sVERSION=$(CleanUpVersion "$1")
    local sPATH=''
    local iFAILED=0

    # NOTE do not return 1 if sVERSION is NULL, functionality below depends on it

    if ! command -v du >/dev/null && ! command -v find >/dev/null && ! command -v wc >/dev/null; then
        iFAILED=1
    fi

    # if all checks succeeded
    if [[ $iFAILED -eq 0 ]]; then
        # set the path to be reported based on whether a version was provided or not
        if [[ -z $sVERSION ]]; then
            # report the file count and disk usage for the entire install path
            sPATH=$sGE_INSTALL_PATH
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                ((iDEBUG)) && echo "Path: $sPATH" 1>&2
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
        if [[ -n $sVERSION ]]; then
            # Report the file count and disk usage for a specific version
            sPATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Version \"$sVERSION\" report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                ((iDEBUG)) && echo "Path: $sPATH" 1>&2
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
    # if any check failed
    elif [[ $iFAILED -eq 1 ]]; then
        ((iDEBUG)) && echo "$LINENO ReportGEDiskUsage: At least one optional command was not found" 1>&2
        echo "One or more optional commands not found (see -h). Report not available"
        return 1
    fi

    return 0
}

###############################################################################
# Removes all saved packages in the install path defined by the global variable sGE_INSTALL_PATH
# NOTE a package is any regular file that matches the glob pattern "Proton-*.tar.gz"
RemoveSavedPackages() {

    local iSUCCESS=0
    local iFAILED=0

    ((iDEBUG)) && echo "$LINENO RemoveSavedPackages: Install path: \"$sGE_INSTALL_PATH\"" 1>&2

    for sPACKAGE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sPACKAGE ]]; then
            if $sCOMMAND_RM -f "$sPACKAGE"; then
                ((iDEBUG)) && echo "$LINENO RemoveSavedPackages: Package \"$sPACKAGE\" removed" 1>&2
                ((iSUCCESS++))
            else
                echo "Remove \"$sPACKAGE\" failed"
                ((iFAILED++))
            fi
        fi
    done

    if [[ $iSUCCESS -eq 0 ]]; then
        echo "0 packages removed"
    elif [[ $iSUCCESS -gt 0 ]]; then
        echo "$iSUCCESS packages removed"
    fi

    [[ $iFAILED -gt 0 ]] && {
        echo "Failed to remove $iFAILED package(s)"
        return 1
    }

    return 0
}

###############################################################################
# Wrapper for QueryGEAttribute to first check latest.json, then if a value is not returned, check releases.json
# Accepts two required parameters, version and attribute, returns the value or NULL if not found/error
# NOTE attributes are validated in QueryJSONAttribute
QueryGEAttribute() {

    [[ -z $1 || -z $2 || ! $# -eq 2 ]] && {
        ((iDEBUG)) && "$LINENO QueryGEAttribute: parameter error 1: \"$1\" 2: \"$2\"" 1>&2
        return 1
    }

    local sVERSION=$(CleanUpVersion "$1")
    local sVALUE=''
    local sATTRIBUTE=$2
    local iEXIT_STATUS

    if UpdateSavedGELatestRelease; then
        ((iDEBUG)) && echo "$LINENO QueryGEAttribute: UpdateSavedGELatestRelease returned success status"
    else
        ((iDEBUG)) && echo "$LINENO QueryGEAttribute: UpdateSavedGELatestRelease returned failure status"
    fi

    sVALUE=$(QueryJSONAttribute "$sFILE_LATEST_JSON" "$sVERSION" "$sATTRIBUTE")
    iEXIT_STATUS=$?
    if [[ $iDEBUG -eq 1 && $iEXIT_STATUS -gt 0 ]]; then
        echo "$LINENO QueryGEAttribute: QueryJSONAttribute returned failure status" 1>&2
    elif [[ $iDEBUG -eq 1 && $iEXIT_STATUS -eq 0 ]]; then
        echo "$LINENO QueryGEAttribute: QueryJSONAttribute returned success status" 1>&2
    elif ((iDEBUG)); then
        echo "$LINENO QueryGEAttribute: QueryJSONAttribute unknown exit status \$?: \"$?\"" 1>&2
    fi

    # if the returned value from QueryJSONAttribute was NULL, try searching in releases
    if [[ -z $sVALUE ]]; then
        if UpdateSavedGEReleases; then
            ((iDEBUG)) && echo "$LINENO QueryGEAttribute: UpdateSavedGEReleases returned success status"
        else
            ((iDEBUG)) && echo "$LINENO QueryGEAttribute: UpdateSavedGEReleases returned failure status"
        fi

        sVALUE=$(QueryJSONAttribute "$sFILE_RELEASES_JSON" "$sVERSION" "$sATTRIBUTE")
        iEXIT_STATUS=$?
        if [[ $iDEBUG -eq 1 && $iEXIT_STATUS -gt 0 ]]; then
            echo "$LINENO QueryGEAttribute: QueryJSONAttribute returned failure status" 1>&2
        elif [[ $iDEBUG -eq 1 && $iEXIT_STATUS -eq 0 ]]; then
            echo "$LINENO QueryGEAttribute: QueryJSONAttribute returned success status" 1>&2
        elif ((iDEBUG)); then
            echo "$LINENO QueryGEAttribute: QueryJSONAttribute unknown exit status \$?: \"$?\"" 1>&2
        fi
    fi

    if [[ -n $sVALUE ]]; then
        printf '%s' "$sVALUE"
        return 0
    else
        printf ''
        return 1
    fi

    # NOTE do not return 0/1 here
}

###############################################################################
# Return the value of a requested attribute from a saved latest/releases JSON file
# value = $( QueryJSONAttribute "file.json" "version" "attribute")
# NOTE This function relies on the JSON being in an exact order, if that order is changed (eg. by the github api) this function will cease to work
# Example JSON order expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# WARNING This function relies on non-minified (newline delimited) JSON responses from the github api.
#         Setting a custom, unique User-Agent can (currently, will) cause the JSON response to be minified, causing this function to not behave as expected.
QueryJSONAttribute() {

    if [[ -z $1 || -z $2 || -z $3 ]] || [[ ! $# -eq 3 ]] || [[ ! -f $1 ]]; then
        ((iDEBUG)) && echo "$LINENO QueryJSONAttribute: invalid parameter error 1: \"$1\" 2: \"$2\" 3: \"$3\" \$#: \"$#\"" 1>&2
        return 1
    fi

    [[ ${3,,} != @(size|browser_download_url) ]] && {
        ((iDEBUG)) && echo "$LINENO QueryJSONAttribute: unsupported attribute requested \"$2\"" 1>&2
        return 1
    }

    local sVERSION=''
    local sSIZE=''
    local sBROWSER_URL=''
    local sATTRIBUTE=''
    local iLINE_COUNTER=0
    local iLINE_VERSION_FOUND=0
    local iLINE_SIZE_FOUND=0
    local iLINE_BROWURL_FOUND=0
    local iFLAG_VERSION_FOUND=0
    local iFLAG_SIZE_FOUND=0
    #local iFLAG_BROWURL_FOUND=0

    sVERSION=$(CleanUpVersion "$2")

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "$LINENO QueryJSONAttribute: sVERSION is null" 1>&2
        return 1
    }

    sATTRIBUTE=${3,,}

    # WARNING do not manually output to stdout in this loop (unless you connect the file to different fd, and set read -u accordingly)
    # NOTE stderr is redirected to /dev/null
    while IFS= read -r; do
        ((iLINE_COUNTER++))
        # version match
        # sVERSION=5.9-GE-5-ST
        # *"name": "Proton-5.9-GE-5-ST.tar.gz",
        [[ $REPLY =~ ^.*\"name\":[[:space:]]\"Proton-${sVERSION}\.tar\.gz\",$ ]] && {
            iFLAG_VERSION_FOUND=1
            iLINE_VERSION_FOUND=$iLINE_COUNTER
        }

        # *"size": 406721946,
        [[ $iFLAG_VERSION_FOUND -eq 1 ]] && {
            [[ ${REPLY,,} =~ ^.*\"size\":[[:space:]]+[[:digit:]]*,$ ]] && {
                iFLAG_SIZE_FOUND=1
                iLINE_SIZE_FOUND=$iLINE_COUNTER
                sSIZE=${REPLY/#*\"size\":[[:space:]]}
                sSIZE=${sSIZE/%,}
                continue
            }
        }

        # *"browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        [[ $iFLAG_VERSION_FOUND -eq 1 && $iFLAG_SIZE_FOUND -eq 1 ]] && {
            [[ $REPLY =~ ^.*\"browser_download_url\":[[:space:]]\".*Proton-${sVERSION}\.tar\.gz\"$ ]] && {
                #iFLAG_BROWURL_FOUND=1
                iLINE_BROWURL_FOUND=$iLINE_COUNTER
                sBROWSER_URL=${REPLY/#*\"browser_download_url\":[[:space:]]\"}
                sBROWSER_URL=${sBROWSER_URL%\"}
                break
            }
        }
    done < "$1" 2>/dev/null

    # debug messages
    ((iDEBUG)) && {
        if [[ $iFLAG_VERSION_FOUND -eq 0 ]]; then
            echo "$LINENO QueryJSONAttribute: version match not found" 1>&2
        elif [[ $iFLAG_VERSION_FOUND -eq 1 ]]; then
            echo "$LINENO QueryJSONAttribute: version match found at line $iLINE_VERSION_FOUND" 1>&2
        fi
        if [[ -z $sSIZE ]]; then
            echo "$LINENO QueryJSONAttribute: sSIZE is NULL" 1>&2
        else
            echo "$LINENO QueryJSONAttribute: sSIZE: \"$sSIZE\"" 1>&2
        fi
        if [[ -z $sBROWSER_URL ]]; then
            echo "$LINENO QueryJSONAttribute: sBROWSER_URL is NULL" 1>&2
        else
            echo "$LINENO QueryJSONAttribute: sBROWSER_URL: \"$sBROWSER_URL\"" 1>&2
        fi
        echo "$LINENO QueryJSONAttribute: iLINE_VERSION_FOUND: $iLINE_VERSION_FOUND iLINE_SIZE_FOUND: $iLINE_SIZE_FOUND iLINE_BROWURL_FOUND: $iLINE_BROWURL_FOUND" 1>&2
    }

    # output the value of the requested attribute
    if [[ -n $sSIZE && -n $sBROWSER_URL ]]; then
        case $sATTRIBUTE in
            (size)
                printf '%s' "$sSIZE" >&1
            ;;
            (browser_download_url)
                printf '%s' "$sBROWSER_URL" >&1
            ;;
            (*)
                # NOTE NULL response indicates error OR not found. check return status and response
                printf ''
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Removes the path defined by the global variable sGE_INSTALL_PATH
# NOTE currently requires -f to be combined with -X
RemoveGEInstallPath() {

    local sSIZE=''

    if command -v du >/dev/null; then
        sSIZE=$(du -sh "$sGE_INSTALL_PATH")
    else
        ((iDEBUG)) && echo "$LINENO RemoveGEInstallPath: command du not found" 1>&2
        sSIZE="?"
    fi

    if $sCOMMAND_RM -rf "$sGE_INSTALL_PATH"; then
        echo "Remove install path succeeded ( ${sSIZE%%[[:blank:]]*} removed )"
        if [[ $iDEBUG -eq 1 ]]; then
            mkdir -pv "$sGE_INSTALL_PATH"
        else
            mkdir -p "$sGE_INSTALL_PATH"
        fi
    else
        echo "Removal of install path \"$sGE_INSTALL_PATH\" failed"
        return 1
    fi

    return 0
}

###############################################################################
# Check if a version is installed
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE Currently only checks if a path for the version exists
# TODO better verification
IsInstalled() {

    [[ -z $1 ]] && {
        ((iDEBUG)) && echo "$LINENO IsInstalled: NULL parameter error" 1>&2
        return 1
    }

    sVERSION=$(CleanUpVersion "$1")

    ((iDEBUG)) && echo "IsInstalled: Checking for version \"$sVERSION\" at \"$sGE_INSTALL_PATH/Proton-${sVERSION}\"" 1>&2

    if [[ -d $sGE_INSTALL_PATH/Proton-${sVERSION} ]]; then
        ((iDEBUG)) && echo "IsInstalled: Version \"$sVERSION\" found" 1>&2
        return 0
    else
        ((iDEBUG)) && echo "IsInstalled: Version \"$sVERSION\" not found" 1>&2
        return 1
    fi

    # NOTE do not return 0 here
}

###############################################################################
# Check if Steam is running using 'ps -e'
# return 0 = Steam is running
# return 1 = Steam is not running / ps is missing / Steam is not running but steamwebhelper is
IsSteamRunning() {

    local iSTEAM=0
    local iWEBHLPR=0

    if command -v ps >/dev/null; then
        while IFS= read -r; do
            [[ ${REPLY,,} =~ ^.*steam$ ]] && {
                iSTEAM=1
                ((iDEBUG)) && echo "$LINENO IsSteamRunning: steam match: \"$REPLY\"" 1>&2
            }
            [[ ${REPLY,,} =~ ^.*steamwebhelper.*$ ]] && {
                iWEBHLPR=1
                ((iDEBUG)) && echo "$LINENO IsSteamRunning: steamwebhelper match: \"$REPLY\"" 1>&2
            }
        done < <(ps -e)
        #return $(( iSTEAM == 1 ? 0 : 1 ))

        if [[ $iSTEAM -eq 1 ]]; then
            return 0
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 1 ]]; then
            echo "Warning: at least one steamwebhelper process(es) is still running and Steam is not running"
            return 1
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 0 ]]; then
            return 1
        else
            echo "$LINENO IsSteamRunning: unknown error iSTEAM: \"$iSTEAM\" iWEBHLPR: \"$iWEBHLPR\" (last)REPLY: \"$REPLY\""
            return 1
        fi
    else
        # ps missing
        echo "$LINENO IsSteamRunning: command 'ps' not found"
        return 1
    fi

    return 1
}

###############################################################################
# Support different formats for version specification
# Internally, the script uses case-sensitive "base" versions such as "5.9-GE-5-ST" but
# for parsing parameters many other variations are supported. Examples are in usage above.
# TODO support even more variations?
CleanUpVersion() {

    local iLENGTH=0
    local sVERSION=${1-}

    [[ -z $sVERSION ]] && {
        ((iDEBUG)) && echo "$LINENO CleanUpVersion: sVERSION is null" 1>&2
        return 1
    }

    ((iDEBUG)) && {
        iLENGTH=${#sVERSION}
        echo "$LINENO CleanUpVersion: before: \"$sVERSION\"" 1>&2
    }

    # global upper case
    sVERSION=${sVERSION^^}
    # anchored left, remove a single "PROTON-" and anything to the left of it
    sVERSION=${sVERSION#*'PROTON-'}
    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    sVERSION=${sVERSION%'.TAR.GZ'*}

    ((iDEBUG)) && {
        echo "$LINENO CleanUpVersion: after: \"$sVERSION\"" 1>&2
        [[ $iLENGTH -ne ${#sVERSION} ]] && echo "$LINENO CleanUpVersion: removed $(( iLENGTH - ${#sVERSION} )) characters" 1>&2
    }

    printf '%s' "$sVERSION"

    return 0
}

###############################################################################
# Diagnostic tool - exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>/dev/stdout; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip ps stat

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: \"$PWD\""
    echo "SHELL: \"$SHELL\""
    echo "SHELLOPTS: \"$SHELLOPTS\""
    echo "SHLVL: \"$SHLVL\""
    echo "BASH_VERSINFO: \"${BASH_VERSINFO[*]}\""
    echo "BASH_VERSION: \"$BASH_VERSION\""
    echo "MACHTYPE: \"$MACHTYPE\""
    echo "OSTYPE: \"$OSTYPE\""
    echo "PROMPT_COMMAND: \"$PROMPT_COMMAND\""
    echo "LANG: \"$LANG\""
    echo "LC_MESSAGES: \"$LC_MESSAGES\""
    echo "LC_ALL: \"$LC_ALL\""
    echo "EUID: \"$EUID\""
    #echo "${FUNCNAME[@]}"
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Optional command support
ConfigureOptionalCommands() {

    if command -v trash >/dev/null; then
        sCOMMAND_RM="trash"
    fi

    return 0
}

###############################################################################
# Remove temporary paths if debug mode is not active
CleanUp() {
    # NOTE must be first
    iREAL_EXIT_STATUS=$? # used to pass the exit status to the calling environment in case of unexpected failure

    [[ -d $sTMP_DIR ]] && {
        if [[ $iDEBUG -eq 0 ]]; then
            if ! $sCOMMAND_RM -rf "$sTMP_DIR"; then
                echo "CleanUp: Failed to remove temporary path at $sTMP_DIR"
                return 1
            fi
        elif [[ $iDEBUG -eq 1 ]]; then
            [[ $iFINAL_CLEANUP -eq 1 ]] && {
                echo "$LINENO CleanUp: Temporary path saved at: $sTMP_DIR" 1>&2
            }
        fi
    }

    return 0
}

###############################################################################
# Parse command line parameters and set global variables according to what was
# requested. Order of operations for invocations that involve multiple parameters
# is listed at the end of the usage section.
ParseParameters() {
    while getopts 'zZhHflSs:i:d:R:NuUX' sOPT; do
        case "$sOPT" in
            (h) iSHOW_HELP=1 ;;
            (H) iSHOW_USAGE=1 ;;
            (f) iFORCE=1 ;;
            (z) iDEBUG=1 ;;
            (Z)
                if [[ $iFORCE -eq 1 ]] && [[ $iDEBUG -eq 1 ]]; then
                    ReportEnvironmentInfo # exactly -fzZ (undocumented diagnostic tool)
                fi
            ;;
            (u) iCHECK_UPDATE=1 ;;
            (X) iREMOVE_INSTALL_PATH=1 ;;
            (N) iREMOVE_SAVED_PACKAGES=1 ;;
            (R)
                iREMOVE=1
                sREMOVE_VERSION=$OPTARG
            ;;
            (l) iLIST_INSTALLED_GE_VERSIONS=1 ;;
            (s)
                iREPORT_VERSION_USAGE=1
                sREPORT_VERSION=$OPTARG
            ;;
            (S) iREPORT_INSTALL_PATH_USAGE=1 ;;
            (d)
                iDOWNLOAD=1
                sDOWNLOAD_VERSION=$OPTARG
            ;;
            (i)
                iINSTALL=1
                sINSTALL_VERSION=$OPTARG
            ;;
            (U) iUPDATE=1 ;;
            (":"|"?")
                return 1
            ;;
        esac
    done

    return 0
}

###############################################################################

Main() {

    # Parse script parameters and options, set global variables
    if ! ParseParameters "$@"; then
        exit 1
    fi

    # show help and/or usage
    if [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 0 ]]; then
        ShowHelp
        exit
    elif [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowHelp
        ShowUsage
        exit
    elif [[ $iSHOW_HELP -eq 0 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowUsage
        exit
    fi

    # debug mode
    ((iDEBUG)) && {
        echo "Main: Debug mode enabled" 1>&2
    }

    ConfigureOptionalCommands

    [[ ! -d $sGE_INSTALL_PATH ]] && {
        if [[ $iDEBUG -eq 1 ]]; then
            mkdir -pv "$sGE_INSTALL_PATH"
        else
            mkdir -p "$sGE_INSTALL_PATH"
        fi
    }

    # checkupdate
    if [[ $iCHECK_UPDATE -eq 1 && $iUPDATE -eq 0 ]]; then
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
    fi

    # remove install path
    if [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 1 ]]; then
        if IsSteamRunning; then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    elif [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 0 ]]; then
        echo "-X must be combined with -f to confirm that you are sure" # "Use the force Harry" ~ Gandalf
    fi

    # remove saved packages
    if [[ $iREMOVE_SAVED_PACKAGES -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]]; then
        # TODO -f required?
        RemoveSavedPackages
    fi

    # remove an installed version or package
    if [[ $iREMOVE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && [[ $iREMOVE_SAVED_PACKAGES -eq 0 ]]; then
        # NOTE sREMOVE_VERSION is set in getops
        RemoveGEVersion "$sREMOVE_VERSION"
    elif [[ $iREMOVE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was requested in the same invocation"
    fi

    # downlaod a package
    ((iDOWNLOAD)) && {
        # NOTE sDOWNLOAD_VERSION is set in getops
        DownloadGEPackage "$sDOWNLOAD_VERSION"
    }

    # check for new version and update if it is not installed
    if [[ $iUPDATE -eq 1 ]]; then
        if UpdateSavedGELatestRelease; then
            if GetLatestGEVersion; then # set sGE_LATEST_VERSION
                if IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 1 ]]; then # Latest version is installed and -f is suppled
                    if RemoveGEVersion "$sGE_LATEST_VERSION"; then
                        if InstallGEVersion; then # InstallGEVersion checks iUPDATE then sINSTALL_VERSION and/or sGE_LATEST_VERSION
                            echo "Update succeeded"
                        else
                            echo "Update failed"
                        fi
                    fi
                elif IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 0 ]]; then # Latest version is installed and -f was not supplied
                    ((iDEBUG)) && printf '%s' "$LINENO Main: Update: "
                    echo "Latest version is already installed ($sGE_LATEST_VERSION)"
                elif ! IsInstalled "$sGE_LATEST_VERSION"; then # Latest version is not installed
                    ((iDEBUG)) && printf '%s' "$LINENO Main: Update: "
                    echo "Latest version is not installed"
                    if InstallGEVersion; then
                        ((iDEBUG)) && printf '%s' "$LINENO Main: Update: "
                        echo "Update succeeded"
                        if IsSteamRunning; then echo "Please restart Steam to use the new version"; fi
                    else
                        ((iDEBUG)) && printf '%s' "$LINENO Main: Update: "
                        echo "Update failed"
                    fi
                fi
            else
                ((iDEBUG)) && printf '%s\n' "$LINENO Main: Update: GetLatestGEVersion returned failure status" 1>&2
            fi
        else
            # GetLatestGEVersionInfo failed
            ((iDEBUG)) && printf '%s\n' "$LINENO Main: Update: GetLatestGEVersionInfo returned failure status" 1>&2
            echo "Update failed"
        fi
        # Like purchasing a tribble, this is probably a bad idea
        [[ $iINSTALL -eq 1 ]] && iUPDATE=0 # Reset iUPDATE to 0 so update and install can run in the same invocation
    fi

    # install a package
    if [[ $iINSTALL -eq 1 ]] && [[ $iUPDATE -eq 0 ]]; then
        # NOTE sINSTALL_VERSION is set in getops
        InstallGEVersion "$sINSTALL_VERSION"
    fi

    # list installed versions
    [[ $iLIST_INSTALLED_GE_VERSIONS -eq 1 ]] && ListInstalledGEVersions

    # Report entire install path disk usage and file count
    [[ $iREPORT_INSTALL_PATH_USAGE -eq 1 ]] && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    [[ $iREPORT_VERSION_USAGE -eq 1 ]] && ReportGEDiskUsage "$sREPORT_VERSION"


    # if no parameters were supplied, show help
    # NOTE ignore iFORCE and iDEBUG flags
    if [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && \
       [[ $iREMOVE_SAVED_PACKAGES -eq 0 ]] && \
       [[ $iREMOVE -eq 0 ]] && \
       [[ $iLIST_INSTALLED_GE_VERSIONS -eq 0 ]] && \
       [[ $iREPORT_VERSION_USAGE -eq 0 ]] && \
       [[ $iREPORT_INSTALL_PATH_USAGE -eq 0 ]] && \
       [[ $iDOWNLOAD -eq 0 ]] && \
       [[ $iINSTALL -eq 0 ]] && \
       [[ $iCHECK_UPDATE -eq 0 ]] && \
       [[ $iUPDATE -eq 0 ]]; then

        ((iDEBUG)) && {
            if IsSteamRunning; then
                echo "Main: Steam is running" 1>&2
            else
                echo "Main: Steam is not running" 1>&2
            fi
            echo "Main: Nothing to do - showing help" 1>&2
        }

        # report latest version installed status
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
        ShowHelp
    fi

    return 0
}

###############################################################################
# EXIT signal trap
trap '((iDEBUG)) && echo "Exit status (before CleanUp): $?" 1>&2; iFINAL_CLEANUP=1 CleanUp; ((iDEBUG)) && echo "Exit status (after CleanUp): $?" 1>&2; exit $iREAL_EXIT_STATUS' EXIT

###############################################################################

Main "$@"
