#!/usr/bin/env bash
# vim: set ft=shell nowrap expandtab shiftwidth=4 tabstop=4 smarttab softtabstop=0
# misc-bash/script-sloc ge-install-manager:
# 2002/3081 SLOC (64%) [SLOC/Comment:2.90], 690 comments (22%) [S:95%,I:4%] [Comment/SLOC:0.34], 418 empty (13%)

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

# -e  Exit immediately if a command exits with a non-zero status.
set +e # WARNING: DO NOT set -e

# -h Remember the location of commands as they are looked up. Default is on.
# -u Treat unset variables as an error when substituting. Default is off.
# -o pipefail The return value of a pipeline is the status of the last command
#             to exit with a non-zero status, or zero if no command exited with
#             a non-zero status. Default is off.
set -huo pipefail

###############################################################################
# "Things that would be nice, but aren't required for main features" list
#
# TODO: Install parameter (-I?) / -f erases cache and config?
#       Currently, using any function that requires cache/config will run the
#       "first time setup" if those files are missing so an explicit parameter
#       isn't exactly required. Install can be as simple as: ge-install-manager -U
#       or ge-install-manager -i <version>
# TODO: Replace getopts with a custom parser
# TODO: support for using jq in addition to sed
#
###############################################################################

# Initialize global variables
# NOTE: Script constants (read only variables) are all upper-case
declare -gr SCRIPT_VERSION="0.7.5"
declare -gr SCRIPT_FULL_NAME=${0##*/}
declare -gr SCRIPT_CODENAME="Cochrane Bonaventure"
declare -gr CURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
declare -gr CURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
declare -gr CURL_HEADER_USER_AGENT="User-Agent: toazd/$SCRIPT_FULL_NAME/$SCRIPT_VERSION"
declare -gr TEMP_PREFIX=$SCRIPT_FULL_NAME.tmp.
# NOTE: Script global variables are all prefixed with g_
declare -g g_command_rm # Configuration file: rm_command
declare -g g_download_version
declare -g g_file_latest_json
declare -g g_file_releases_json
declare -g g_script_config_path=${XDG_CONFIG_HOME:-$HOME/.config}/$SCRIPT_FULL_NAME
declare -g g_file_script_config=$g_script_config_path/$SCRIPT_FULL_NAME.conf
declare -g g_file_sed_unminify_script=$g_script_config_path/unminify-JSON.sed
declare -g g_install_path  # Configuration file: install_path
declare -g g_install_version
declare -g g_latest_version
declare -g g_latest_version_url # Configuration file: latest_version_url
declare -g g_override_default_install_path=''
declare -g g_releases_url # Configuration file: releases_url
declare -g g_remove_version
declare -g g_remove_saved_version
declare -g g_report_version
declare -g g_script_cache_path # Configuration file: cache_path
declare -g g_temp_base_path=/tmp # Configuration file: temp_path
declare -g g_verify_version
declare -gi g_check_update=0
declare -gi g_verbose=0
declare -gi g_download=0
declare -gi g_flag_sigint_caught=0
declare -gi g_force=0
declare -gi g_install=0
declare -gi g_integration_testing=0
declare -gi g_list_installed_versions=0
declare -gi g_real_exit_status=0
declare -gi g_remove_all_saved_packages=0
declare -gi g_remove_installed_version=0
declare -gi g_remove_install_path=0
declare -gi g_remove_saved_package=0
declare -gi g_report_install_path_usage=0
declare -gi g_report_version_usage=0
declare -gi g_show_help=0
declare -gi g_show_usage=0
declare -gi g_size_bytes_sed_unminify_script=824
declare -gi g_update=0
declare -gi g_verify=0
declare -gi g_checked_recently_seconds=3600 # NOTE: Minimum interval that checks for a new version of latest/releases will be allowed (60 minutes)

###############################################################################
# Purpose: Print the help text to stdout
# Input:   None
# Output:  None
# Return:  Always 0
ShowHelp() {

    cat <<HELP_HEREDOC

    $(basename "$0")  v$SCRIPT_VERSION "$SCRIPT_CODENAME"

    Configuration path: $g_script_config_path

    Required:       Bash 3.2+(TBD), curl, sed, tar, gzip, stat, wc, touch
    Optional:       date, du, pgrep, sort, cmp, envsubst, fallocate, trash

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
    -r <version>  - Remove saved package <version>
    -V            - Verify each installation using its saved package
                      Combined with -v, -V will be skipped
                      Saved packages will be downloaded as needed
    -v <version>  - Verify <version> using its saved package
    -d <version>  - Download and save the package for <version>
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      NOTE: Saved packages are currently stored in the installation path
    -f            - Force install, upgrade, or remove
                      Combined with -U and/or -i, remove saved package and download a new copy
    -z            - Enable verbose output mode (to stderr)
                      Also preserves any temporary files created
                      Format: (calling line)[function trace]: message
HELP_HEREDOC

    return 0
}

###############################################################################
# Purpose: Print the usage text to stdout
# Input:  None
# Output: None
# Return: Always 0
ShowUsage() {

     cat <<USAGE_HEREDOC
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle,
      Report environment info (-fzZ),
      Show help,
      Show usage,
      Debug toggle,
      Check for latest release,
      Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Remove saved package (if remove install path is not active),
      Download,
      Update,
      Install,
      List installed,
      Report install path usage,
      Report specific version usage
      Verify

USAGE_HEREDOC

    return 0
}

###############################################################################
# Purpose: Set the global variable g_latest_version to the latest version
#          which is retrieved from the name member of the assets object in
#          the local file g_file_latest_json.
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = UpdateCachedGEReleases returned 1, or a match was not found
#              in g_file_latest_json
#
# TODO: Might want to check releases if latest fails. But, will the first entry
#       always be the latest?
GetLatestGEVersion() {

    local version
    g_latest_version=''

    if UpdateCachedGEReleases; then
        while IFS= read -r --; do
            # WARNING: Do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST"
            #          for matching. The version extracted from them (eg. 5.9-GE-5-ST) is not
            #          always the same as the version extracted from browser_download_url
            # NOTE: The regex must match all 3 of the following potential formats:
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name": "Proton-5.9-GE-5-ST.tar.gz"
            [[ $REPLY =~ ^[[:blank:]]*\"name\":[[:blank:]]*\"Proton-.*\.tar\.gz\".*$ ]] && {
                REPLY=${REPLY%\"*}
                version=${REPLY##*\"}
                ((g_verbose)) && vMsg "version: $version"
                CleanUpVersion
                g_latest_version=$version
                ((g_verbose)) && vMsg "g_latest_version: $g_latest_version"
                break
            }
        done < "$g_file_latest_json"
        [[ -z $g_latest_version ]] && {
            ((g_verbose)) && vMsg "g_latest_version is NULL (no match or not found)"
            return 1
        }
    else
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Call the RequestURL function to update both g_file_latest_json and
#          g_file_releases_json (RequestURL: if the remote versions are newer)
#          and a configurable interval has passed.
# Input:   None
# Output:  None
# Return:  0 = Success (both files were successfully updated or the access
#                       interval has not passed for both files)
#          1 = Failure (RequestURL returned 1 for either file)
UpdateCachedGEReleases() {

    ((g_verbose)) && {
        vMsg "g_latest_version_url: $g_latest_version_url"
        vMsg "g_file_latest_json: $g_file_latest_json"
    }

    # Check the access time of the local file and if the interval hasn't passed use
    # the local file instead of checking for a newer remote version.
    if CheckAccessTime "$g_file_latest_json" "$g_checked_recently_seconds"; then
        if RequestURL "$g_latest_version_url" "$g_file_latest_json"; then
            return 0
        else
            return 1
        fi
    else
        return 0
    fi

    ((g_verbose)) && {
        vMsg "g_releases_url: $g_releases_url"
        vMsg "g_file_releases_json: $g_file_releases_json"
    }

    # Check the access time of the local file and if the interval hasn't passed use
    # the local file instead of checking for a newer version remotely.
    if CheckAccessTime "$g_file_releases_json" "$g_checked_recently_seconds"; then
        if RequestURL "$g_releases_url" "$g_file_releases_json"; then
            return 0
        else
            return 1
        fi
    else
        return 0
    fi

    ((g_verbose)) && vMsg "Warning, returning default value of 1"

    return 1
}

###############################################################################
# Purpose: Using curl, download a proton-ge-custom release package to a
#          temporary path and if the download size matches the expected size
#          copy it to g_install_path
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
DownloadGEPackage() {

    # Declare local variables
    local version temp_path temp_package package_download_url
    local -i temp_base_path_remaining_bytes=0
    local -i install_path_remaining_bytes=0
    local -i expected_size_bytes=0
    local -i downloaded_package_size_bytes=0

    # Set local variables, checking return values and reporting as needed
    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Get the download URL from the saved latest/releases JSON
    package_download_url=$(QueryGEAttribute "$version" "browser_download_url") || {
        ((g_verbose)) && vMsg "QueryGEAttribute browser_download_url returned failure"
        return 1
    }

    # If QueryGEAttribute returned success but the URL is NULL, abort
    [[ -z $package_download_url ]] && { ((g_verbose)) && vMsg "package_download_url is NULL"; return 1; }

    # Get the expected package size in bytes from the saved latest/releases JSON
    expected_size_bytes=$(QueryGEAttribute "$version" "size") || { ((g_verbose)) && vMsg "QueryGEAttribute size returned failure"; return 1; }

    # If QueryGEAttribute returned success and size is not only one or more digits, abort
    [[ $expected_size_bytes =~ ^[[:digit:]]+$ ]] || { ((g_verbose)) && vMsg "size is not all digits: $expected_size_bytes"; return 1; }

    # Create a temporary path for the package
    temp_path=$(MkTempPath)

    # Define the temporary package name
    temp_package=$temp_path/Proton-${version}.tar.gz

    # Get the bytes remaining on the temp path
    temp_base_path_remaining_bytes=$(SpaceRemaining "$g_temp_base_path" "b")

    # Get the bytes remaining on the install path
    install_path_remaining_bytes=$(SpaceRemaining "$g_install_path" "b")

    # Check if there is enough free space to copy the package to g_install_path
    if ((expected_size_bytes > install_path_remaining_bytes)); then
        printf '%s\n%s\n' \
               "WARNING: Not enough free space at $g_install_path" \
               "Need at least $expected_size_bytes bytes but there is only $install_path_remaining_bytes bytes free"
        return 1
    else
        ((g_verbose)) && {
            vMsg "g_install_path ($g_install_path) remaining bytes: $install_path_remaining_bytes"
            vMsg "temp_path ($temp_path) remaining bytes: $temp_base_path_remaining_bytes"
            vMsg "Expected package size (bytes): $expected_size_bytes"
        }
    fi

    # If there is not enough free space remaining on the temp_path file system
    # TODO: Use a different path as a fallback?
    if ((temp_base_path_remaining_bytes < expected_size_bytes)); then
        ((g_verbose)) && vMsg "Free space on $g_temp_base_path is $temp_base_path_remaining_bytes bytes"
        printf '%s\n%s\n%s\n' \
               "WARNING: Not enough free space at $g_temp_base_path" \
               "Need at least $expected_size_bytes bytes but there is only $temp_base_path_remaining_bytes bytes free" \
               "Free up space or change temp_path in the configuration file"
        return 1
    else
        # If fallocate is found, preallocate the file to be downloaded
        if command -v fallocate &>/dev/null; then
            if fallocate -l "$expected_size_bytes" -- "$temp_package"; then
                ((g_verbose)) && vMsg "fallocate succeeded"
            else
                #echo "Failed to preallocate $sTMP_FILE, download may fail"
                ((g_verbose)) && vMsg "fallocate -l $expected_size_bytes -- $temp_package returned failure"
                [[ -f $temp_package ]] && rm -f -- "$temp_package"
            fi
        else
            ((g_verbose)) && vMsg "fallocate not found"
        fi
    fi

    # Attempt to retrieve the package with curl
    echo "Downloading $package_download_url"
    if curl -# -L "$package_download_url" -o "$temp_package"; then

        # Get the downloaded file size in bytes
        downloaded_package_size_bytes=$(stat -c '%s' -- "$temp_package")
        ((g_verbose)) && vMsg "Downloaded package size in bytes: $downloaded_package_size_bytes"

        # Not found
        if ((downloaded_package_size_bytes == 9)); then
            echo "Server responded Not Found for version $version"
            CleanUp
            return 1
        fi

        # Github API request rate limit exceeded
        if ((downloaded_package_size_bytes == 248)); then
            echo "Github API request rate limit exceeded. Try again later."
            CleanUp
            return 1
        fi

        # Check if the the package size and expected size are equal
        if (( downloaded_package_size_bytes == $(QueryGEAttribute "$version" "size") )); then
            echo "Downloaded package is the expected size ($expected_size_bytes bytes)"
        else
            printf '%s\n%s\n%s\n' \
                   "Downloaded file size and expected size do not match" \
                   "Downloaded file: $downloaded_package_size_bytes bytes" \
                   "Expected size  : $expected_size_bytes bytes"
           CleanUp
           return 1
        fi

        # Copy the package from the temporary path to g_install path
        ((g_verbose)) && vMsg "Copying package $temp_package to $g_install_path"
        if cp -- "$temp_package" "$g_install_path"; then
            ((g_verbose)) && vMsg "Package copied successfully"
            echo "Copy package to install path succeeded"
            CleanUp
        else
            ((g_verbose)) && vMsg "Copy package from $temp_package to $g_install_path failed"
            echo "Copy package to install path failed"
            CleanUp
            return 1
        fi
    else
        # curl returned >0
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Check for the latest version and if it is not installed install it
#          If force mode is active and the latest version is already installed,
#          it will first be removed and then re-installed.
# Input:   None
# Output:  None
# Return:  0 = Success
#          1 = Failure
UpdateGEVersion() {

    # Get the latest g_file_latest_json if the remote file is newer
    if UpdateCachedGEReleases; then

        # Latest version is installed and force mode is not active
        if IsInstalled "$g_latest_version" && ((! g_force)); then
            echo "Latest version is already installed ($g_latest_version)"
        # Latest version is not installed
        elif ! IsInstalled "$g_latest_version"; then
            echo "Latest version ($g_latest_version) is not installed"
            if InstallGEVersion "$g_latest_version"; then
                echo "Update succeeded"
                IsSteamRunning && echo "Restart Steam to use the new version"
            else
                echo "Update failed"
                return 1
            fi
        # Latest version is installed and force mode is active
        elif ((g_force)); then
            # NOTE: InstallGEVersion also verifys that force mode is active
            if InstallGEVersion "$g_latest_version"; then
                echo "Update succeeded"
            else
                echo "Update failed"
                return 1
            fi
        else
            ((g_verbose)) && vMsg "Error determining install status and force mode"
            return 1
        fi
    else
        # GetLatestGEVersionInfo failed
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status"
        echo "Update failed"
        return 1
    fi

    return 0
}


###############################################################################
# Purpose: Install a requested proton-ge-custom release version or install the
#          latest version. If g_force=1 and a saved package exists for the
#          requested version the package will be removed and a new one will be
#          downloaded.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
InstallGEVersion() {

    local version=${1-}

    [[ -z $version ]] && ((g_verbose)) && { vMsg "Parameter error (NULL)"; return 1; }

    CleanUpVersion

    [[ -n $version ]] && ((g_verbose)) && vMsg "Requested version is $version"

    # If the requested version is already installed
    if IsInstalled "$version"; then

        # If force mode is on
        if ((g_force)); then

            # If Steam is running, avoid undefined behavior
            if IsSteamRunning; then
                echo "Please close Steam before re-installing a version"
                return 1
            # If Steam is not running, remove the install
            # NOTE: The re-install is handled below
            else
                echo "Forcing re-install of version $version"
                echo "Removing install at $g_install_path/Proton-${version}"
                if ($g_command_rm -- "$g_install_path/Proton-${version}"); then
                    echo "Install removed"
                else
                    echo "Remove failed"
                    return 1
                fi
            fi
        # If force mode is off, nothing else to do
        else
            echo "Version $version is already installed"
            return 0
        fi
    fi

    # If a saved package exists for the requested version
    if [[ -f $g_install_path/Proton-${version}.tar.gz ]]; then

        # If force mode is on, remove the package
        if ((g_force)); then
            echo "Removing saved package $g_install_path/Proton-${version}.tar.gz"
            if ($g_command_rm -- "$g_install_path/Proton-${version}.tar.gz"); then
                echo "Package removed"
            else
                echo "Removing package failed"
                return 1
            fi
        # If force mode is off, use the saved package
        else
            echo "Using saved package: $g_install_path/Proton-${version}.tar.gz"

            # Check that the size of the package is the expected size
            if (( $(stat -c '%s' -- "$g_install_path/Proton-${version}.tar.gz") != $(QueryGEAttribute "$version" "size") )); then
                echo "Saved package is not the expected size, a new one will be downloaded"
                if RemoveSavedPackage "$version"; then
                    echo "Removed package"
                else
                    echo "WARNING: Remove package failed"
                    return 1
                fi
            else
                if ExtractGEPackage "$version"; then
                    echo "Installation of version $version was successful"
                    return 0
                else
                    echo "Installation of version $version failed"
                    return 1
                fi
            fi
        fi
    fi

    # Download a new package and extract it.
    if DownloadGEPackage "$version"; then
        if ExtractGEPackage "$version"; then
            echo "Installation of version $version was successful"
            if IsSteamRunning; then
                echo "You must restart Steam to use the new version"
            fi
            return 0
        else
            echo "Installation of version $version failed"
            return 1
        fi
    else
        echo "Version $version not found"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove an installed Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 = Success
#          1 = Failure
RemoveGEVersion() {

    local version remove_path disk_usage

    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Define the path that will be removed
    remove_path=$g_install_path/Proton-${version}

    ((g_verbose)) && { vMsg "Requested version: $version"; vMsg "remove_path: $remove_path"; }

    # Remove the path if it exists
    if [[ -d $remove_path ]]; then
        if ! IsSteamRunning; then
            # Get the disk usage in human readable format
            disk_usage=$(du -sh -- "$remove_path" 2>/dev/null)
            disk_usage=${disk_usage%[[:space:]]*}
            if ($g_command_rm -rf -- "$remove_path" &>/dev/null); then
                echo "Removed path $remove_path (${disk_usage:-'error'})"
            else
                echo "Failed to remove $remove_path"
                return 1
            fi
        else
            echo "Please close Steam before removing an install path"
            return 1
        fi
    else
        echo "Install path not found for version $version"
    fi

    return 0
}

###############################################################################
# Purpose: Extract a Proton-ge-custom package (.tar.gz) to g_install path or
#          optionally to a specified path.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (optional) The path to extract the package to (default: g_install_path)
# Output:  None
# Return:  0 = Success
#          1 = Failure
ExtractGEPackage() {

    local version extract_file extract_path

    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Define the package name to extract
    extract_file=$g_install_path/Proton-${version}.tar.gz

    # Define the path to extract the package to
    extract_path=${2:-$g_install_path}
    [[ ! -d $extract_path && -w $extract_path ]] && { ((g_verbose)) && vMsg "Parameter error (not a valid path)"; return 1; }

    # Display "Extracting" with trailing dots indicating the extraction progress
    printf '%s' "Extracting $extract_file to $extract_path"
    if tar --checkpoint=.10000 -C "$extract_path" -xzf "$extract_file" 2>/dev/null; then

        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        # Return to the beginning of the line, erase from that position to the end of the line
        printf '\r\033[0K%s\n' "Package extraction failed"

        # If the extraction failed, remove the partially extracted path
        [[ -d $extract_path/Proton-${version} ]] && {
            if ($g_command_rm -- "$extract_path/Proton-${version}"); then
                ((g_verbose)) && vMsg "Removal succeeded"
                echo "Removed failed extraction path at $extract_path/Proton-${version}"
            else
                echo "Failed to remove partial extraction path: $extract_path/Proton-${version}"

                # TODO: update/remove message when install verification is updated
                echo "This script may interpret it as a valid g_install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Print the currently installed Proton-ge-custom versions, saved
#          packages, and their individual disk usage to stdout.
# Input:   None
# Output:  None
# Return:  Always 0
ListInstalledGEVersions() {

    local node installed_version_disk_usage saved_package_disk_usage saved_packages_total_disk_usage size_bytes expected_size_bytes
    local -i i=0

    ((g_verbose)) && vMsg "Install path: $g_install_path"

    echo "Installed version(s):"
    for node in "$g_install_path"/Proton-*; do
        [[ -d $node ]] && {
            ((i++))
            # Get the disk usage of the package in human readable format
            IFS=$'\t' read -r -- installed_version_disk_usage path < <(du -sh -- "$node")
            echo "  ${node##*/} ($installed_version_disk_usage)"
        }
    done
    ((i)) || echo "  None found"

    echo "Saved package(s):"
    i=0
    for node in "$g_install_path"/Proton-*.tar.gz; do
        if [[ -f $node ]]; then
            ((i++))
            size_bytes=$(stat -c '%s' -- "$node")
            expected_size_bytes=$(QueryGEAttribute "${node##*/}" "size")
            if ((size_bytes != expected_size_bytes)); then
                echo "  ${node##*/} (WARNING: Size [$size_bytes] is not the expected size [$expected_size_bytes])"
            else
                IFS=$'\t' read -r -- saved_package_disk_usage path < <(du -h -- "$node")
                echo "  ${node##*/} ($saved_package_disk_usage)"
            fi
        fi
    done

    # Report total disk usage for saved packages if one or more were found
    if ((i >= 1)); then
        while IFS=$'\t' read -r -- size path; do
            [[ $path = "total" ]] && saved_packages_total_disk_usage=$size
        done < <(du -csh -- "$g_install_path/"*.tar.gz)
        echo "Saved packages total: $saved_packages_total_disk_usage"
    else
        echo "  None found"
    fi

    return 0
}

###############################################################################
# Purpose: Print the disk usage and file count for g_install_path and/or a
#          specified version to stdout.
# Input:   1 (optional) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 A required external command was not found or the version requested was not found
ReportGEDiskUsage() {

    local version file_counter path disk_usage="0"
    local -i flag_missing_command=0

    version=${1-}
    CleanUpVersion

    # NOTE: do not return 1 if version is NULL, functionality below depends on it

    # Optional commands that are required for this function
    if ! command -v du &>/dev/null; then
        echo "Command 'du' not found"
        flag_missing_command=1
    fi

    if ! command -v find &>/dev/null; then
        echo "Command 'find' not found"
        flag_missing_command=1
    fi

    # If all command checks succeeded
    if ((! flag_missing_command)); then

        # Set the path to be reported based on whether a version was provided or not
        if [[ -z $version ]]; then

            # Report the file count and disk usage for g_install_path
            if [[ -d $g_install_path ]]; then
                disk_usage=$(du -sh -- "$g_install_path")
                file_counter=$(find "$g_install_path" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' \
                       "Path: $g_install_path" \
                       "Files: $file_counter" \
                       "Disk usage: ${disk_usage%%[[:blank:]]*}"
            else
                ((g_verbose)) && vMsg "Path: $g_install_path"
                echo "Version $version not found"
                return 1
            fi
        fi

        # If a version was supplied as a parameter, report only for that version
        if [[ -n $version ]]; then

            # Report the file count and disk usage for a specific version
            path=$g_install_path/Proton-${version}
            if [[ -d $path ]]; then
                disk_usage=$(du -sh -- "$path")
                file_counter=$(find "$path" -type f | wc -l)
                echo "Version $version report:"
                printf '  %s\n  %s\n  %s\n' \
                       "Path: $path" \
                       "Files: $file_counter" \
                       "Disk usage: ${disk_usage%%[[:blank:]]*}"
            else
                ((g_verbose)) && vMsg "Path: $path"
                echo "Version $version not found"
                return 1
            fi
        fi

    # If any command check failed
    else
        echo "Report not available"
    fi

    return $(( flag_missing_command ? 1 : 0 ))
}

###############################################################################
# Purpose: Remove a saved package for a specified Proton-ge-custom version
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Success
#          1 Failure
RemoveSavedPackage() {

    local version package

    version=${1-}
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    # Define the package path and name that will be removed
    package=$g_install_path/Proton-${version}.tar.gz

    if [[ -f $package ]]; then
        if [[ -w $package ]]; then
            if ($g_command_rm -- "$package"); then
                echo "Removed $package"
                return 0
            else
                echo "Failed to remove version $version ($g_command_rm returned >0)"
                return 1
            fi
        else
            echo "Failed to remove version $version (no write permission)"
            return 1
        fi
    else
        echo "Failed to remove version $version (file not found)"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Remove all saved packages in g_install_path
# Input:   None
# Output:  None
# Return:  0 Success (all packages or 0 packages were removed)
#          1 Failure (any one package removal failed)
RemoveAllSavedPackages() {

    local package
    local -i success_counter=0 failure_counter=0

    ((g_verbose)) && vMsg "Install path: $g_install_path"

    for package in "$g_install_path"/Proton-*.tar.gz; do
        if [[ -f $package ]]; then
            if ($g_command_rm -- "$package"); then
                echo "Removed $package"
                ((success_counter++))
            else
                echo "Remove $package failed"
                ((failure_counter++))
            fi
        fi
    done

    if ((success_counter == 0)); then
        echo "0 packages removed"
    elif ((success_counter == 1)); then
        echo "$success_counter package removed"
    elif ((success_counter > 1)); then
        echo "$success_counter packages removed"
    fi

    ((failure_counter)) && echo "Failed to remove $failure_counter package(s)"

    return $(( failure_counter ? 1 : 0 ))
}

###############################################################################
# Purpose: Remove g_install_path
# Input:   None
# Output:  None
# Return:  0 Success
#          1 Failure (Remove failed or re-creating g_install_path failed)
RemoveGEInstallPath() {

    local disk_usage="?"

    if command -v du &>/dev/null; then
        disk_usage=$(du -sh -- "$g_install_path")
    else
        ((g_verbose)) && vMsg "Command 'du' not found"
        disk_usage="unknown"
    fi

    if ($g_command_rm -- "$g_install_path"); then
        echo "Remove install path succeeded ( ${disk_usage%%[[:blank:]]*} removed )"
        ((g_verbose)) && vMsg "Recreating install path at $g_install_path"

        # Re-create the g_install_path in case a requested subsequent script function needs it
        if mkdir -p -- "$g_install_path" &>/dev/null; then
            ((g_verbose)) && vMsg "mkdir -p $g_install_path succeeded"
        else
            if ((g_verbose)); then
                vMsg "mkdir -p $g_install_path failed"
            else
                echo "Warning: failed to re-create install path at $g_install_path"
                return 1
            fi
        fi
    else
        echo "Removal of install path $g_install_path failed"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Verify all installed versions or a specified version by comparing
#          each file from the saved package to the installed file and report
#          the number of files that match, are missing, and don't match to stdout.
# Input:   None
# Output:  None
# Return:  0 Success
#          1 Failure
# NOTE: __pycache__ is created at runtime in an installed version path and will
#       not be present in the saved packages.
# NOTE: bash 5+ is required for EPOCHSECONDS
# NOTE: bash 4.2+ is required for printf $()T
VerifyGEInstall() {

    local version node path temp_path file_extracted file_installed saved_cmp_alias=''
    local -i expected_size_bytes=0 temp_base_path_remaining_bytes=0 match_counter=0 \
             missing_counter=0 mismatch_counter=0 files_arrays_count_match=0 total_files=0 \
             counter_extracted=0 counter_installed=0 start_time_seconds=0 end_time_seconds=0 \
             progress_percent=0 prev_progress=1 flag_missing_command=0
    local -a files_extracted files_installed

    version=${1-}
    CleanUpVersion

    # If g_temp_base_path = g_install_path
    # WARNING: Setting g_temp_base_path and g_install_path to the same path would cause
    #          this function to overwrite installed versions and then attempt
    #          to compare those extracted files (and any others already there) to themselves.
    [[ $g_temp_base_path -ef $g_install_path ]] && {
        vMsg "Setting tmp_path and install_path to the same path is not supported"
        return 1
    }

    # Required external commands
    if ! command -v cmp &>/dev/null; then
        echo "Command 'cmp' is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v sort &>/dev/null; then
        echo "Command 'sort' is required to use this function"
        flag_missing_command=1
    fi
    if ! command -v date &>/dev/null; then
        echo "Command 'date' is required to use this function"
        flag_missing_command=1
    fi

    # If any one required command is missing
    ((flag_missing_command)) && return 1

    # Check for install paths that don't have a saved package, download if missing
    for node in "$g_install_path/Proton-"*; do
        [[ -d $node ]] && {

            # Verify that it is installed
            IsInstalled "${node##*/}" && {

                # If no saved package exists for this version
                [[ ! -f $g_install_path/${node##*/}.tar.gz ]] && {
                    echo "Package not found for installed version ${node##*/}"
                    if ! DownloadGEPackage "${node##*/Proton-}"; then
                        return 1
                    fi
                }
            }
        }
    done

    # For each saved package available, check each file in the package against the installed file
    for node in "$g_install_path"/Proton-${version:-*}.tar.gz; do
        [[ -f $node ]] && {
            version=${node##*/}
            CleanUpVersion
            echo "Found a package for version $version"
            if ! IsInstalled "$version"; then
                echo "Version $version is not installed"
                continue
            else
                echo "Version $version is installed"

                # Check for enough free space on the filesystem that contains tmp_path
                IFS=$'\t' read -r -- expected_size_bytes path < <(du -bs -- "$g_install_path/Proton-${version}")
                temp_base_path_remaining_bytes=$(SpaceRemaining "$g_temp_base_path" "b")

                ((g_verbose)) && {
                    vMsg "$version extracted size: $expected_size_bytes bytes"
                    vMsg "$g_temp_base_path remaining bytes: $temp_base_path_remaining_bytes"
                }

                ((expected_size_bytes > temp_base_path_remaining_bytes)) && {
                    echo "WARNING: Not enough free space at $g_temp_base_path to continue"
                    CleanUp
                    return 1
                }

                # Reset for each package to check
                CleanUp
                temp_path=$(MkTempPath)
                match_counter=0
                mismatch_counter=0
                missing_counter=0
                progress_percent=0
                prev_progress=1
                total_files=0
                counter_extracted=0
                counter_installed=0
                files_installed=()
                files_extracted=()

                # Extract the package to a temporary path
                if ! ExtractGEPackage "$version" "$temp_path"; then
                    return 1
                fi

                # Create two indexed arrays, each containing a seperate list of files,
                # one from the extracted path and the other from the installed path
                echo "Indexing files to compare"

                # Array of extracted files
                while IFS= read -r file_extracted; do
                    [[ -n $file_extracted ]] && files_extracted+=("$file_extracted")
                done < <(find "$temp_path/Proton-${version}/" -type f ! -iwholename '*__pycache__*' 2>/dev/null | LC_ALL=C sort)

                # Array of installed files
                while IFS= read -r file_installed; do
                    [[ -n $file_installed ]] && files_installed+=("$file_installed")
                done < <(find "$g_install_path/Proton-${version}/" -type f ! -iwholename '*__pycache__*' 2>/dev/null | LC_ALL=C sort)

                # Report the number of files found in each path
                echo "Found ${#files_extracted[@]} (extracted) and ${#files_installed[@]} (installed) files"

                # Based on array element sizes, decide on a method to compare files
                # The faster method is a one-to-one comparison of each array element.
                # The slower method takes each element of the extracted array and then searches through
                # the entire installed array until it finds a matching file name.
                if (( ${#files_extracted[@]} != ${#files_installed[@]} )); then
                    echo "Using slower method for comparing"
                    files_arrays_count_match=0
                else
                    echo "Using faster method for comparing"
                    files_arrays_count_match=1
                fi

                printf '%s\033[s' "Comparing files"

                # Begin comparing, using the faster method
                # If the number of elements match
                if (( files_arrays_count_match == 1 )); then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"; do
                        cmp -s -- "${files_extracted[counter_extracted]}" "${files_installed[counter_extracted]}"
                        case $? in
                            (0) ((match_counter++)) ;;
                            (1) ((mismatch_counter++)) ;;
                            (2) ((missing_counter++)) ;;
                        esac
                        # Some test results - this method is already
                        # reasonably fast so not much testing was done
                        # 1 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 2 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 3 - do nothing - 5.9-GE-3-ST - 6 seconds

                        # 1 - 5.9-GE-3-ST - 6 seconds
                        # 2 - 5.9-GE-3-ST - 7 seconds
                        # 3 - 5.9-GE-3-ST - 7 seconds
                        #unset 'files_installed[counter_extracted]'
                        #unset 'files_extracted[counter_extracted]'

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))

                        # Only update the progress_percent when it actually changes
                        ((progress_percent != prev_progress)) && printf '\033[u\033[s%s' "... ${progress_percent}%"
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)

                # Begin comparing, using the slower method
                elif (( files_arrays_count_match == 0 )); then
                    total_files=${#files_extracted[@]}
                    start_time_seconds=$(date +%s)
                    for counter_extracted in "${!files_extracted[@]}"; do

                        # Strip away the part of the path that is different for the current file
                        sCOMPARE_EXTRACTED=${files_extracted[counter_extracted]/#$temp_path\/}
                        for counter_installed in "${!files_installed[@]}"; do

                            # Strip away the part of the path that is different for the current file
                            sCOMPARE_INSTALLED=${files_installed[counter_installed]/#$g_install_path\/}

                            if [[ $sCOMPARE_INSTALLED = "$sCOMPARE_EXTRACTED" ]]; then
                                cmp -s -- "${files_installed[counter_installed]}" "${files_extracted[counter_extracted]}"
                                case $? in
                                    (0) ((match_counter++)) ;;
                                    (1) ((mismatch_counter++)) ;;
                                    (2) ((missing_counter++)) ;;
                                esac
                                # Some test results - fastest is what remains
                                # fastest - 5.9-GE-3-ST - 246 seconds
                                unset 'files_installed[counter_installed]'

                                # do nothing1 - 5.9-GE-3-ST - 376 seconds
                                # do nothing2 - 5.9-GE-3-ST - 484 seconds

                                # 5.9-GE-3-ST - 486 seconds
                                #files_installed=(${files_installed[@]:0:$counter_installed} ${files_installed[@]:$((counter_installed+1))})

                                # 5.9-GE-3-ST - 398 seconds
                                #files_installed=("${files_installed[@]:0:$counter_installed}" "${files_installed[@]:$((counter_installed+1))}")

                                #unset 'files_extracted[counter_extracted]'
                                #files_extracted=(${files_extracted[@]:0:$counter_extracted} ${files_extracted[@]:$((counter_extracted+1))})
                                #total_files=${#files_extracted[@]}
                            fi
                        done

                        # Progress report
                        progress_percent=$(( (counter_extracted * 100) / total_files ))

                        # Only update the progress_percent when it actually changes
                        ((progress_percent != prev_progress)) && printf '\033[u\033[s%s' "... ${progress_percent}%"
                        prev_progress=$progress_percent
                    done
                    end_time_seconds=$(date +%s)
                fi

                # Restore saved cmp alias
                # TODO: do other shells alias command output in a reusable format?
                [[ -n $saved_cmp_alias ]] && {
                    echo "Restoring saved alias for command cmp"
                    if ! $saved_cmp_alias; then
                        echo "Failed to restore alias for 'cmp'"
                    fi
                }

                printf "\033[u\033[0K%s\n" ". Finished in $(( end_time_seconds - start_time_seconds )) seconds."

                # Report
                echo "$match_counter files match. $missing_counter files are missing. $mismatch_counter do not match."

                if ((match_counter > 0 && missing_counter == 0 && mismatch_counter == 0)); then
                    echo "Installation for version $version appears ok"
                elif ((missing_counter > 0 || mismatch_counter > 0)); then
                    printf '%s\n%s\n' \
                           "WARNING: Version $version has missing or potentially corrupt files." \
                           "${0##*/} -R $version -i $version to reinstall it (add -f to download a new package)"
                fi
            fi
        }
    done

    return 0
}

###############################################################################
# Purpose: A wrapper for QueryJSONAttribute that provides a single function call
#          to retrieve values from keys/attributes in both g_file_latest_json and
#          g_file_releases_json.
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          2 (required) A supported attribute name (refer to QueryJSONAttribute)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 Failure (a value was not found for the requested attribute or an error occured)
# TODO Seperate return values for not found and error
QueryGEAttribute() {

    [[ -z $1 || -z $2 || $# -ne 2 ]] && { ((g_verbose)) && vMsg "Parameter error 1: $1 2: $2 \$#: $#"; return 1; }

    local version value key=${2-}

    version=${1-}
    CleanUpVersion

    if ! UpdateCachedGEReleases; then
        ((g_verbose)) && vMsg "UpdateCachedGEReleases returned failure status"
        [[ ! -f $g_file_latest_json ]] && {
            ((g_verbose)) && vMsg "g_file_latest_json: $g_file_latest_json"
        }
        [[ ! -f $g_file_releases_json ]] && {
            ((g_verbose)) && {
                vMsg "g_file_releases_json: $g_file_releases_json"
            }
        }
    fi

    ((g_verbose)) && vMsg "Checking $g_file_latest_json"

    # Search g_file_latest_json
    value=$(QueryJSONAttribute "$g_file_latest_json" "$version" "$key") # NOTE: DO NOT return 1 on failure

    # If the returned value from QueryJSONAttribute was NULL and the return status
    # was 0 (success), try g_file_releases_json
    if [[ -z $value ]]; then
        ((g_verbose)) && vMsg "Checking $g_file_releases_json"
        ((g_verbose)) && vMsg "For $key of version $version"
        if value=$(QueryJSONAttribute "$g_file_releases_json" "$version" "$key"); then
            ((g_verbose)) && vMsg "QueryJSONAttribute returned success"
        else
            ((g_verbose)) && vMsg "QueryJSONAttribute returned failure. value: $value"
        fi
    fi

    if [[ -n $value ]]; then
        printf '%s' "$value"
        return 0
    else
        printf '' # TODO: is it really necessary to return NULL?
        return 1
    fi

    return 1
}

###############################################################################
# Purpose: Retrieve a supported attribute value from a specified JSON file
# Input:   1 (required) JSON file
#          2 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
#          3 (required) A supported attribute name (size or browser_download_url)
# Output:  The value of the attribute requested or NULL (stdout)
# Return:  0 Success
#          1 Failure (a value was not found for the requested attribute or an error occured)
#
# NOTE This function relies on the JSON being structured in a precise, predictable order
# Example order of attributes expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE: The default media-type requested is "application/vnd.github.v3.text+json" and
#       the current sed script also reformats the body_text section to plain text. Those
#       choices were made to more easily support (eventually) showing release notes.
QueryJSONAttribute() {

    # If the number of parameters is not exactly three, the second parameter is not a regular file, or any of the three parameters are empty
    if [[ $# -ne 3 ]] || [[ ! -f $1 ]] || [[ -z $1 || -z $2 || -z $3 ]]; then
        ((g_verbose)) && vMsg "Parameter error 1: $1 2: $2 3: $3 \$#: $#"
        return 1
    fi

    # Check if the attribute requested is currently supported
    [[ ${3,,} != @(size|browser_download_url) ]] && { ((g_verbose)) && vMsg "Parameter error (unsupported attribute requested)"; return 1; }

    local version file_json=${1-} value_browser_url='' key
    local -i counter_lines=0 line_version_found=0 line_size_found=0 line_browserurl_found=0 flag_version_found=0 flag_size_found=0 value_size_bytes=0
    #local flag_browserurl_found=0

    version=$2
    CleanUpVersion

    [[ -z $version ]] && { ((g_verbose)) && vMsg "version is NULL"; return 1; }

    key=${3,,}

    ((g_verbose)) && vMsg "Searching in $file_json"

    # WARNING: Do not output to stdout or stderr inside the following loop
    while IFS= read -r --; do
        ((counter_lines++))
        # version match
        # version example: 5.9-GE-5-ST
        # NOTE: must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        ((! flag_version_found)) && {
            [[ $REPLY =~ ^.*\"name\":[[:blank:]]*\"Proton-${version}\.tar\.gz\".*$ ]] && {
                flag_version_found=1
                line_version_found=$counter_lines
                continue
            }
        }

        # NOTE: must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        ((flag_version_found && ! flag_size_found)) && {
            [[ ${REPLY,,} =~ ^.*\"size\":[[:blank:]]*[[:digit:]]+.*$ ]] && {
                flag_size_found=1
                line_size_found=$counter_lines
                # Remove all characters that are not digits
                value_size_bytes=${REPLY//[!0-9]/}
                continue
            }
        }

        # NOTE: must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        ((flag_version_found && flag_size_found)) && {
            [[ $REPLY =~ ^.*\"browser_download_url\":[[:blank:]]*\".*Proton-${version}\.tar\.gz\".*$ ]] && {
                #flag_browserurl_found=1
                line_browserurl_found=$counter_lines
                REPLY=${REPLY//[[:space:]]}
                REPLY=${REPLY/#*\"browser_download_url\":\"}
                value_browser_url=${REPLY%%\"*}
                break
            }
        }
    done < "$file_json"

    # Debug messages
    ((g_verbose)) && {
        if ((flag_version_found)); then
            vMsg "Version match found at line $line_version_found"
        else
            vMsg "Version match not found"
        fi
        if [[ -z $value_size_bytes ]]; then
            vMsg "value_size_bytes is NULL"
        else
            vMsg "value_size_bytes: $value_size_bytes"
        fi
        if [[ -z $value_browser_url ]]; then
            vMsg "value_browser_url is NULL"
        else
            vMsg "value_browser_url: $value_browser_url"
        fi
        vMsg "line_version_found: $line_version_found line_size_found: $line_size_found line_browserurl_found: $line_browserurl_found"
    }

    # Print the value of the requested attribute to stdout
    if [[ -n $value_size_bytes && -n $value_browser_url ]]; then
        case $key in
            (size)
                printf '%s' "$value_size_bytes"
            ;;
            (browser_download_url)
                printf '%s' "$value_browser_url"
            ;;
            (*)
                # NOTE: NULL response indicates error OR not found. This is NOT ideal
                printf '' # TODO: is it really necessary to return NULL?
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Check the access time of a specified file and determine whether the
#          specified interval has elapsed.
# Input:   1 (required) File to check
#          2 (required) Interval in seconds
# Output:  None
# Return:  1 (The specified interval has not elapsed since the last access)
#          0 (The specified interval has elapsed since the last access, or an error occured)
CheckAccessTime() {

    local -i current_seconds=0 last_check_seconds=0 interval=${2:-0}
    local file=${1-}

    [[ -z $file || ! -r $file || $interval -lt 1 ]] && { ((g_verbose)) && vMsg "Parameter error file"; exit 1; }

    ((g_verbose)) && vMsg "Checking access time for $file (interval: $interval)"

    # Using the access time of g_file_latest_json, restrict how often RequestURL is called to check for a newer
    # version of g_file_latest_json. The allowed interval is defined in g_checked_recently_seconds (default: 3600 seconds/60 minutes)
    current_seconds=$(date +%s)
    last_check_seconds=$(stat --cached=never -c '%X' -- "$file")
    if (( (current_seconds - last_check_seconds) < interval )); then
        ((g_verbose)) && {
            vMsg "Access denied, last access is less than the required interval"
            vMsg "$(( current_seconds - last_check_seconds )) out of $interval seconds have elapsed since the last access"
            vMsg "The next access will be allowed in $(( interval - (current_seconds - last_check_seconds) )) seconds"
        }
        return 1
    else
        ((g_verbose)) && {
            vMsg "Interval has elapsed, allowing access to $file"
            vMsg "Access was restored $(( (current_seconds - last_check_seconds) - interval )) seconds ago"
        }
        return 0
    fi

    ((g_verbose)) && {
        vMsg "Warning, returning default value of 0"
        vMsg "file: $file"
        vMsg "current_seconds: $current_seconds"
        vMsg "last_check_seconds: $last_check_seconds"
        vMsg "interval: $interval"
    }

    return 0
}

###############################################################################
# Purpose: Run sed using the script g_file_sed_unminify_script (generated by the
#          function CreateSedUnminifyJSONscript) on a specified file.
# Input:   1 (required) A JSON file (minified and not minified are both supported)
# Output:  None
# Return:  0 Success
#          1 Failure
ReformatJSONUsingSed() {

    local file_json=${1-}

    [[ -z $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }
    [[ -f $file_json ]] || { ((g_verbose)) && vMsg "Parameter error (not a file)"; return 1; }

    ((g_verbose)) && vMsg "file_json: $file_json"
    ((g_verbose)) && vMsg "g_file_sed_unminify_script: $g_file_sed_unminify_script"

    if [[ -w $file_json ]]; then
        if sed -i --file="$g_file_sed_unminify_script" "$file_json"; then
            ((g_verbose)) && vMsg "'sed' returned success"
            return 0
        else
            ((g_verbose)) && vMsg "'sed' returned failure"
            return 1
        fi
    else
        ((g_verbose)) && vMsg "No write access to: $file_json"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Detect if a specified JSON file is minified or not. Used for debug
#          reporting only because the unminify script is run on the JSON
#          regardless of the result of this function.
# Input:   1 (required) A JSON file
# Output:  None
# Return:  0 Yes/True
#          1 No/False
IsJSONminified() {

    local file_json=${1-}
    local -i counter_lines=0

    [[ -z $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }
    [[ ! -f $file_json || ! -r $file_json ]] && { ((g_verbose)) && vMsg "Parameter error (not a file and/or not readable)"; return 1; }

    # Get the number of newlines in the file
    counter_lines=$(wc -l -- < "$file_json")
    ((g_verbose)) && vMsg "counter_lines: $counter_lines"

    # 0 is the actual value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added or if in the future
    # minified JSON is returned that has 1 newline.
    ((g_verbose)) && {
        if ((counter_lines <= 1)); then
            vMsg "JSON is minified"
        else
            vMsg "JSON is not minified"
        fi
    }

    return $(( (counter_lines <= 1) ? 0 : 1 ))
}

###############################################################################
# Purpose: If the sed script g_file_sed_unminify_script is not found or it's size
#          in bytes does not match an expected value, create/overwrite it
# Input:   None
# Output:  None
# Return:  Always 0
CreateSedUnminifyJSONscript() {

    if [[ ! -f $g_file_sed_unminify_script ]] || (($(stat -c '%s' -- "$g_file_sed_unminify_script") != g_size_bytes_sed_unminify_script)); then
        ((g_verbose)) && vMsg "sed script at $g_file_sed_unminify_script does not exist or is not the expected size ($g_size_bytes_sed_unminify_script)"
        cat <<"END_OF_SED_SCRIPT" > "$g_file_sed_unminify_script"
#### begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s|","|"\n"|g
#### end minimum required for ge-install-manager

# replace:  "assets": [
# with:     "assets":newline
s|"assets":\[|"assets":\n|g

# replace:  :{"
# with:     :newline"
s|:{"|:\n"|g

# replace:  "},"
# with:     "newline"
s|"},"|"\n"|g

# replace:  },"
# with:     newline"
s|},"|\n"|g

# replace:  {"
# with:     "
s|{"|"|g

#### Re-format text intended for formating ('\n') in "body_text" when media type
#### "application/vnd.github.v3.text+json" is requested
# replace:  \n
# with:     newline
s|\\n|\n|g

# replace:  ,"
# with:     newline"
s|,"|\n"|g

#### one per release listed
# replace:  "}]
# with:     "
s|"}\]|"|g

# replace:  "}
# with:     "
s|"}|"|g

#### very minor
# replace:  ["
# with:     "
s|\["|"|g
END_OF_SED_SCRIPT
    else
        ((g_verbose)) && vMsg "sed script already exists at g_file_sed_unminify_script and is the expected size ($g_size_bytes_sed_unminify_script bytes)"
    fi

    return 0
}

###############################################################################
# Purpose: Check if a version is installed
# Input:   1 (required) Proton-ge-custom version (in one of the acceptable formats described in usage)
# Output:  None
# Return:  0 Yes/True
#          1 No/False
# NOTE: Currently only checks if a path for the version exists
# TODO: Find a better way that is reliable
IsInstalled() {

    local version

    [[ -z $1 ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    version=${1-}
    CleanUpVersion

    ((g_verbose)) && vMsg "Checking for version $version at $g_install_path/Proton-${version}"

    if [[ -d $g_install_path/Proton-${version} ]]; then
        ((g_verbose)) && vMsg "Version $version found"
        return 0
    else
        ((g_verbose)) && vMsg "Version $version not found"
        return 1
    fi

    # NOTE: Do not return 0 here
}

###############################################################################
# Purpose: Check if Steam is running
# Input:   None
# Output:  None
# Return:  0 Yes/True (a Steam process was detected, or an error occured)
#          1 No/False (a Steam process was not detected)
IsSteamRunning() {

    local -i flag_found_steam=0

    (( $(pgrep steam | wc -l) > 0 )) && flag_found_steam=1

    ((g_verbose)) && { ((flag_found_steam)) || vMsg "Steam process not found"; }

    return $(( flag_found_steam ? 0 : 1 ))
}

###############################################################################
# Purpose: Use curl -z to request a specified URL. If the remote URL has an mtime
#          newer than the specified file, write the response to a temporary file.
#          Check the temporary file for basic response errors and if none are found
#          copy the temporary file to the specified file. Used to update
#          g_file_latest_json and g_file_releases_json only if the remote file is newer.
# Input:   1 (required) A URL (g_latest_version_url or g_releases_url)
#          2 (required) A file (does not have to exist)
# Output:  None
# Return:  0 Success
#          1 Failure
RequestURL() {

    local requested_url=${1-} file_local=${2-} file_temp
    local -i downloaded_package_size_bytes=0

    file_temp=$(MkTempFile)

    [[ -z $requested_url || -z $file_local || $# -ne 2 ]] && ((g_verbose)) && vMsg "Parameter error (NULL or not exactly two)"
    [[ ! -f $file_temp || ! -w $file_temp ]] && ((g_verbose)) && vMsg "Parameter error (temp file not a file or not writeable)"

    ((g_verbose)) && vMsg "Checking remote file against $file_local"

    if curl -sz "$file_local" \
            -H "$CURL_HEADER_USER_AGENT" \
            -H "$CURL_HEADER_CONTENT_TYPE" \
            -H "$CURL_HEADER_GITHUB_MEDIATYPE" \
            -L "$requested_url" \
            -o "$file_temp" 2>/dev/null; then

        # Force an update to the access time of file_local
        if touch -ac -- "$file_local"; then
            ((g_verbose)) && vMsg "Updated access time for $file_local"
        else
            ((g_verbose)) && vMsg "Failed to update access time for $file_local"
        fi

        ((g_verbose)) && vMsg "curl returned success"
        if (($(stat -c '%s' -- "$file_temp"))); then
            if [[ -f $file_temp && -r $file_temp ]]; then

                # Check the temporary file contents for some basic error responses
                # Not found
                downloaded_package_size_bytes=$(stat -c '%s' -- "$file_temp")
                if ((downloaded_package_size_bytes == 9)); then
                    ((g_verbose)) && vMsg "Server responded Not Found"
                    CleanUp
                    return 1
                fi

                # Github API request rate limit exceeded
                if ((downloaded_package_size_bytes == 248)); then
                    ((g_verbose)) && vMsg "Github API request rate limit exceeded. Unable to retrieve remote file."
                    CleanUp
                    return 1
                fi

                # NOTE: Only the status is checked, unminify is run regardless of the result
                IsJSONminified "$file_temp"

                if ReformatJSONUsingSed "$file_temp"; then
                    ((g_verbose)) && vMsg "ReformatJSONUsingSed returned success"

                    # If the local file already exists, create a backup first
                    [[ -f $file_local ]] && CreateBackup "$file_local"
                    if cp -f -- "$file_temp" "$file_local"; then
                        ((g_verbose)) && vMsg "Copied $file_temp to $file_local"
                        return 0
                    else
                        ((g_verbose)) && vMsg "Failed to copy $file_temp to $file_local"
                        return 1
                    fi
                else
                    ((g_verbose)) && vMsg "ReformatJSONUsingSed returned failure"
                    return 1
                fi
            else
                ((g_verbose)) && vMsg "file_temp not found or not readable: $file_temp"
                return 1
            fi
        else
            # remote file is not newer if curl returns success and the response is NULL
            ((g_verbose)) && vMsg "Remote file is not newer"
            return 0
        fi
    else
        ((g_verbose)) && vMsg "curl returned failure"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Backup a file/path in tar.gz format supporting upto a configurable
#          number (n) of backups with a basename (sans extension) suffix of _n.
#          The newest backup is the lowest index (n) and the oldest backup is
#          the highest index (n). The backups are stored in the parent path of
#          the file/path to be backed up.
# Input:   1 (required) The file or path to backup
# Output:  None
# Return:  0 Success
#          1 Failure
CreateBackup() {

    local backup_target=${1-} backup_target_basename backup_target_path file backup_index
    local -i max_backups=3 backups_counter=0 flag_rename_backups=0
    local -a files_existing_backups

    shopt -s nullglob dotglob

    [[ -z $backup_target ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    ((g_verbose)) && vMsg "Backup requested for: $backup_target"

    # Check that backup_target is either an existing file or an existing path
    if [[ -f $backup_target ]]; then
        ((g_verbose)) && vMsg "backup_target is a file"
    else
        ((g_verbose)) && vMsg "backup_target is not a file"
        if [[ -d $backup_target ]]; then
            ((g_verbose)) && vMsg "backup_target is a path"
        else
            ((g_verbose)) && vMsg "Parameter error (not a file or a path)"
            return 1
        fi
    fi

    # If a relative file/path was given
    [[ ${backup_target:0:1} != "/" || ${backup_target:0:2} == "./" ]] && {
        ((g_verbose)) && vMsg "Resolving relative path"
        backup_target=$(realpath -- "$backup_target" 2>/dev/null)
    }

    # If backup_target is a file, get the path to it
    if [[ ! -d $backup_target && -f $backup_target ]]; then
        backup_target_path=${backup_target%/*}
    else
        # If its a path, get the parent path of backup_target
        backup_target_path=$(realpath -- "$(dirname -- "$backup_target" 2>/dev/null)" 2>/dev/null)
    fi

    backup_target_basename=${backup_target##*/}

    # Determine the basename suffix to use {1..$max_backups}
    for file in "$backup_target_path/$backup_target_basename"_?.tar.gz; do
        if [[ $file =~ ^.*[^_]_[[:digit:]]{1}\.tar\.gz$ ]]; then
            backup_index=${file##*_}
            backup_index=${backup_index/%.tar.gz}
            ((g_verbose)) && vMsg "backup_index is $backup_index"
            [[ $backup_index =~ ^[[:digit:]]+$ ]] && {
                ((backups_counter++))
                files_existing_backups+=("$file")
                ((g_verbose)) && vMsg "Valid backup file found at $file"
                if ((backup_index == 1 )); then
                    ((g_verbose)) && vMsg "Index 1 found, existing backups will be renamed"
                    flag_rename_backups=1
                fi
            }
        fi
    done
    ((g_verbose)) && vMsg "Found $backups_counter backups"

    if ((flag_rename_backups)); then
        backup_index=$backups_counter
        if ((backup_index >= max_backups)); then

            # Remove the oldest (highest index) backup until max_backups is reached
            while ((backup_index >= max_backups)); do
                if ($g_command_rm -- "${files_existing_backups[backup_index-1]}"); then
                    ((g_verbose)) && vMsg "Removed highest index greater than $max_backups: ${files_existing_backups[backup_index-1]}"
                    backup_index=$((backup_index - 1))
                else
                    vMsg "Failed to remove backup file ${files_existing_backups[backup_index-1]}"
                    return 1
                fi
            done
        fi

        # Rename existing backups, leaving room for a new index 1 (increment each existing index by +1)
        for ((backup_index; backup_index>=1; backup_index--)); do
            if mv -- "${files_existing_backups[backup_index-1]}" "${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"; then
                ((g_verbose)) && vMsg "${files_existing_backups[backup_index-1]} renamed to ${files_existing_backups[backup_index-1]/${backup_index}/$((backup_index+1))}"
            else
                vMsg "Failed to rename backup file: ${files_existing_backups[backup_index-1]}"
                return 1
            fi
        done
    else
        ((g_verbose)) && vMsg "Index 1 not found, no need to rename existing backups"
    fi

    if tar -C "$backup_target_path" -cf "$backup_target_path/${backup_target_basename}_1.tar.gz" -z "$backup_target_basename"; then
        ((g_verbose)) && vMsg "Created new backup at: $backup_target_path/${backup_target_basename}_1.tar.gz"
        return 0
    else
        ((g_verbose)) && vMsg "Backup failed: $backup_target_path/${backup_target_basename}_1.tar.gz"
        return 1
    fi

    return 0
}

###############################################################################
# Purpose: Given a file/path (filesystem) and a unit (binary prefix), use stat
#          to calculate the remaining space on a filesystem by multiplying
#          the filesystem block size by the number of remaining blocks and
#          return the value in the unit requested.
# Input:   1 (required) File/path on the filesystem to check
#          1 (required) Binary prefix (see case below for supported formats)
# Output:  Integer value representing the space remaining in the unit requested
#          NOTE: Bash arithmatic is used because this script does not require
#                   the precision afforded by bc/etc.
# Return:  Return value of printf
# NOTE: bash arithmatic supports upto 1024^6/1024**6 (exbibyte)
# TODO: Add a third, optional parameter to request calculations using bc
SpaceRemaining() {

    local file_system=${1-} binary_prefix=${2-}
    local -i power_of=0

    [[ -z $file_system || -z $binary_prefix ]] && { ((g_verbose)) && vMsg "Parameter error (NULL)"; return 1; }

    [[ ! -d $file_system ]] && { ((g_verbose)) && vMsg "Parameter error (not a directory)"; return 1; }

    case ${binary_prefix,,} in
        (b|byte|bytes) power_of=0 ;;
        (k|kibi|kibibyte) power_of=1 ;;
        (m|mebi|mebibyte) power_of=2 ;;
        (g|gibi|gibibyte) power_of=3 ;;
        (t|tebi|tebibyte) power_of=4 ;;
        (p|pebi|pebibyte) power_of=5 ;;
        (e|exbi|exbibyte) power_of=6 ;;
    esac

    ((g_verbose)) && vMsg "Checking $file_system"

    printf '%s' "$(( ($(stat -L --cached=never -c '%s' -f -- "$file_system") * $(stat -L --cached=never -c '%a' -f -- "$file_system")) / ( 1024 ** power_of ) ))"

    return
}

###############################################################################
# Purpose: If g_file_script_config is not found, create a default
# Input:   None
# Output:  None
# Return:  0 (Success)
#          1 (Create path to g_file_script_config failed)
CreateDefaultConfigFile() {

    local rm_command path

    # If the config path doesn't exist, create it
    path=$(dirname "$g_file_script_config")
    [[ ! -d $path ]] && {
        if ! mkdir -p -- "$path"; then
            vMsg "Failed to create path: $path"
            return 1
        fi
    }

    cat <<DEFAULT_CONFIG > "$g_file_script_config" # This section is subject to variable expansion
#
# $SCRIPT_FULL_NAME v$SCRIPT_VERSION Default configuration file
#
# Quick start format:
# #comment
# key=value #comment
#
# Lines begining with an octothorpe "#" are considered comment lines and are ignored.
# Any characters that follow a space and an octothorpe " #" are considered comments.
# Empty lines and lines that begin with space/tab are ignored.
# Lines that contain one or more semi-colon(s) ";" will be ignored.
# Lines that contain potential escape sequences are ignored.
# A key with a null value and a value with a null key are ignored (eg. "key=" and "=value").
#
# Paths (install, cache, and tmp) do not have to exist but
# the script will need write permission to create them for you.
#
# When install_path is set to the special value "auto", the script will
# attempt to auto-detect the Steam installation path.
#
# Environment variables and script global variables will be expanded.
# \$SCRIPT_FULL_NAME is a script global variable that is always set to the basename of the script.
# Setting tmp_path to the same path as install_path is currently not supported (eg. tmp_path=\$g_install_path).
#
# Do not quote variables outside parameter expansions (:+, :-, :=, or :?) unless
# you want the quotes included in the value.
#
DEFAULT_CONFIG

    cat <<"DEFAULT_CONFIG" >> "$g_file_script_config" # This section is not subject to expansion

# Default install path
install_path=auto

# Default cache path
cache_path=${XDG_CACHE_HOME:-"$HOME"/.cache}/$SCRIPT_FULL_NAME

# Default URL used to retrieve 'latest' JSON
latest_version_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest

# Default URL used to retrieve 'releases' JSON
releases_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases

# Default temporary file path
tmp_path=/tmp

DEFAULT_CONFIG

    # If trash is found, use it instead of rm
    if command -v trash >/dev/null; then
        rm_command="trash"
    else
        rm_command="rm"
    fi

    cat <<DEFAULT_CONFIG >> "$g_file_script_config" # This section is subject to variable expansion
# Default command used instead of rm (for removing all but temporary files)
# NOTE: Any command and its parameters that support the last parameter being either a file or a path is supported
rm_command=$rm_command
DEFAULT_CONFIG

    return 0
}


###############################################################################
# Purpose: Parse the config file set in the global variable g_file_script_config,
#          validate recognized key/value pairs and then set/reset global
#          variables accordingly.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Runs DetectSteamInstallPath if g_install_path is set to the special value "auto"
ParseConfigFile() {


    local config_key config_value
    local -i existing_config_file_lines=0 counter_config_line=0 flag_failed=0 flag_update_install_path=0

    existing_config_file_lines=$(wc -l 2>/dev/null < "$g_file_script_config") # NOTE: do not || return 1 here

    ((g_verbose)) && vMsg "existing_config_file_lines: $existing_config_file_lines"

    # If existing_config_file_lines is empty or g_file_script_config doesn't exist, create a default config file
    [[ -z $existing_config_file_lines || ! -f $g_file_script_config ]] && {
        ((g_verbose)) && vMsg "Generating a default config file at: $g_file_script_config"
        if CreateDefaultConfigFile; then
            ((g_verbose)) && vMsg "CreateDefaultConfigFile returned success"
            echo "Default configuration created at $g_file_script_config"
            if [[ -n ${EDITOR-} ]]; then
                ((g_verbose)) && vMsg "EDITOR is set to: $EDITOR"
                while :; do
                    read -rp "Would you like to open it with ${EDITOR}? " </dev/tty
                    case ${REPLY,,} in
                        ("y"|"yes") ($EDITOR "$g_file_script_config"); exit 0 ;;
                        ("n"|"no") exit 0 ;;
                        ("*") echo "Enter (y)es or (n)o" ;;
                    esac
                done
            else
                echo "EDITOR not set, default configuration created at $g_file_script_config"
            fi
            exit 0
        else
            vMsg "Failed to create default config file at: $g_file_script_config"
            return 1
        fi
    }

    # Sanity checks
    [[ -z $g_file_script_config || ! -f $g_file_script_config || ! -w $g_file_script_config ]] && {
        ((g_verbose)) && vMsg "g_file_script_config error (NULL, not a file, or not writeable)"
        return 1
    }

    # Begin parsing g_file_script_config
    while IFS= read -r --; do

        # Increment the line counter
        ((counter_config_line++))

        # Ignore lines that begin with a # (comments)
        [[ $REPLY =~ ^#.*$ ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (#)"; continue; }

        # Ignore lines that contain one or more semi-colon ";". Anti-exploit measure.
        [[ $REPLY =~ ^.*\;+.*$ ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (;)"; continue; }

        # Ignore lines containing potential escape sequences. Anti-exploit measure.
        [[ $REPLY =~ ^.*\\[[:digit:]]+\[.*$ ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (potential escape code)"; continue; }

        # Trim away inline comments
        if [[ $REPLY =~ ^.*#.*$ ]]; then
            ((g_verbose)) && vMsg "Partially commented line $counter_config_line: $REPLY"
            # remove the ' #' and everything to the right of it
            # NOTE: valid comments are preceded by at least one [[:blank:]]
            # BUG: this will mangle herestrings that contain comments
            REPLY=${REPLY%%[[:blank:]]#*}
        fi

        # Ignore lines that are empty
        [[ -z $REPLY ]] && { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (empty)"; continue; }

        # Ignore lines that don't contain exactly one = and also don't have characters on either side of the = sign.
        # If there are characters on either side of the = sign, they may not be spaces or tabs
        [[ $REPLY =~ ^[^=[:blank:]]+=[^=[:blank:]]+$ ]] || { ((g_verbose)) && vMsg "Ignoring line $counter_config_line (improperly formatted)"; continue; }

        ((g_verbose)) && vMsg "Potentially valid config line ($counter_config_line): $REPLY"

        # Get the key (the characters to the left of the equals "=" sign)
        config_key=${REPLY%%=*}

        # Get the value (the characters to the right of the equals "=" sign)
        config_value=${REPLY#*=}

        ((g_verbose)) && vMsg "config line $counter_config_line - Key: $config_key Value: $config_value"

        # Expand any variables in the config using envsubst or eval
        # Skip expansion if the value doesn't contain one or more $
        if [[ $config_value =~ ^.+[$]+.+$ ]]; then
            if [[ $config_value =~ ^.+:[+-=?]{1}.+$ ]]; then
                ((g_verbose)) && vMsg "Using 'eval' to expand config_value: $config_value"
                config_value=$(eval printf '%s' "$config_value")
                ((g_verbose)) && vMsg "config_value expanded to: $config_value"
            else
                if command -v envsubst &>/dev/null; then
                    ((g_verbose)) && vMsg "Using 'envsubst' to expand config_value: $config_value"
                    config_value=$(envsubst <<< "$config_value")

                    # If there is still a $ in config_value it contained a variable envsubst couldn't expand
                    [[ $config_value =~ ^.*\$+.*$ ]] && {
                        ((g_verbose)) && vMsg "config_value still contains one or more $ after envsubst"
                        config_value=$(eval printf '%s' "$config_value")
                        ((g_verbose)) && vMsg "config_value expanded again with 'eval' to: $config_value"
                    }
                    ((g_verbose)) && vMsg "config_value expanded to: $config_value"
                else
                    ((g_verbose)) && vMsg "Command 'envsubst' not available, using 'eval' to expand config_value: $config_value"
                    config_value=$(eval printf '%s' "$config_value")
                    ((g_verbose)) && vMsg "config_value expanded to: $config_value"
                fi
            fi
        else
            # No $ were found, no expansion necessary
            ((g_verbose)) && vMsg "Skipping expansion of config_value: $config_value"
        fi

        # Validate values for recognized keys and set global variables accordingly
        case $config_key in
            (install_path)
                # If the value for install_path is the special value "auto", attempt to auto detect the steam install path
                # NOTE: If one is found/chosen the global variable g_override_default_install_path will be set accordingly.
                #       A value of NULL indicates a problem, error, or user chose manual configuration in which case
                #       the value will remain auto.
                [[ ${config_value,,} = "auto" ]] && {
                    ((g_verbose)) && vMsg "$config_key is set to $config_value, Running DetectSteamInstallPath"
                    DetectSteamInstallPath
                    if [[ -n $g_override_default_install_path && ${g_override_default_install_path,,} != "auto" ]]; then
                        config_value=$g_override_default_install_path/compatibilitytools.d
                        flag_update_install_path=1
                    else
                        return 1
                    fi
                }
                if [[ -d $config_value && -w $config_value ]]; then
                    ((g_verbose)) && vMsg "$config_value is a directory and the script has write permission to it"
                    g_install_path=$config_value
                    flag_update_install_path=1
                else
                    ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((g_verbose)) && vMsg "Script has write permission to $config_value"
                            g_install_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                            flag_failed=1
                            flag_update_install_path=0
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                        flag_failed=1
                        flag_update_install_path=0
                    fi
                fi
            ;;
            (cache_path)
                if [[ -d $config_value && -w $config_value ]]; then
                    ((g_verbose)) && {
                        # If cache_path would = g_install_path
                        if [[ $config_value -ef $g_install_path ]]; then
                            vMsg "cache_path is the same as g_install_path"
                        else
                            vMsg "$config_value is a directory and the script has write permission to it"
                        fi
                    }
                    g_script_cache_path=$config_value
                else
                    ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((g_verbose)) && vMsg "Script has write permission to $config_value"
                            g_script_cache_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                            flag_failed=1
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                        flag_failed=1
                    fi
                fi
            ;;
            (tmp_path) # g_temp_base_path
                # If tmp_path would = g_install_path (would cause issues with VerifyGEInstall)
                [[ $config_value -ef $g_install_path ]] && {
                    vMsg "Setting tmp_path and g_install_path to the same path is not supported"
                    flag_failed=1
                }
                if [[ -d $config_value && -w $config_value ]]; then
                    ((g_verbose)) && vMsg "$config_value is a directory and the script has write permission to it"
                    g_temp_base_path=$config_value
                else
                    ((g_verbose)) && vMsg "$config_value is not a valid path, attempting to create it"
                    if mkdir -p -- "$config_value" &>/dev/null; then
                        if [[ -w $config_value ]]; then
                            ((g_verbose)) && vMsg "Script has write permission to $config_value"
                            g_temp_base_path=$config_value
                        else
                            vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                            flag_failed=1
                        fi
                    else
                        vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                        flag_failed=1
                    fi
                fi
            ;;
            (rm_command)
                if (command -v -- "$config_value" &>/dev/null); then
                    g_command_rm=$config_value
                    ((g_verbose)) && vMsg "g_command_rm set to: $g_command_rm"
                else
                    ((g_verbose)) && vMsg "command -v $config_value failed"
                    vMsg "Invalid value for $config_key at line $counter_config_line: $config_value" \
                    vMsg "If you don't want the script to use 'rm' then fix it"
                    g_command_rm='rm'
                fi
            ;;
            (latest_version_url)
                if curl -sLI -- "$config_value" &>/dev/null; then
                    g_latest_version_url=$config_value
                    ((g_verbose)) && vMsg "g_latest_version_url set to: $g_latest_version_url"
                else
                    vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                    flag_failed=1
                fi
            ;;
            (releases_url)
                if curl -sLI -- "$config_value" &>/dev/null; then
                    g_releases_url=$config_value
                    ((g_verbose)) && vMsg "g_releases_url set to: $g_releases_url"
                else
                    vMsg "Invalid value for $config_key at line $counter_config_line: $config_value"
                    flag_failed=1
                fi
            ;;
            (*)
                ((g_verbose)) && vMsg "No key match for valid config ($counter_config_line): $REPLY"
            ;;
        esac
    done < "$g_file_script_config"

    # Update install_path in the configuration file if necessary
    ((flag_update_install_path)) && {
        [[ -n ${g_override_default_install_path-} ]] && {
            g_install_path=$g_override_default_install_path/compatibilitytools.d
            [[ -f $g_file_script_config ]] && CreateBackup "$g_file_script_config"
            if ! sed -i "s|install_path=auto|install_path=$g_install_path|" -- "$g_file_script_config"; then
                flag_failed=1
            fi
        }
    }

    # If any crucial config options are empty (missing from config, except g_script_config_path)
    [[ -z ${g_install_path-} ]] && {
        vMsg "Invalid/missing g_install_path ($g_file_script_config)"
        return 1
    }

    [[ -z ${g_temp_base_path-} ]] && {
        vMsg "Invalid/missing g_temp_base_path ($g_file_script_config)"
        return 1
    }

    # A warning in case the default global variable is manually changed
    [[ -z ${g_script_config_path-} ]] && {
        vMsg "Invalid/missing g_script_config_path"
        return 1
    }

    [[ -z ${g_script_cache_path-} ]] && {
        vMsg "Invalid/missing g_script_cache_path ($g_file_script_config)"
        return 1
    }

    # Debug report
    ((g_verbose)) && vMsg "Install path set to: $g_install_path"
    ((g_verbose)) && vMsg "Temp path set to: $g_temp_base_path"
    ((g_verbose)) && vMsg "Config path set to: $g_script_config_path" # NOTE: config_path is currently not configurable
    # update global variables that depend on this one
    #g_file_script_config=$g_script_config_path/$SCRIPT_FULL_NAME.conf
    #((g_verbose)) && vMsg "g_file_script_config set to: $g_file_script_config"
    #((g_verbose)) && vMsg "g_file_sed_unminify_script set to: $g_file_sed_unminify_script"

    ((g_verbose)) && vMsg "Cache path set to: $g_script_cache_path"
    # update global variables that depend on this one
    g_file_latest_json="$g_script_cache_path"/latest.json
    ((g_verbose)) && vMsg "g_file_latest_json set to: $g_file_latest_json"

    g_file_releases_json="$g_script_cache_path"/releases.json
    ((g_verbose)) && vMsg "g_file_releases_json set to: $g_file_releases_json"

    return $(( flag_failed ? 1 : 0 ))
}

###############################################################################
# Purpose: When invoked, "clean" a version string stored in the variable version.
# Input:   None
# Output:  None
# Return:  Always 0
CleanUpVersion() {

    local -i length_characters=0

    [[ -z $version ]] && { ((g_verbose)) && vMsg "version is NULL"; printf ''; return 1; }

    ((g_verbose)) && {
        length_characters=${#version}
        vMsg "Before: $version"
    }

    # global upper case
    version=${version^^}

    # anchored left, remove a single "PROTON-" and anything to the left of it
    version=${version#*'PROTON-'}

    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    version=${version%'.TAR.GZ'*}

    ((g_verbose)) && {
        vMsg "After: $version"
        ((length_characters != ${#version})) && vMsg "Removed $(( length_characters - ${#version} )) characters"
    }

    return 0
}

###############################################################################
# Purpose: Bash only primitive replacement for mktemp (file version)
# Input:   None
# Output:  A string containing a path and file with no trailing newline (stdout)
# Return:  0 (Success)
#          1 (Failure)
MkTempFile() {

    local create_temp_file

    [[ -d $g_temp_base_path && -w $g_temp_base_path ]] || {
        ((g_verbose)) && vMsg "g_temp_base_path is not a valid path or no write access: $g_temp_base_path"
        return 1
    }

    create_temp_file=$g_temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16) || return 1

    ((g_verbose)) && vMsg "Created temp file at: $create_temp_file"

    # Create the empty temp file
    : > "$create_temp_file"

    # "Return" the path and filename,
    printf '%s' "$create_temp_file"

    return 0
}

###############################################################################
# Purpose: Bash only primitive replacement for mktemp (path version)
# Input:   None
# Output:  A string containing a path with no trailing newline (stdout)
# Return:  0 (Success)
#          1 (Failure)
MkTempPath() {

    local create_temp_path

    [[ -d $g_temp_base_path && -w $g_temp_base_path ]] || {
        ((g_verbose)) && vMsg "g_temp_base_path is not a valid path or no write access: $g_temp_base_path"
        return 1
    }

    create_temp_path=$g_temp_base_path/$TEMP_PREFIX$(GenerateRandomAlphaNumericString 16) || return 1

    ((g_verbose)) && vMsg "Created temp path at: $create_temp_path"

    # Create the path
    mkdir -p "$create_temp_path" &>/dev/null

    # "Return" the path and filename,
    printf '%s' "$create_temp_path"

    return 0
}

###############################################################################
# Purpose: Generate a pseudo-random alphanumeric string using only Bash
# Input:   1 (optional) An integer indicating the length of the sequence to generate
# Output:  A string containing the generated alphanumeric sequence (stdout)
# Return:  0 (Success)
#          1 (Failure)
# NOTE: Valid input length range 1-32767 (default: 10)
GenerateRandomAlphaNumericString() {

    local list character result='' # NOTE: Must be initialized as NULL
    local -i length=${1:-10} i

    list=$(printf '%s' {a..z}{0..9}{A..Z}) || return 1

    # If the length requested is outside sane upper and lower bounds, reset it
    (( length < 1 )) && length=1
    (( length > 32767 )) && length=32767

    # Loop length times
    for (( i=1; i<=length; i++ )); do

        # Randomly choose one offset of length one from list
        character=${list:$RANDOM%${#list}:1}

        # Randomly invert the case
        (( RANDOM % 2 )) && character=${character~}

        # Concatenate result and character
        result=${result}${character}

    done

    # "Return" the resulting string,
    # meant to be captured using command substitution
    # eg. sSTRING_OF_LENGTH_TEN=$(GenerateRandomAlphaNumericString 10)
    printf '%s' "$result"

    return 0
}

###############################################################################
# Purpose: Attempt to auto-detect the Steam installation path and set the
#          global variable g_override_default_install_path to it. That variable
#          is then read by ParseConfigFile to set g_install_path in the config
#          file. If multiple potential install paths are detected the user will
#          be prompted to choose one of them. If none/exit is chosen or an abort
#          occurs install_path will remain set to auto.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: ~/.steam/root/compatibilitytools.d                                   # proton-ge-custom install notes
#       /usr/share/steam/compatibilitytools.d
#       /usr/local/share/steam/compatibilitytools.d
# flatpak
#       ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/  # proton-ge-custom install notes
#       ~/.var/app/com.valvesoftware.Steam/.local/share/Steam
#       ~/.var/app/com.valvesoftware.Steam/.steam
#       ~/.steam/root/compatibilitytools.d (steam install folder symlink) || ~/.local/share/Steam/compatibilitytools.d
# TODO: Colon-separated global paths in $STEAM_EXTRA_COMPAT_TOOLS_PATHS
DetectSteamInstallPath () {

    local check_path
    local -i i=0
    local -a valid_paths search_paths=("$HOME/.steam/root" \
                                       "${XDG_DATA_HOME:-$HOME/.local/share/Steam}" \
                                       "/usr/share/steam" \
                                       "/usr/local/share/steam" \
                                       "$HOME/.var/app/com.valvesoftware.Steam/data/Steam" \
                                       "$HOME/.var/app/com.valvesoftware.Steam/.local/share/Steam" \
                                       "$HOME/.var/app/com.valvesoftware.Steam/.steam")

    # Report the set status of XDG vars
    # XDG_DATA_HOME
    if [[ ${XDG_DATA_HOME-unset} != 'unset' ]]; then
        if [[ ${XDG_DATA_HOME-} != "$HOME"/.local/share ]]; then
            ((g_verbose)) && vMsg "XDG_DATA_HOME is not set to the default: $XDG_DATA_HOME"
        else
            ((g_verbose)) && vMsg "XDG_DATA_HOME is set to: $XDG_DATA_HOME"
        fi
    else
        ((g_verbose)) && vMsg "XDG_DATA_HOME is unset"
    fi

    # XDG_CONFIG_HOME
    if [[ ${XDG_CONFIG_HOME-unset} != 'unset' ]]; then
        if [[ ${XDG_CONFIG_HOME-} != "$HOME"/.config ]]; then
            ((g_verbose)) && vMsg "XDG_CONFIG_HOME is not set to the default: $XDG_CONFIG_HOME"
        else
            ((g_verbose)) && vMsg "XDG_CONFIG_HOME is set to: $XDG_CONFIG_HOME"
        fi
    else
        ((g_verbose)) && vMsg "XDG_CONFIG_HOME is unset"
    fi

    # XDG_CACHE_HOME
    if [[ ${XDG_CACHE_HOME-unset} != 'unset' ]]; then
        if [[ ${XDG_CACHE_HOME-} != "$HOME"/.cache ]]; then
            ((g_verbose)) && vMsg "XDG_CACHE_HOME is not set to the default: $XDG_CACHE_HOME"
        else
            ((g_verbose)) && vMsg "XDG_CACHE_HOME is set to: $XDG_CACHE_HOME"
        fi
    else
        ((g_verbose)) && vMsg "XDG_CACHE_HOME is unset"
    fi

    # Search each known possible Steam install path path for steam.sh
    # NOTE: If steam.sh is found the path containing it is considered valid
    #
    # ~/.steam/root/compatibilitytools.d
    ((g_verbose)) && vMsg "search_paths: ${#search_paths[@]}"
    for check_path in "${search_paths[@]}"; do
        ((g_verbose)) && vMsg "Checking $check_path"
        if [[ -f $check_path/steam.sh ]]; then
            ((g_verbose)) && vMsg "steam.sh found in $check_path"
            valid_paths+=("$check_path")
        else
            ((g_verbose)) && vMsg "steam.sh not found in $check_path"
        fi
    done

    ((g_verbose)) && vMsg "#valid_paths: ${#valid_paths[@]}"
    ((g_verbose)) && vMsg "valid_paths[*]: ${valid_paths[*]}"

    if ((${#valid_paths[@]} == 0)); then
        printf '%s\n%s\n%s\n' \
               "ERROR: Unable to detect Steam installation path" \
               "You will need to configure install_path manually in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        g_override_default_install_path=''

    # Prefer to use the symlink if two paths were found and one is a link to the other
    elif ((${#valid_paths[@]} == 1)) || [[ ${#valid_paths[@]} -eq 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]; then
        printf '%s\n%s\n%s\n' \
               "Steam install path detected as ${valid_paths[0]}" \
               "If that path is incorrect, then change install_path in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
        g_override_default_install_path=${valid_paths[0]}

    # Multiple paths detected with or without the Steam home link pointing to one of them
    elif [[ ${#valid_paths[@]} -gt 1 && ! ${valid_paths[0]} -ef ${valid_paths[1]} ]] || [[ ${#valid_paths[@]} -gt 2 && ${valid_paths[0]} -ef ${valid_paths[1]} ]]; then
        echo "Multiple Steam install paths detected:"
        for (( i=0; i < ${#valid_paths[@]}; i++ )); do
            echo "($(( i + 1 ))) ${valid_paths[i]}"
        done

        echo "Choose a path from above or enter exit/quit"
        while :; do
            read -rp "Enter a number from 1-${#valid_paths[@]}: " </dev/tty
            [[ $REPLY = @(exit|quit) ]] && {
                g_override_default_install_path=''
                break
            }
            REPLY=${REPLY//[!0-9]/} # Remove characters that are not a digit
            case $REPLY in
                (*[[:digit:]]*) # TODO: Make this case test more precise
                    if ((REPLY < 1 || REPLY >= $(( ${#valid_paths[@]} + 1 )))); then
                        echo "Invalid choice"
                    else
                        ((g_verbose)) && vMsg "Setting g_override_default_install_path to ${valid_paths[$((REPLY-1))]}"
                        g_override_default_install_path=${valid_paths[$((REPLY-1))]}
                        printf '%s\n%s\n%s\n' \
                               "You have chosen the path $g_override_default_install_path" \
                               "If that is not correct then change install_path in the configuration file" \
                               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
                        ((g_verbose)) && vMsg "g_override_default_install_path set to $g_override_default_install_path"
                        break
                    fi
                ;;
                (*) echo "Invalid choice" ;;
            esac
        done

        [[ -z $g_override_default_install_path ]] && {
            printf '%s\n%s\n' \
                   "You will need to manually set install_path in the configuration file" \
                   "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$SCRIPT_FULL_NAME/$SCRIPT_FULL_NAME.conf)"
            g_override_default_install_path="auto"
        }
    fi

    return 0
}

###############################################################################
# Purpose: Ensure critical paths exist and that the script has the required
#          permissions to each of them. Additionally, in case the shebang is
#          changed from /usr/bin/env bash, aliases for commands used by the
#          script are checked and unset if needed to avoid potential undefined
#          behavior.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
SetupEnvironment() {

    local -i flag_failed=0 count_success=0 count_failed=0
    local -a check_alias_commands=(curl sed tar gzip stat wc date du pgrep sort cmp envsubst fallocate trash)

    # Check for and unset existing aliases for commands used in the script
    # that could cause undefined behavior
    # NOTE: This is not needed so long as the shebang remains /usr/bin/env bash
    for check_alias in "${check_alias_commands[@]}"; do
        result=$(alias "$check_alias" 2>&1)
        [[ $result == *"${check_alias}="* && $result != *'not found'* ]] && {
            ((g_verbose)) && vMsg "Found alias for $check_alias: $result"
            echo "WARNING: Alias detected for $check_alias (it will be unset to avoid undefined behavior)"
            if ! unalias "$check_alias"; then
                ((g_verbose)) && vMsg "unalias $check_alias failed"
                flag_failed=1
            fi
            count_failed=$(( count_failed + 1 ))
            continue
        }
        ((g_verbose)) && vMsg "No alias found for $check_alias"
        count_success=$(( count_success + 1 ))
    done
    ((g_verbose)) && vMsg "Checked for $(( count_success + count_failed )) aliases"

    # g_install_path
    if [[ -d $g_install_path ]]; then
        ((g_verbose)) && vMsg "Found existing install path at $g_install_path"
        if [[ -w $g_install_path ]]; then
            ((g_verbose)) && vMsg "Script has write access"
        else
            vMsg "No write access to: $g_install_path"
            flag_failed=1
        fi
    elif [[ ! -d $g_install_path ]]; then
        ((g_verbose)) && vMsg "g_install_path not found. Creating at $g_install_path"
        if mkdir -p -- "$g_install_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create install path succeeded"
        else
            vMsg "Failed to create: $g_install_path"
            flag_failed=1
        fi
    fi

    # g_script_config_path
    if [[ -d $g_script_config_path ]]; then
        ((g_verbose)) && vMsg "Found existing config path at $g_script_config_path"
        if [[ -w $g_script_config_path ]]; then
            ((g_verbose)) && vMsg "Script has write access"
        else
            vMsg "No write access to: $g_script_config_path"
            flag_failed=1
        fi
    elif [[ ! -d $g_script_config_path ]]; then
        ((g_verbose)) && vMsg "Config path not found, creating at $g_script_config_path"
        if mkdir -p -- "$g_script_config_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create config path succeeded"
        else
            vMsg "Failed to create: $g_script_config_path"
            flag_failed=1
        fi
    fi

    # g_script_cache_path
    if [[ -d $g_script_cache_path ]]; then
        ((g_verbose)) && vMsg "Found existing cache path at $g_script_cache_path"
        if [[ -w $g_script_cache_path ]]; then
            ((g_verbose)) && vMsg "Script has write access"
        else
            vMsg "No write access to: $g_script_cache_path"
            flag_failed=1
        fi
    elif [[ ! -d $g_script_cache_path ]]; then
        ((g_verbose)) && vMsg "Cache path not found, creating at $g_script_cache_path"
        if mkdir -p -- "$g_script_cache_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create cache path succeeded"
        else
            vMsg "Failed to create: $g_script_cache_path"
            flag_failed=1
        fi
    fi

    # g_file_script_config
    if [[ -f $g_file_script_config ]]; then
        ((g_verbose)) && vMsg "Found existing script config file at $g_file_script_config"
        if [[ -w $g_file_script_config ]]; then
            ((g_verbose)) && vMsg "Script has write access"
        else
            vMsg "No write access to: $g_file_script_config"
            flag_failed=1
        fi
        if [[ -r $g_file_script_config ]]; then
            ((g_verbose)) && vMsg "Script has read access"
        else
            vMsg "No read access to: $g_file_script_config"
            flag_failed=1
        fi
    elif [[ ! -f $g_file_script_config ]]; then
        ((g_verbose)) && vMsg "g_file_script_config not found, creating at $g_file_script_config"
        if printf '' > "$g_file_script_config"; then
            ((g_verbose)) && vMsg "Create script config file succeeded"
        else
            vMsg "Failed to create: $g_file_script_config"
            flag_failed=1
        fi
    fi

    # g_temp_base_path
    if [[ -d $g_temp_base_path ]]; then
        ((g_verbose)) && vMsg "Found existing temp base path at $g_temp_base_path"
        if [[ -w $g_temp_base_path ]]; then
            ((g_verbose)) && vMsg "Script has write access"
        else
            vMsg "Invalid tmp_path path: $g_temp_base_path"
            flag_failed=1
        fi
    elif [[ ! -d $g_temp_base_path ]]; then
        ((g_verbose)) && vMsg "Temp base path not found, creating at $g_temp_base_path"
        if mkdir -p -- "$g_temp_base_path" &>/dev/null; then
            ((g_verbose)) && vMsg "Create cache path succeeded"
        else
            vMsg "Failed to create: $g_temp_base_path"
            flag_failed=1
        fi
    fi

    # Remove 0 size g_file_latest_json
    [[ -f $g_file_latest_json ]] && {
        (( $(stat -c '%s' -- "$g_file_latest_json" 2>/dev/null) == 0 )) && {
            ((g_verbose)) && vMsg "g_file_latest_json is size 0, removing"
            if ! rm -f -- "$g_file_latest_json"; then
                flag_failed=1
            fi
        }
    }

    # Remove 0 size g_file_releases_json
    [[ -f $g_file_releases_json ]] && {
        (( $(stat -c '%s' -- "$g_file_releases_json" 2>/dev/null) == 0 )) && {
            ((g_verbose)) && vMsg "g_file_releases_json is size 0, removing"
            if ! rm -f -- "$g_file_releases_json"; then
                flag_failed=1
            fi
        }
    }

    # Create the sed script used to unminify JSON responses if it is not present
    CreateSedUnminifyJSONscript

    return $(( flag_failed ? 1 : 0 ))
}

###############################################################################
# Purpose: Check for minimum required external commands for basic functionality
#          and report if any are missing.
# Input:   None
# Output:  None
# Return:  0 (Success) All checks passed
#          1 (Failure) Any one check failed
CheckRequirements() {

    local -i flag_failed=0
    local -a required_commands=(curl sed tar gzip stat wc touch)

    while IFS= read -r --; do
        [[ ${REPLY,,} == *'is'* ]] && { ((g_verbose)) && vMsg "$REPLY"; continue; }
        [[ ${REPLY,,} == *'not found'* ]] && {
            REPLY=${REPLY#*:} # remove script_name:
            REPLY=${REPLY#*:} # remove lineno:
            # Remove a leading space if found
            [[ ${REPLY:0:1} = [[:blank:]] ]] && REPLY=${REPLY/#[[:blank:]]}
            echo "Required $REPLY"
            flag_failed=1
        }
    done < <(command -V -- "${required_commands[@]}" 2>&1)

    ((g_verbose)) && {
        if ((flag_failed)); then
            vMsg "One or more required commands not found"
        else
            vMsg "All required commands found"
        fi
    }

    return $(( flag_failed ? 1 : 0 ))
}

###############################################################################
# Purpose: Print a supplied message to stderr and prefix that message with the
#          line number that called this function followed by a function trace
#          that excludes "main". Similar to the caller built-in.
# Input:   1 (required) A string (the message to output)
# Output:  None
# Return:  Always 0
vMsg() {

    [[ -z ${1-} ]] && { echo "($LINENO)[vMsg]: Parameter error (NULL)" 1>&2; return 1; }

    local -i i

    # Calling line number
    printf '%s' "(${BASH_LINENO[0]})[" 1>&2
    for (( i=$(( ${#FUNCNAME[@]} - 2 )); i>1; i-- )); do
        # Function trace (excluding 'main')
        printf '%s' "${FUNCNAME[i]}," 1>&2
    done
    # The last function in the function trace doesn't get a comma suffix
    printf '%s' "${FUNCNAME[i]}]: " 1>&2
    # Message
    printf '%s\n' "$1" 1>&2

    return 0
}

###############################################################################
# Purpose: Provide a basic diagnostic tool that reports environment information.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>&1; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip pgrep stat sed cmp sort envsubst printf

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: $PWD"
    echo "SHELL: $SHELL"
    echo "SHELLOPTS: $SHELLOPTS"
    echo "SHLVL: $SHLVL"
    echo "BASH_VERSINFO: ${BASH_VERSINFO[*]}"
    echo "BASH_VERSION: $BASH_VERSION"
    echo "MACHTYPE: $MACHTYPE"
    echo "OSTYPE: $OSTYPE"
    echo "PROMPT_COMMAND: $PROMPT_COMMAND"
    echo "LANG: $LANG"
    echo "LC_MESSAGES: $LC_MESSAGES"
    echo "LC_ALL: $LC_ALL"
    echo "EUID: $EUID"
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Purpose: Provide a function to test new features and/or changes independent
#          of the rest of the script.
# Input:   None
# Output:  None
# Return:  Always 0
# NOTE: Exactly -fzT invokes this function
# All hope abandon, ye who enter here!
ProvingGrounds() {

    ((g_integration_testing)) || return 1

    exit
}

###############################################################################
# Purpose: Remove any temporary files/paths created by the script if g_verbose mode
#          is not enabled
# Input:   None
# Output:  None
# Return:  Always 0
CleanUp() {

    local node

    # If SIGINT was caught, attempt to prevent the cleanup from being interupted
    ((g_flag_sigint_caught)) && trap '' ABRT CHLD FPE INT QUIT TERM TSTP USR1 USR2 TRAP CONT HUP

    for node in "$g_temp_base_path/$TEMP_PREFIX"*; do
        # Paths
        [[ -d $node ]] && {
            ((g_verbose)) && vMsg "Temporary path found at $node"
            if ((g_verbose)); then
                vMsg "Debug enabled, temporary path not removed"
            else
                if rm -fr -- "$node" &>/dev/null; then
                    ((g_verbose)) && vMsg "Temporary path removed"
                else
                    vMsg "Failed to remove temporary path: $node"
                fi
            fi
        }

        # Files
        [[ -f $node ]] && {
            ((g_verbose)) && vMsg "Temp file found at $node"
            if ((g_verbose)); then
                vMsg "Debug enabled, temporary file not removed"
            else
                if rm -f -- "$node" &>/dev/null; then
                    ((g_verbose)) && vMsg "Temporary file removed"
                else
                    vMsg "Failed to remove temporary file: $node"
                fi
            fi
        }
    done

    # Handle the received SIGINT properly by terminating the script/process group with SIGINT
    ((g_flag_sigint_caught)) && {
        # If the kill fails
        if ! kill -s SIGINT $$; then
            # Try the external command
            if ! $(which --skip-alias --skip-functions -- kill) -2 0; then
                kill -2 0
                exit
            fi
        fi
    }

    return 0
}

###############################################################################
# Purpose: Parse command line parameters using getopts and set global variables
#          according to what was requested.
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  getopts exist status (man getopts):
#          0  (An option, specified or unspecified by optstring, was found.)
#          >0 (The end of options was encountered or an error occurred.)
ParseParameters() {
    OPTERR=1 # make sure it's on
    while getopts 'zZThHflSs:i:d:R:r:NuUXv:V' sOPT; do
        case "$sOPT" in
            (h) g_show_help=1 ;;
            (H) g_show_usage=1 ;;
            (f) g_force=1 ;;
            (z) g_verbose=1 ;;
            (T) if [[ $g_force -eq 1 ]] && [[ $g_verbose -eq 1 ]]; then
                    g_integration_testing=1
                    ProvingGrounds
                fi
            ;;
            (Z)
                if [[ $g_force -eq 1 ]] && [[ $g_verbose -eq 1 ]]; then
                    (ReportEnvironmentInfo)
                fi
            ;;
            (u) g_check_update=1 ;;
            (X) g_remove_install_path=1 ;;
            (N) g_remove_all_saved_packages=1 ;;
            (R)
                g_remove_installed_version=1
                g_remove_version=$OPTARG
            ;;
            (r)
                g_remove_saved_package=1
                g_remove_saved_version=$OPTARG
            ;;
            (l) g_list_installed_versions=1 ;;
            (s)
                g_report_version_usage=1
                g_report_version=$OPTARG
            ;;
            (S) g_report_install_path_usage=1 ;;
            (d)
                g_download=1
                g_download_version=$OPTARG
            ;;
            (i)
                g_install=1
                g_install_version=$OPTARG
            ;;
            (U) g_update=1 ;;
            (V) g_verify=1 ;;
            (v)
                g_verify=1
                g_verify_version=$OPTARG
            ;;
            (":"|"?") return 1 ;;
        esac
    done
}

###############################################################################
# Purpose: Supervise and control the flow of the script depending on how it was invoked
# Input:   1 (required) "$@" (all command line positional parameters)
# Output:  None
# Return:  0 (Success)
#          1 (An error occured)
Main() {

    (( $(id -u) )) || { echo "This script requires non-root effective permissions"; exit 1; }

    # Parse script parameters and arguments, set global variables
    ParseParameters "$@" || exit 1

    # Report if debug mode is enabled
    ((g_verbose)) && vMsg "Verbose mode enabled"

    # If no parameters were supplied, show help
    # NOTE: Ignore g_force and g_verbose flags
    # TODO: This is not ideal
    if ((! g_remove_install_path)) && \
       ((! g_remove_all_saved_packages)) && \
       ((! g_remove_installed_version)) && \
       ((! g_remove_saved_package)) && \
       ((! g_list_installed_versions)) && \
       ((! g_report_version_usage)) && \
       ((! g_report_install_path_usage)) && \
       ((! g_download)) && \
       ((! g_install)) && \
       ((! g_check_update)) && \
       ((! g_verify)) && \
       ((! g_show_help)) && \
       ((! g_show_usage)) && \
       ((! g_update)); then

        ((g_verbose)) && {
            if IsSteamRunning; then
                vMsg "Steam is running"
            else
                vMsg "Steam is not running"
            fi
        }

        CheckRequirements # Print any required commands that are not found
        ShowHelp
        exit 0
    fi

    # Print help
    ((g_show_help)) && { CheckRequirements; ShowHelp; }

    # Print usage
    ((g_show_usage)) && { CheckRequirements; ShowUsage; }

    # If either ShowHelp or ShowUsage was invoked, exit
    ((g_show_help || g_show_usage)) && exit 0

    if CheckRequirements; then
        if ParseConfigFile; then
            if ! SetupEnvironment; then
                exit 1
            fi
        else
            exit 1
        fi
    else
        exit 1
    fi

    # Check if the latest release is installed
    if (( g_check_update && ! g_update )); then
        if GetLatestGEVersion; then
            if IsInstalled "$g_latest_version"; then
                echo "The latest version $g_latest_version is installed"
            else
                echo "The latest version $g_latest_version is not installed"
            fi
        fi
    fi

    # Remove install path if force mode is active
    if (( g_remove_install_path && g_force )); then
        if IsSteamRunning; then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    # If remove install path was requested but force mode is not active
    elif ((g_remove_install_path)); then
        echo "-X must be combined with -f to confirm that you are sure"
    fi

    # Remove all saved packages if remove install path was not requested
    if (( g_remove_all_saved_packages && ! g_remove_install_path )); then
        RemoveAllSavedPackages # TODO: -f required?
    fi

    # Remove an installed version if remove install path was not requested
    if (( g_remove_installed_version && ! g_remove_install_path )); then
        RemoveGEVersion "$g_remove_version" # NOTE: g_remove_version is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif ((g_remove_installed_version)); then
        echo "Remove installed version skipped (remove install path was requested)"
    fi

    # Remove a saved package if both remove install path and remove all saved packages was not requested
    if (( g_remove_saved_package && ! g_remove_install_path && ! g_remove_all_saved_packages )); then
        RemoveSavedPackage "$g_remove_saved_version" # NOTE: g_remove_version is set in getops
    elif ((g_remove_saved_package)); then
        echo "Remove saved package skipped (remove install path or remove all saved packages was requested)"
    fi

    # Download a package
    ((g_download)) && {
        if ! DownloadGEPackage "$g_download_version"; then # NOTE: g_download_version is set in getops
            echo "Download failed"
        fi
    }

    # Update to the latest release
    ((g_update)) && UpdateGEVersion

    # Install a package
    if (( g_install && ! g_update )); then
        InstallGEVersion "$g_install_version" # NOTE: g_install_version is set in getops
    fi

    # List installed versions
    ((g_list_installed_versions)) && ListInstalledGEVersions

    # Report entire g_install path disk usage and file count
    ((g_report_install_path_usage)) && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    ((g_report_version_usage)) && ReportGEDiskUsage "$g_report_version"

    # Run verify if remove install path and remove saved packages wasn't requested
    # TODO: add support to verify even if remove saved packages and/or remove install path was invoked
    #       so long as some sort of install was also requested. Additionally, maybe support installing a version
    #       that is not installed when verify is called and force mode is active.
    if (( g_verify && ! g_remove_install_path && ! g_remove_all_saved_packages )); then
        VerifyGEInstall "${g_verify_version-}"
    fi

    return 0
}

###############################################################################
# Purpose: Run the function CleanUp on SIGEXIT
#          Save the exit status of the last executed command before invoking
#          the CleanUp function. Report both the saved exit status and the exit
#          status of CleanUp if debug mode is enabled.
trap 'g_real_exit_status=$?; ((g_verbose)) && vMsg "Exit status (before CleanUp): $g_real_exit_status"; CleanUp; ((g_verbose)) && vMsg "Exit status (after CleanUp): $?"; exit $g_real_exit_status' EXIT

###############################################################################
# Purpose: Run the function CleanUp if the process group received SIGINT
#          This needs to be a seperate trap to properly handle SIGINT.
trap 'g_flag_sigint_caught=1; CleanUp' INT

###############################################################################
# Wait...the end is just a new beginning? Always has been.

Main "$@"
