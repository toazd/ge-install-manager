#!/usr/bin/env bash
# vim: set nowrap et sta shiftwidth=4 ts=8 sts=0
#
#shellcheck disable=SC2155
# https://github.com/koalaman/shellcheck/wiki/SC2155

###############################################################################
#                                                                             #
#      Toazd 2020 Unlicense https://unlicense.org/                            #
#                                                                             #
#      GloriousEggroll proton-ge-custom installation manager                  #
#       Manage proton-ge-custom installations                                 #
#        https://github.com/GloriousEggroll/proton-ge-custom                  #
#                                                                             #
###############################################################################

set +e # WARNING DO NOT set -e
set -huo pipefail
#set -T # If set, the DEBUG and RETURN traps are inherited by shell functions.

###############################################################################
# "Things that would be nice, but aren't required for main features" list
#
# TODO Find a way to not download releases so often (updates to download_count update the mtime of the remote file)
# TODO What if githubs anonymous request rate limit is exceeded (60/hr)?
# TODO The script has outgrown getopts. Support for multiple identical parameters per single invocation depends
#      on using something else or simply making a parser
# TODO support for using jq if sed fails to reformat minified JSON how the script expects (or just use jq first if it's available)
#
###############################################################################
# Global variables
sSCRIPT_VERSION="0.7.4"
sSCRIPT_CODENAME="Cochrane Bonaventure"
# ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/
sGE_INSTALL_PATH='' #"$HOME"/.steam/root/compatibilitytools.d
#sSCRIPT_SHORT_NAME="ge-install-manager"
sSCRIPT_FULL_NAME=${0##*/}
sSCRIPT_CONFIG_PATH=${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME
sSCRIPT_CACHE_PATH= #${XDG_CACHE_HOME:-"$HOME"/.cache}/$sSCRIPT_FULL_NAME # TODO consider moving saved packages to here instead
# JSON data sources TODO optional support for jq in addition to keeping sed as a fallback
sGE_LATEST_VERSION_URL='' #"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest"
sGE_RELEASES_URL='' #"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases"
# HTML data sources (reference only, this script does not currently support html data sources)
# https://github.com/GloriousEggroll/proton-ge-custom/releases
# https://github.com/GloriousEggroll/proton-ge-custom/tags
sFILE_LATEST_JSON="$sSCRIPT_CACHE_PATH"/latest.json
sFILE_RELEASES_JSON="$sSCRIPT_CACHE_PATH"/releases.json
# NOTE JSON is returned minified when a custom User-Agent is used.
# This saves ~25KiB per releases file download and ~0.5KiB per latest file download
sCURL_HEADER_GITHUB_MEDIATYPE="Accept: application/vnd.github.v3.text+json"
sCURL_HEADER_USER_AGENT="User-Agent: toazd/$sSCRIPT_FULL_NAME/$sSCRIPT_VERSION"
sCURL_HEADER_CONTENT_TYPE="Content-Type: application/json"
sGE_LATEST_VERSION=''
sFILE_SCRIPT_CONFIG=$sSCRIPT_CONFIG_PATH/$sSCRIPT_FULL_NAME.conf
sFILE_SED_UNMINIFY_SCRIPT= #"$sSCRIPT_CONFIG_PATH/unminify-JSON.sed" # TODO consider moving to XDG_DATA_HOME
sOVERRIDE_DEFAULT_INSTALL_PATH=''
sCOMMAND_RM='' #"trash" # Used in place of rm for all but temporary files if it is found
sTMP_BASE_PATH=/tmp
sTMP_PREFIX=$sSCRIPT_FULL_NAME.tmp.
# some script functionality depends on the following being initialized as 0
iFORCE=0
iDEBUG=0
iDOWNLOAD=0
iINSTALL=0
iREMOVE_INSTALLED_VERSION=0
iUPDATE=0
iVERIFY=0
iREMOVE_INSTALL_PATH=0
iREMOVE_SAVED_PACKAGE=0
iREMOVE_ALL_SAVED_PACKAGES=0
iLIST_INSTALLED_GE_VERSIONS=0
iREPORT_VERSION_USAGE=0
iREPORT_INSTALL_PATH_USAGE=0
iSHOW_HELP=0
iSHOW_USAGE=0
iCHECK_UPDATE=0
iINTEGRATION_TESTING=0
iSIZE_BYTES_SED_UNMINIFY_SCRIPT=824
iREAL_EXIT_STATUS=0
OPTERR=1 # make sure it's on

###############################################################################
# TODO
ShowHelp() {
    cat <<HELP_MESSAGE

    $(basename "$0")  v$sSCRIPT_VERSION "$sSCRIPT_CODENAME"

    Required:       Bash 3.2+(TBD), curl, sed, tar, gzip, stat, wc
    Optional:       du (display disk usage of a path/file)
                    ps (is steam running)
                    sort, cmp (verify)
                    envsubst (config file parsing)
                    trash (used in place of of rm [excluding temporary files])

    -h            - Show this help
    -H            - Show usage notes, formats, and examples
    -l            - List installed versions and saved packages
    -S            - Report file count and disk usage of install path
    -s <version>  - Report file count and disk usage of <version>
    -U            - Check for and install the latest release
    -u            - Check for the latest release and report installed status
                      Combined with -U, -u will be ignored
    -i <version>  - Download and install <version>
    -R <version>  - Remove installed <version>
    -r <version>  - Remove saved package <version>
    -V            - Verify each installation using its saved package
                      Combined with -v, -V will be skipped
                      Saved packages will be downloaded as needed
    -v <version>  - Verify <version> using its saved package
    -d <version>  - Download and save the package for <version>
    -N            - Remove all saved packages matching the pattern "Proton-*.tar.gz" in the install path
    -X            - Remove the entire install path
                      -f is also required to confirm that you are sure
                      NOTE: Saved packages are currently stored in the installation path
    -f            - Force install, upgrade, or remove
                      Combined with -U and/or -i, remove saved package and download a new copy
                      Combined with -R to remove a saved package (even if that version is not installed)
    -z            - Enable debug mode
                      Enable extra output messages and preserve any temporary files created
HELP_MESSAGE

    return 0
}

###############################################################################
# TODO
ShowUsage() {
    cat <<USAGE_MESSAGE
Usage:

  - Acceptable formats for <version>:
      5.9-GE-3-ST, Proton-5.9-GE-3-ST, Proton-5.9-GE-3-ST.tar.gz (case-insensitive)

  - Most parameters can be combined with other unique parameters.
    > NOTE: arguments must directly follow parameters that require arguments
      Example (both produce the same result):
        ./$(basename "$0") -Hh
        ./$(basename "$0") -h -H
          Result: Show help and then show usage
      Example (both produce the same result):
        ./$(basename "$0") -lSui 5.9-GE-3-ST
        ./$(basename "$0") -lS -i 5.9-GE-3-ST -u
          Result: Check for the latest version and install it,
           install version 5.9-GE-3-ST, list installed versions, then
           report file and disk usage for the install path
      Example: (assume the latest version is 5.9-GE-3-ST)
        ./$(basename "$0") -z -u -i Proton-5.11-GE-1-MF -Xf
          Result: enable debug mode, remove the installation path,
           update to the latest version 5.9-GE-3-ST, and then install version 5.11-GE-1-MF.
      Example (both produce the same result):
        ./$(basename "$0") -s 5.6-GE-3-ST -S
        ./$(basename "$0") -Ss 5.6-GE-3-ST
          Result: report disk usage and file count for the install path,
           and then report disk usage and file count for version 5.6-GE-3-ST

  - The order of parameters is not significant except:
    > If during invocation multiple identical parameters are supplied.
      Example:
        ./$(basename "$0") -s 5.11-GE-1-MF -s 5.9-GE-3-ST
          Result: Only the right-most parameter will be processed (-s 5.9-GE-3-ST).

  - Order of operations if multiple unique parameters are supplied:
    > NOTE: -h and/or -H, and -fzZ will exit irrespective of other parameters
      Force toggle,
      Report environment info (-fzZ),
      Show help,
      Show usage,
      Debug toggle,
      Check for latest release,
      Remove install path,
      Remove saved packages (if remove install path is not active),
      Remove installed version (if remove install path is not active),
      Remove saved package (if remove install path is not active),
      Download,
      Update,
      Install,
      List installed,
      Report install path usage,
      Report specific version usage
      Verify

  - Debug message format: (calling line)[function trace]: message
USAGE_MESSAGE

    return 0
}

###############################################################################
# Sets the global variable sGE_LATEST_VERSION to the latest version
# TODO *might* want to check releases if latest fails.
# NOTE rate limied exceeded [[ $(stat -c '%s' "$sFILE_LATEST_JSON") -eq 245 ]]
GetLatestGEVersion() {

    local iRATE_LIMITED_EXCEEDED=0

    # WARNING DO NOT make this local
    sGE_LATEST_VERSION=''

    if UpdateSavedGELatestRelease; then
        while IFS= read -r; do
            # WARNING do not use "tag_name": "5.9-GE-5-ST", or "name": "Proton-5.9-GE-5-ST",
            #         they are not always the same as the version name in browser_download_url
            # NOTE must be compatible with all 3 of the following potential formats
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            #         "name": "Proton-5.9-GE-5-ST.tar.gz",
            # "name":"Proton-5.9-GE-5-ST.tar.gz"
            [[ $REPLY =~ ^.*\"name\":.*\"Proton-.*\.tar\.gz\".*$ ]] && {
                DebugMessage "matched line \"$REPLY\""
                sGE_LATEST_VERSION=${REPLY#*\"name\":}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION#*\"}
                sGE_LATEST_VERSION=${sGE_LATEST_VERSION%.tar.gz\"*}
                DebugMessage "sGE_LATEST_VERSION set to \"$sGE_LATEST_VERSION\""
                break
            }
            [[ ${REPLY,,} == *"rate limit exceeded"* ]] && {
                iRATE_LIMITED_EXCEEDED=1
                break
            }
        done < "$sFILE_LATEST_JSON"

        [[ $iRATE_LIMITED_EXCEEDED -eq 1 ]] && {
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "Github API rate limited exceeded"
            elif [[ $iDEBUG -eq 0 ]]; then
                printf '%s\n%s\n%s\n' \
                       "Github API rate limited exceeded" \
                       "\"For unauthenticated requests, the rate limit allows for up to 60 requests per hour.\"" \
                       "https://developer.github.com/v3/#rate-limiting"
            fi
            # needs to be removed or RequestURL won't grab a new one right away
            rm "$sFILE_LATEST_JSON"
            return 1
        }

        [[ -z $sGE_LATEST_VERSION ]] && {
            DebugMessage "sGE_LATEST_VERSION is NULL (no match or not found)"
            return 1
        }
    else
        DebugMessage "UpdateSavedGELatestRelease returned failure status"
        return 1
    fi

    return 0
}

###############################################################################
# Retrieve "latest" JSON from sGE_LATEST_VERSION_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGELatestRelease() {

    local sGE_LATEST_RELEASE_JSON=''

    DebugMessage "Using RequestURL to check if \"$sGE_LATEST_VERSION_URL\" is newer than \"$sFILE_LATEST_JSON\""

    if sGE_LATEST_RELEASE_JSON=$(RequestURL "$sGE_LATEST_VERSION_URL" "$sFILE_LATEST_JSON"); then
        DebugMessage "RequestURL returned success"
    else
        DebugMessage "RequestURL returned failure"
    fi

    # check the response and report and respond accordingly
    if [[ -n $sGE_LATEST_RELEASE_JSON ]]; then
        DebugMessage "sGE_LATEST_RELEASE_JSON is not empty"
        [[ -f $sFILE_LATEST_JSON ]] && CreateBackup "$sFILE_LATEST_JSON"
        printf '%s' "$sGE_LATEST_RELEASE_JSON" > "$sFILE_LATEST_JSON"
        return 0
    elif [[ -z $sGE_LATEST_RELEASE_JSON ]]; then
        DebugMessage "sGE_LATEST_RELEASE_JSON is NULL"
        if [[ ! -f $sFILE_LATEST_JSON ]]; then
            echo "Response from RequestURL was NULL and file \"$sFILE_LATEST_JSON\" not found. Is \"$sGE_LATEST_VERSION_URL\" a valid URL?"
            return 1
        fi
    fi

    return 0
}

###############################################################################
# Retrieve "releases" JSON from sGE_RELEASES_URL
#TODO consider merging UpdateSavedGEReleases and UpdateSavedGELatestRelease
UpdateSavedGEReleases() {

    local sGE_RELEASES_JSON=''

    # BUG updates to download_count in remote releases cause curl -z to download a new version much more often than is needed
    DebugMessage "Using RequestURL to check if \"$sGE_RELEASES_URL\" is newer than \"$sFILE_RELEASES_JSON\""

    if sGE_RELEASES_JSON=$(RequestURL "$sGE_RELEASES_URL" "$sFILE_RELEASES_JSON"); then
        DebugMessage "RequestURL returned success"
    else
        DebugMessage "RequestURL returned failure"
    fi

    if [[ -n $sGE_RELEASES_JSON ]]; then
        DebugMessage "sGE_RELEASES_JSON is not empty"
        [[ -f $sFILE_RELEASES_JSON ]] && CreateBackup "$sFILE_RELEASES_JSON"
        printf '%s' "$sGE_RELEASES_JSON" > "$sFILE_RELEASES_JSON"
        return 0
    elif [[ -z $sGE_RELEASES_JSON ]]; then
        DebugMessage "sGE_RELEASES_JSON is NULL"
        if [[ ! -f $sFILE_RELEASES_JSON ]]; then
            echo "Response from RequestURL was NULL and file \"$sFILE_RELEASES_JSON\" not found. Is \"$sGE_RELEASES_URL\" a valid URL?"
            return 1
         fi
    fi

    return 0
}

###############################################################################
# Attempt to download a package (Proton*.tar.gz) using a tmp path.
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
DownloadGEPackage() {

    local sVERSION=$(CleanUpVersion "${1-}")
    [[ -z $sVERSION ]] && { DebugMessage "Parameter error (NULL)"; return 1; }
    local sTMP_PATH=$(MkTempPath)
    local sTMP_PACKAGE=$sTMP_PATH/Proton-${sVERSION}.tar.gz
    local sGE_DOWNLOAD_URL=$(QueryGEAttribute "$sVERSION" "browser_download_url")
    local iSIZE_BYTES=''

    [[ -z $sGE_DOWNLOAD_URL ]] && { DebugMessage "sGE_DOWNLOAD_URL is NULL"; return 1; }

    echo "Downloading \"$sGE_DOWNLOAD_URL\""
    if curl -# -L "$sGE_DOWNLOAD_URL" -o "$sTMP_PACKAGE"; then
        iSIZE_BYTES=$(stat -c '%s' "$sTMP_PACKAGE")
        DebugMessage "Package size in bytes: \"$iSIZE_BYTES\""
        if [[ $iSIZE_BYTES -eq 9 ]] || [[ $(cat "$sTMP_PACKAGE" 2>/dev/null) =~ ^[Nn]ot[[:blank:]]+[Ff]ound$ ]]; then
            echo "Server responded \"Not Found\" for version \"$sVERSION\""
            CleanUp
            return 1
        fi
        if [[ $iSIZE_BYTES = "$(QueryGEAttribute "$sVERSION" "size")" ]]; then
            echo "Downloaded package is the expected size"
        else
            printf '%s\n%s\n' \
                   "Downloaded file size and expected size do not match" \
                   "(\"$iSIZE_BYTES\" vs \"$(QueryGEAttribute "$sVERSION" "size")\")"
           CleanUp
           return 1
        fi
        DebugMessage "Copying package \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\""
        if cp "$sTMP_PACKAGE" "$sGE_INSTALL_PATH"; then
            DebugMessage "Package copied successfully"
            echo "Download succeeded"
            CleanUp
        else
            DebugMessage "Copy package from \"$sTMP_PACKAGE\" to \"$sGE_INSTALL_PATH\" failed"
            echo "Download failed"
            CleanUp
            return 1
        fi
    else
        DebugMessage "'curl' returned failure status"
        echo "Download failed"
        CleanUp
        return 1
    fi

    return 0
}

###############################################################################
# Install a GE version using either a saved package or downloading a new one
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
# NOTE sINSTALL_VERSION is set in getops when -i is invoked
# NOTE If -u and -i are both invoked, the update will run first and then the install, if needed
InstallGEVersion() {

    local sVERSION

    DebugMessage "Determining mode"
    if [[ $iUPDATE -eq 1 ]]; then
        DebugMessage "Update mode active"
        [[ -z $sGE_LATEST_VERSION ]] && {
            if GetLatestGEVersion; then
                DebugMessage "GetLatestGEVersion returned success"
                sVERSION=$sGE_LATEST_VERSION
            else
                DebugMessage "GetLatestGEVersion returned failure"
                return 1
            fi
        }
    elif [[ $iUPDATE -eq 0 ]]; then
        DebugMessage "Install mode active"
        sVERSION=${sINSTALL_VERSION:-$(CleanUpVersion "${1-}")}
    else
        DebugMessage "Unknown error detecting install mode"
        return 1
    fi

    sVERSION=$(CleanUpVersion "${1-}")

    [[ -z $sVERSION ]] && { DebugMessage "sVERSION is NULL"; return 1; }

    DebugMessage "Requested sVERSION is \"$sVERSION\""

    # Re-install a version that is already installed
    if IsInstalled "$sVERSION"; then
        if [[ $iFORCE -eq 0 ]]; then
            echo "Version \"$sVERSION\" is already installed"
            return 0
        elif [[ $iFORCE -eq 1 ]]; then
            if IsSteamRunning; then
                echo "Please close Steam before re-installing a version that is already installed"
                return 1
            else
                echo "Forcing re-install of version \"$sVERSION\""
            fi
        fi
    fi

    # if a saved package exists and force mode is not active
    if [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 0 ]]; then
        echo "Using saved package: \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if ExtractGEPackage "$sVERSION"; then
            return 0
        else
            return 1
        fi
    # if a saved package exists and force mode is active
elif [[ -f $sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz ]] && [[ $iFORCE -eq 1 ]]; then
        echo "Removing saved package \"$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz\""
        if $sCOMMAND_RM "$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz"; then
            echo "Package removed"
        else
            echo "Removing package failed"
            return 1
        fi
    fi

    # If a saved package for this version doesn't exist or it was removed, download it and install it
    if DownloadGEPackage "$sVERSION"; then
        if ExtractGEPackage "$sVERSION"; then
            echo "Installation of version \"$sVERSION\" was successful"
            return 0
        else
            echo "Installation of version \"$sVERSION\" failed"
            return 1
        fi
    else
        echo "Version \"$sVERSION\" not found"
        return 1
    fi

    return 0
}

###############################################################################
# Removes an installed version
# Accepts one parameter, the version, in one of the acceptable formats described in usage
RemoveGEVersion() {

    local sVERSION=$(CleanUpVersion "${1-}")
    local sREMOVE_PATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
    local sSIZE="0"

    [[ -z $sVERSION ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    DebugMessage "Requested sVERSION: \"$sVERSION\" sREMOVE_PATH: \"$sREMOVE_PATH\""

    # Remove the path if it exists
    if [[ -d $sREMOVE_PATH ]]; then
        if ! IsSteamRunning; then
            sSIZE=$(du -sh "$sREMOVE_PATH" 2>/dev/null)
            sSIZE=${sSIZE%[[:space:]]*}
            if $sCOMMAND_RM -rf "$sREMOVE_PATH" >/dev/null; then
                echo "Removed path \"$sREMOVE_PATH\" (${sSIZE:-'error'})"
            else
                echo "Failed to remove \"$sREMOVE_PATH\""
                return 1
            fi
        else
            echo "Please close Steam before removing an install path"
            return 1
        fi
    else
        DebugMessage "Install path does not exist"
        echo "Install path not found for version \"$sVERSION\""
    fi

    return 0
}

###############################################################################
# Extracts a saved package (Proton-*.tar.gz) in the install path to the install path
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
# Accepts one optional second parameter, the path to extract the package to
ExtractGEPackage() {

    local sVERSION=$(CleanUpVersion "${1-}")
    local sEXTRACT_FILE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz
    local sEXTRACT_PATH=${2:-$sGE_INSTALL_PATH}

    [[ -z $sVERSION ]] && { DebugMessage "Parameter error (NULL)"; return 1; }
    [[ ! -d $sEXTRACT_PATH && -w $sEXTRACT_PATH ]] && { DebugMessage "Parameter error (Not a valid path)"; return 1; }

    printf '%s' "Extracting \"$sEXTRACT_FILE\" to \"$sEXTRACT_PATH\""
    if tar --checkpoint=.10000 -C "$sEXTRACT_PATH" -xzf "$sEXTRACT_FILE" 2>/dev/null; then
        printf '\r\033[0K%s\n' "Package extracted successfully"
        return 0
    else
        printf '\r\033[0K%s\n' "Package extraction failed"
        [[ -d $sEXTRACT_PATH/Proton-${sVERSION} ]] && {
            DebugMessage "Removing failed extraction path \"$sEXTRACT_PATH/Proton-${sVERSION}\""
            if $sCOMMAND_RM "$sEXTRACT_PATH/Proton-${sVERSION}"; then
                DebugMessage "Removal succeeded"
                echo "Removed failed extraction path at \"$sEXTRACT_PATH/Proton-${sVERSION}\""
            else
                echo "Failed to remove path of failed extraction: \"$sEXTRACT_PATH/Proton-${sVERSION}\""
                # TODO update/remove message when install verification is updated
                echo "This script may interpret it as a valid install until it is removed"
            fi
        }
        return 1
    fi

    return 0
}

###############################################################################
# List the currently installed GE versions and any saved packages
ListInstalledGEVersions() {

    local iCOUNT=0
    local sNODE
    #local sEXTRACTED_VERSION=''

    DebugMessage "Install path: \"$sGE_INSTALL_PATH\""

    echo "Installed version(s):"
    for sNODE in "$sGE_INSTALL_PATH"/*; do
        if [[ -d $sNODE ]]; then
            #sEXTRACTED_VERSION=$(cat "$sNODE"/version 2>/dev/null)
            #sEXTRACTED_VERSION=${sEXTRACTED_VERSION#*[[:blank:]]}
            #if [[ -z $sEXTRACTED_VERSION ]] || [[ $sEXTRACTED_VERSION = "file not found" ]]; then sEXTRACTED_VERSION="error: version file not found"; fi
            #echo "  ${sNODE##*/} ($sEXTRACTED_VERSION)"
            echo "  ${sNODE##*/} ($(du -sh "$sNODE" | cut -f1))"
            ((iCOUNT++))
        fi
    done
    [[ $iCOUNT -eq 0 ]] && echo "None found"

    echo "Saved package(s):"
    sNODE=''
    iCOUNT=0
    for sNODE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sNODE ]]; then
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "${sNODE##*/} (size: $(stat -c '%s' "$sNODE"), expected size: $(QueryGEAttribute "${sNODE##*/}" "size"))"
            else
                echo "  ${sNODE##*/} ($(du -h "$sNODE" | cut -f1))"
            fi
            ((iCOUNT++))
        fi
    done
    if [[ $iCOUNT -ge 1 ]]; then
        echo "Saved packages disk usage: $(du -csh "$sGE_INSTALL_PATH/"*.tar.gz | tail -n1 | cut -f1)"
    elif [[ $iCOUNT -eq 0 ]]; then
        echo "None found"
    fi

    return 0
}

###############################################################################
# Report disk usage and file counts for the install path and/or a specified installed version
# Accepts one optional parameter, the version, in one of the acceptable formats described in usage
ReportGEDiskUsage() {

    local sVERSION=$(CleanUpVersion "${1-}")
    local sPATH=''
    local sSIZE="0"
    local iFAILED=0

    # NOTE do not return 1 if sVERSION is NULL, functionality below depends on it

    if ! command -v du >/dev/null && ! command -v find >/dev/null && ! command -v wc >/dev/null; then
        iFAILED=1
    fi

    # if all checks succeeded
    if [[ $iFAILED -eq 0 ]]; then
        # set the path to be reported based on whether a version was provided or not
        if [[ -z $sVERSION ]]; then
            # report the file count and disk usage for the entire install path
            sPATH=$sGE_INSTALL_PATH
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Install path report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                DebugMessage "Path: $sPATH"
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
        if [[ -n $sVERSION ]]; then
            # Report the file count and disk usage for a specific version
            sPATH=$sGE_INSTALL_PATH/Proton-${sVERSION}
            if [[ -d $sPATH ]]; then
                sSIZE=$(du -sh "$sPATH")
                sFILE_COUNT=$(find "$sPATH" -type f | wc -l)
                echo "Version \"$sVERSION\" report:"
                printf '  %s\n  %s\n  %s\n' "Path: $sPATH" "Files: $sFILE_COUNT" "Disk usage: ${sSIZE%%[[:blank:]]*}"
            else
                DebugMessage "Path: $sPATH"
                echo "Version \"$sVERSION\" not found"
                return 1
            fi
        fi
    # if any check failed
    elif [[ $iFAILED -eq 1 ]]; then
        DebugMessage "At least one optional command was not found"
        echo "One or more optional commands not found (see -h). Report not available."
        return 1
    fi

    return 0
}

###############################################################################
# Remove a saved package
# Accepts one required parameter, the version, in one of the acceptable formats described in usage
RemoveSavedPackage() {

    local sVERSION=$(CleanUpVersion "${1-}")
    local sPACKAGE=$sGE_INSTALL_PATH/Proton-${sVERSION}.tar.gz

    [[ -z $sVERSION ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    if [[ -f $sPACKAGE ]]; then
        if [[ -w $sPACKAGE ]]; then
            if $sCOMMAND_RM "$sPACKAGE"; then
                echo "Removed \"$sPACKAGE\""
                return 0
            else
                DebugMessage "sCOMMAND_RM: \"$sCOMMAND_RM\" sPACKAGE: \"$sPACKAGE\""
                echo "Failed to remove version \"$sVERSION\" (rm command failed)"
                return 1
            fi
        else
            DebugMessage "No write access to \"$sPACKAGE\""
            echo "Failed to remove version \"$sVERSION\" (no write permission)"
            return 1
        fi
    else
        DebugMessage "sPACKAGE is not a regular file: \"$sPACKAGE\""
        echo "Failed to remove version \"$sVERSION\" (file not found)"
        return 1
    fi

    return 0
}

###############################################################################
# Removes all saved packages in the install path defined by the global variable sGE_INSTALL_PATH
# NOTE a package is any regular file that matches the glob pattern "Proton-*.tar.gz"
RemoveAllSavedPackages() {

    local iSUCCESS=0
    local iFAILED=0

    DebugMessage "Install path: \"$sGE_INSTALL_PATH\""

    for sPACKAGE in "$sGE_INSTALL_PATH"/Proton-*.tar.gz; do
        if [[ -f $sPACKAGE ]]; then
            if $sCOMMAND_RM "$sPACKAGE"; then
                if [[ $iDEBUG -eq 1 ]]; then
                    DebugMessage "Package \"$sPACKAGE\" removed"
                else
                    echo "Removed \"$sPACKAGE\""
                fi
                ((iSUCCESS++))
            else
                echo "Remove \"$sPACKAGE\" failed"
                ((iFAILED++))
            fi
        fi
    done

    if [[ $iSUCCESS -eq 0 ]]; then
        echo "0 packages removed"
    elif [[ $iSUCCESS -gt 0 ]]; then
        echo "$iSUCCESS packages removed"
    fi

    [[ $iFAILED -gt 0 ]] && {
        echo "Failed to remove $iFAILED package(s)"
        return 1
    }

    return 0
}

###############################################################################
# Removes the path defined by the global variable sGE_INSTALL_PATH
# NOTE currently requires -f to be combined with -X
RemoveGEInstallPath() {

    local sSIZE="0"

    if command -v du >/dev/null; then
        sSIZE=$(du -sh "$sGE_INSTALL_PATH")
    else
        DebugMessage "Command du not found"
        sSIZE="unknown"
    fi

    if $sCOMMAND_RM "$sGE_INSTALL_PATH"; then
        echo "Remove install path succeeded ( ${sSIZE%%[[:blank:]]*} removed )"
        DebugMessage "Recreating install path at \"$sGE_INSTALL_PATH\""
        if mkdir -p "$sGE_INSTALL_PATH"; then
            DebugMessage "Creation succeeded"
        else
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "Creation failed"
            else
                echo "Warning: failed to re-create install path at \"$sGE_INSTALL_PATH\""
                return 1
            fi
        fi
    else
        echo "Removal of install path \"$sGE_INSTALL_PATH\" failed"
        return 1
    fi

    return 0
}

###############################################################################
# TODO
VerifyGEInstall() {

    local sNODE
    local sTMP_PATH=$(MkTempPath)
    local sVERSION=$(CleanUpVersion "${1-}")
    local iaEXTRACTED=()
    local iaINSTALLED=()
    local iMATCH_COUNTER=0
    local iMISSING_COUNTER=0
    local iMISMATCH_COUNTER=0
    local iFILE_COUNT_MATCH=0
    local iCOUNTER=0
    local iCOUNTER_EXTRACTED=0
    local iCOUNTER_INSTALLED=0
    local iSTART_TIME_SECONDS=0 # NOTE bash 5+ is required for EPOCHSECONDS
    local iEND_TIME_SECONDS=0   # NOTE bash 4.2+ is required for printf $()T
    local iPROGRESS=0
    local iPREV_PROGRESS=1

    # Required external commands
    if ! command -v cmp >/dev/null && ! command -v sort >/dev/null; then
        echo "Command 'cmp' is required to use this function"
        return 1
    fi

    # Check for install paths that don't have a saved package, download if missing
    for sNODE in "$sGE_INSTALL_PATH/Proton-"*; do
        [[ -d $sNODE ]] && {
            # Verify that it is installed
            IsInstalled "${sNODE##*/}" && {
                # If no saved package exists for this version
                [[ ! -f $sGE_INSTALL_PATH/${sNODE##*/}.tar.gz ]] && {
                    echo "Package not found for installed version \"${sNODE##*/}\""
                    DownloadGEPackage "${sNODE##*/Proton-}"
                }
            }
        }
    done

    # For each saved package available, check each file of the contents against the install path if it exists
    for sNODE in "$sGE_INSTALL_PATH"/Proton-${sVERSION:-*}.tar.gz; do
        [[ -f $sNODE ]] && {
            sVERSION=$(CleanUpVersion "${sNODE##*/}")
            #[[ $sNODE != *Proton-5.9-GE-TEST-ST* ]] && continue
            echo "Found a package for version \"$sVERSION\""
            if ! IsInstalled "$sVERSION"; then
                echo "Version \"$sVERSION\" is not installed"
                continue
            else
                echo "Version \"$sVERSION\" is installed"
                if ! ExtractGEPackage "$sVERSION" "$sTMP_PATH"; then
                    return 1
                fi

                # create two indexed arrays, each containing a seperate list of files, one from the extracted path and the other from the installed path respectively
                #printf '\033[s%s' "Indexing files to compare"
                # NOTE __pycache__ is created at runtime and will not be present in the saved packages
                echo "Indexing files to compare"
                while IFS= read -r sFILE_EXTRACTED; do
                    iaEXTRACTED+=("$sFILE_EXTRACTED")
                done < <(find "$sTMP_PATH/Proton-${sVERSION}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)
                while IFS= read -r sFILE_INSTALLED; do
                    iaINSTALLED+=("$sFILE_INSTALLED")
                done < <(find "$sGE_INSTALL_PATH/Proton-${sVERSION}" -type f ! -iwholename "*__pycache__*" 2>/dev/null | LC_ALL=C sort)

                # Report files found in each
                #printf "\033[u\033[0K%s\n" "${#iaEXTRACTED[@]} (extracted files) vs ${#iaINSTALLED[@]} (installed files)"
                echo "${#iaEXTRACTED[@]} (extracted) vs ${#iaINSTALLED[@]} (installed)"

                # Based on array element sizes, decide on a method to compare files
                #if [[ $(true) = "$(false)" ]]; then
                if [[ ${#iaEXTRACTED[@]} -ne ${#iaINSTALLED[@]} ]]; then
                    #DebugMessage "Array sizes do not match: ${#iaEXTRACTED[@]} vs ${#iaINSTALLED[@]}"
                    DebugMessage "Array sizes are not equal"
                    echo "Using slower method for comparing"
                    iFILE_COUNT_MATCH=0
                else
                    #DebugMessage "Array sizes match: ${#iaEXTRACTED[@]} vs ${#iaINSTALLED[@]}"
                    DebugMessage "Array sizes are equal"
                    echo "Using faster method for comparing"
                    iFILE_COUNT_MATCH=1
                fi

                # begin comparing, using the faster method
                printf '%s\033[s' "Comparing files"
                # if the number of entries match, check them directly against eachother
                if [[ $iFILE_COUNT_MATCH -eq 1 ]]; then
                    iTOTAL_FILES=${#iaEXTRACTED[@]}
                    iSTART_TIME_SECONDS=$(date +%s)
                    for iCOUNTER in "${!iaEXTRACTED[@]}"; do
                        cmp -s "${iaEXTRACTED[iCOUNTER]}" "${iaINSTALLED[iCOUNTER]}"
                        case $? in
                            (0) ((iMATCH_COUNTER++)) ;;
                            (1) ((iMISMATCH_COUNTER++)) ;;
                            (2) ((iMISSING_COUNTER++)) ;;
                        esac
                        # Some test results - this method is already
                        # quite fast so not much testing was done
                        # 1 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 2 - do nothing - 5.9-GE-3-ST - 6 seconds
                        # 3 - do nothing - 5.9-GE-3-ST - 6 seconds

                        # 1 - 5.9-GE-3-ST - 6 seconds
                        # 2 - 5.9-GE-3-ST - 7 seconds
                        # 3 - 5.9-GE-3-ST - 7 seconds
                        #unset 'iaINSTALLED[iCOUNTER]'
                        #unset 'iaEXTRACTED[iCOUNTER]'

                        # Progress report
                        iPROGRESS=$(((iCOUNTER*100)/iTOTAL_FILES))
                        [[ $iPROGRESS -ne $iPREV_PROGRESS ]] && printf '\033[u%s' "... ${iPROGRESS}%" # Only update the progress when it actually changes
                        iPREV_PROGRESS=$iPROGRESS
                    done
                    iEND_TIME_SECONDS=$(date +%s)
                # begin comparing, using the slower method
                # if the number of elements don't match, check only the files that appear in the archive against the matching file in the install path
                # NOTE this method is quite a bit slower TODO learn a better way
                # for each file in iaEXTRACTED, find the entry in iaINSTALLED that matches it (as much as is possible), then compare them
                elif [[ $iFILE_COUNT_MATCH -eq 0 ]]; then
                    iTOTAL_FILES=${#iaEXTRACTED[@]}
                    iSTART_TIME_SECONDS=$(date +%s)
                    for iCOUNTER_EXTRACTED in "${!iaEXTRACTED[@]}"; do
                        # strip away the part of the path that is different for the current file
                        sCOMPARE_EXTRACTED=${iaEXTRACTED[iCOUNTER_EXTRACTED]/#$sTMP_PATH\/}

                        for iCOUNTER_INSTALLED in "${!iaINSTALLED[@]}"; do
                            # strip away the part of the path that is different for the current file
                            sCOMPARE_INSTALLED=${iaINSTALLED[iCOUNTER_INSTALLED]/#$sGE_INSTALL_PATH\/}

                            if [[ $sCOMPARE_INSTALLED = "$sCOMPARE_EXTRACTED" ]]; then
                                cmp -s "${iaINSTALLED[iCOUNTER_INSTALLED]}" "${iaEXTRACTED[iCOUNTER_EXTRACTED]}"
                                case $? in
                                    (0) ((iMATCH_COUNTER++)) ;;
                                    (1) ((iMISMATCH_COUNTER++)) ;;
                                    (2) ((iMISSING_COUNTER++)) ;;
                                esac
                                # Some test results - fastest is what remains
                                # TODO use new SpaceRemaining function to compare both in /tmp if there's plenty of free space?
                                # fastest - 5.9-GE-3-ST - 246 seconds
                                unset 'iaINSTALLED[iCOUNTER_INSTALLED]'

                                # do nothing1 - 5.9-GE-3-ST - 376 seconds
                                # do nothing2 - 5.9-GE-3-ST - 484 seconds

                                # 5.9-GE-3-ST - 486 seconds
                                #iaINSTALLED=(${iaINSTALLED[@]:0:$iCOUNTER_INSTALLED} ${iaINSTALLED[@]:$((iCOUNTER_INSTALLED+1))})

                                # 5.9-GE-3-ST - 398 seconds
                                #iaINSTALLED=("${iaINSTALLED[@]:0:$iCOUNTER_INSTALLED}" "${iaINSTALLED[@]:$((iCOUNTER_INSTALLED+1))}")

                                #unset 'iaEXTRACTED[iCOUNTER_EXTRACTED]'
                                #iaEXTRACTED=(${iaEXTRACTED[@]:0:$iCOUNTER_EXTRACTED} ${iaEXTRACTED[@]:$((iCOUNTER_EXTRACTED+1))})
                                #iTOTAL_FILES=${#iaEXTRACTED[@]}
                            fi
                        done

                        # Progress report
                        iPROGRESS=$(((iCOUNTER_EXTRACTED*100)/iTOTAL_FILES))
                        [[ $iPROGRESS -ne $iPREV_PROGRESS ]] && printf '\033[u%s' "... ${iPROGRESS}%" # Only update the progress when it actually changes
                        iPREV_PROGRESS=$iPROGRESS
                    done
                    iEND_TIME_SECONDS=$(date +%s)
                fi
                printf "\033[u\033[0K%s\n" ". Finished in $((iEND_TIME_SECONDS-iSTART_TIME_SECONDS)) seconds."

                echo "$iMATCH_COUNTER files match. $iMISSING_COUNTER files are missing. $iMISMATCH_COUNTER do not match."
            fi
            # Quit after one round - for debugging/speed/optimization tests
            #return 0
        }
    done

    return 0
}

###############################################################################
# Wrapper for QueryGEAttribute to first check latest.json, then if a value other
# than NULL is not returned, check releases.json.
# Accepts two required parameters, version and attribute, returns the value or NULL if not found/error
# NOTE attributes are validated in QueryJSONAttribute
QueryGEAttribute() {

    [[ -z $1 || -z $2 || $# -ne 2 ]] && { DebugMessage "Parameter error 1: \"$1\" 2: \"$2\" \$#: \"$#\""; return 1; }

    local sVERSION=$(CleanUpVersion "${1-}")
    local sVALUE=''
    local sATTRIBUTE=$2
    local iEXIT_STATUS

    if UpdateSavedGELatestRelease; then
        DebugMessage "UpdateSavedGELatestRelease returned success"
    else
        DebugMessage "UpdateSavedGELatestRelease returned failure"
    fi

    sVALUE=$(QueryJSONAttribute "$sFILE_LATEST_JSON" "$sVERSION" "$sATTRIBUTE")
    iEXIT_STATUS=$?
    if [[ $iDEBUG -eq 1 && $iEXIT_STATUS -gt 0 ]]; then
        DebugMessage "QueryJSONAttribute returned failure"
    elif [[ $iDEBUG -eq 1 && $iEXIT_STATUS -eq 0 ]]; then
        DebugMessage "QueryJSONAttribute returned success"
    elif [[ $iDEBUG -eq 1 ]]; then
        DebugMessage "QueryJSONAttribute unknown exit status \$?: \"$?\""
    fi

    # if the returned value from QueryJSONAttribute was NULL, try searching in releases
    if [[ -z $sVALUE ]]; then
        if UpdateSavedGEReleases; then
            DebugMessage "UpdateSavedGEReleases returned success"
        else
            DebugMessage "UpdateSavedGEReleases returned failure"
        fi

        sVALUE=$(QueryJSONAttribute "$sFILE_RELEASES_JSON" "$sVERSION" "$sATTRIBUTE")
        iEXIT_STATUS=$?
        [[ $iDEBUG -eq 1 ]] && {
            if [[ $iEXIT_STATUS -gt 0 ]]; then
                DebugMessage "QueryJSONAttribute returned failure status"
            elif [[ $iEXIT_STATUS -eq 0 ]]; then
                DebugMessage "QueryJSONAttribute returned success status"
            else
                DebugMessage "QueryJSONAttribute unknown exit status \$?: \"$?\""
            fi
        }
    fi

    if [[ -n $sVALUE ]]; then
        printf '%s' "$sVALUE"
        return 0
    else
        printf ''
        return 1
    fi

    # NOTE do not return 0/1 here
}

###############################################################################
# Return the value of a requested attribute from a saved latest/releases JSON file
# value = $( QueryJSONAttribute "file.json" "version" "attribute")
# NOTE This function relies on the JSON being in an exact order, if that order is changed (eg. by the github api) this function will cease to work
# Example JSON order expected (line numbers are irrelevant, what matters is the order they appear in):
# 1.(Line 41) "name": "Proton-5.9-GE-5-ST.tar.gz",
# 2.(Line 65) "size": 406721946,
# 3.(line 69) "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
#
# NOTE the default media-type requested is "application/vnd.github.v3.text+json" (I may make use of the body_text which generally contains change/update notes)
QueryJSONAttribute() {

    if [[ $# -ne 3 ]] || [[ ! -f $1 ]] || [[ -z $1 || -z $2 || -z $3 ]]; then
        DebugMessage "Invalid parameter error 1: \"$1\" 2: \"$2\" 3: \"$3\" \$#: \"$#\""
        return 1
    fi

    [[ ${3,,} != @(size|browser_download_url) ]] && { DebugMessage "Unsupported attribute requested \"$2\""; return 1; }

    local sVERSION=''
    local iSIZE=''
    local sBROWSER_URL=''
    local sATTRIBUTE=''
    local iLINE_COUNTER=0
    local iLINE_VERSION_FOUND=0
    local iLINE_SIZE_FOUND=0
    local iLINE_BROWURL_FOUND=0
    local iFLAG_VERSION_FOUND=0
    local iFLAG_SIZE_FOUND=0
    #local iFLAG_BROWURL_FOUND=0

    sVERSION=$(CleanUpVersion "$2")

    [[ -z $sVERSION ]] && { DebugMessage "sVERSION is NULL"; return 1; }

    sATTRIBUTE=${3,,}

    # WARNING do not manually output to stdout in this loop (unless you connect the file to different fd, and set read -u accordingly)
    while IFS= read -r; do
        ((iLINE_COUNTER++))
        # version match
        # sVERSION example: 5.9-GE-5-ST
        # NOTE must be compatible with all 3 of the following potential formats
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        #         "name": "Proton-5.9-GE-5-ST.tar.gz",
        # "name":"Proton-5.9-GE-5-ST.tar.gz"
        [[ $REPLY =~ ^.*\"name\":.*\"Proton-${sVERSION}\.tar\.gz\".*$ ]] && {
            iFLAG_VERSION_FOUND=1
            iLINE_VERSION_FOUND=$iLINE_COUNTER
        }

        # NOTE must be compatible with all 3 of the following potential formats
        # "size":406721946,"download_count":6780,"created_at":"2020-07-29T05:00:40Z"
        #         "size": 406721946,
        # "size":406721946
        [[ $iFLAG_VERSION_FOUND -eq 1 ]] && {
            [[ ${REPLY,,} =~ ^.*\"size\":.*[[:digit:]]+.*$ ]] && {
                iFLAG_SIZE_FOUND=1
                iLINE_SIZE_FOUND=$iLINE_COUNTER
                iSIZE=${REPLY//[[:space:]]}
                iSIZE=${iSIZE/#\"size\":}
                iSIZE=${iSIZE%%[[:punct:]]*} # iSIZE=${iSIZE%,*}
                continue
            }
        }

        # NOTE must be compatible with all 3 of the following potential formats
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        #         "browser_download_url": "https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"
        # "browser_download_url":"https://github.com/GloriousEggroll/proton-ge-custom/releases/download/5.9-GE-5-ST/Proton-5.9-GE-5-ST.tar.gz"}],"tarball_url":"https://api.github.com/repos/GloriousEggroll/proton-ge-custom/tarball/5.9-GE-5-ST"
        [[ $iFLAG_VERSION_FOUND -eq 1 && $iFLAG_SIZE_FOUND -eq 1 ]] && {
            [[ $REPLY =~ ^.*\"browser_download_url\":.*\".*Proton-${sVERSION}\.tar\.gz\".*$ ]] && {
                #iFLAG_BROWURL_FOUND=1
                iLINE_BROWURL_FOUND=$iLINE_COUNTER
                sBROWSER_URL=${REPLY/#*\"browser_download_url\":}
                sBROWSER_URL=${sBROWSER_URL//[[:space:]]}
                sBROWSER_URL=${sBROWSER_URL/#\"}
                sBROWSER_URL=${sBROWSER_URL%%\"*}
                break
            }
        }
    done < "$1" 2>/dev/null

    # debug messages
    [[ $iDEBUG -eq 1 ]] && {
        if [[ $iFLAG_VERSION_FOUND -eq 0 ]]; then
            DebugMessage "Version match not found"
        elif [[ $iFLAG_VERSION_FOUND -eq 1 ]]; then
            DebugMessage "Version match found at line $iLINE_VERSION_FOUND"
        fi
        if [[ -z $iSIZE ]]; then
            DebugMessage "iSIZE is NULL"
        else
            DebugMessage "iSIZE: \"$iSIZE\""
        fi
        if [[ -z $sBROWSER_URL ]]; then
            DebugMessage "sBROWSER_URL is NULL"
        else
            DebugMessage "sBROWSER_URL: \"$sBROWSER_URL\""
        fi
        DebugMessage "iLINE_VERSION_FOUND: $iLINE_VERSION_FOUND iLINE_SIZE_FOUND: $iLINE_SIZE_FOUND iLINE_BROWURL_FOUND: $iLINE_BROWURL_FOUND"
    }

    # output the value of the requested attribute
    if [[ -n $iSIZE && -n $sBROWSER_URL ]]; then
        case $sATTRIBUTE in
            (size)
                printf '%s' "$iSIZE" >&1
            ;;
            (browser_download_url)
                printf '%s' "$sBROWSER_URL" >&1
            ;;
            (*)
                # NOTE NULL response indicates error OR not found. check return status, response, and debug messages
                printf ''
                return 1
            ;;
        esac
    else
        printf ''
        return 1
    fi

    return 0
}

###############################################################################
# Run the sed script created by CreateSedUnminifyJSONscript on a supplied path/file
# TODO
ReformatJSONUsingSed() {

    local sFILE_JSON=$1

    [[ -z $sFILE_JSON || ! -f $sFILE_JSON ]] && { DebugMessage "Parameter error (NULL or not a file)"; return 1; }

    DebugMessage "sFILE_JSON: \"$sFILE_JSON\""

    if [[ -f $sFILE_JSON && -w $sFILE_JSON ]]; then
        CreateBackup "$sFILE_JSON"
        if sed -f "$sFILE_SED_UNMINIFY_SCRIPT" -i "$sFILE_JSON"; then
            DebugMessage "'sed' returned success"
            return 0
        else
            DebugMessage "'sed' returned failure"
            return 1
        fi
    else
        DebugMessage "Invalid file requested: \"$sFILE_JSON\""
        return 1
    fi

    return 0
}

###############################################################################
# Detect if a string is minified or not (zero newlines)
# return 0 if yes, 1 if no
# NOTE the current un-minify script works on both minified and not-minified JSON data
#      so this function is pointless other than reporting debug info
IsJSONminified() {

    local sJSON=$1

    [[ -z $sJSON ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    # NOTE do not use herestring
    iLINES=$(printf '%s' "$sJSON" | wc -l)
    DebugMessage "iLINES: \"$iLINES\""
    # 0 is the actual value of a minified JSON response, 1 is used in case a mistake is
    # made handling the string and a trailing newline is added
    if [[ $iLINES -le 1 ]]; then
        DebugMessage "JSON is minified"
        return 0
    else
        DebugMessage "JSON is not minified"
        return 1
    fi

    # assume it is minified if an error occurs
    # NOTE the unminify script works on both minified and un-minified JSON
    # NOTE it will also reformat the body_text section if needed when the media type
    #      "application/vnd.github.v3.text+json" is requested (default)

    return 0
}

###############################################################################
# If the sed script sFILE_SED_UNMINIFY_SCRIPT is not found or it's size doesn't match what's expected, create it
# This sed script is used to un-minify minified JSON and reformat the body_text section
# NOTE supports both unminified and minified input
# TODO
CreateSedUnminifyJSONscript() {

    if [[ ! -f $sFILE_SED_UNMINIFY_SCRIPT ]] || [[ $(stat -c '%s' "$sFILE_SED_UNMINIFY_SCRIPT") -ne $iSIZE_BYTES_SED_UNMINIFY_SCRIPT ]]; then
        DebugMessage "'sed' script at \"$sFILE_SED_UNMINIFY_SCRIPT\" does not exist or is not the expected size ($iSIZE_BYTES_SED_UNMINIFY_SCRIPT)"
        cat <<"END_OF_SED_SCRIPT" > "$sFILE_SED_UNMINIFY_SCRIPT"
#### begin minimum required for ge-install-manager
# replace: ","
# with:    ",newline"
s/","/"\n"/g
#### end minimum required for ge-install-manager

# replace:  "assets": [
# with:     "assets":newline
s/"assets":\[/"assets":\n/g

# replace:  :{"
# with:     :newline"
s/:{"/:\n"/g

# replace:  "},"
# with:     "newline"
s/"},"/"\n"/g

# replace:  },"
# with:     newline"
s/},"/\n"/g

# replace:  {"
# with:     "
s/{"/"/g

#### Re-format text intended for formating ('\n') in "body_text" when media type
#### "application/vnd.github.v3.text+json" is requested
# replace:  \n
# with:     newline
s/\\n/\n/g

# replace:  ,"
# with:     newline"
s/,"/\n"/g

#### one per release listed
# replace:  "}]
# with:     "
s/"}\]/"/g

# replace:  "}
# with:     "
s/"}/"/g

#### very minor
# replace:  ["
# with:     "
s/\["/"/g
END_OF_SED_SCRIPT
    else
        DebugMessage "'sed' script already exists at sFILE_SED_UNMINIFY_SCRIPT and is the expected size ($iSIZE_BYTES_SED_UNMINIFY_SCRIPT)"
    fi

    return 0
}

###############################################################################
# Check if a version is installed
# Accepts one parameter, the version, in one of the acceptable formats described in usage
# NOTE Currently only checks if a path for the version exists
# TODO better verification
IsInstalled() {

    local sVERSION

    [[ -z $1 ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    sVERSION=$(CleanUpVersion "${1-}")

    DebugMessage "Checking for version \"$sVERSION\" at \"$sGE_INSTALL_PATH/Proton-${sVERSION}\""

    if [[ -d $sGE_INSTALL_PATH/Proton-${sVERSION} ]]; then
        DebugMessage "Version \"$sVERSION\" found"
        return 0
    else
        DebugMessage "Version \"$sVERSION\" not found"
        return 1
    fi

    # NOTE do not return 0 here
}

###############################################################################
# Check if Steam is running using 'ps -e'
# return 0 = Steam is running
# return 1 = Steam is not running / ps is missing / Steam is not running but steamwebhelper is / unknown error
IsSteamRunning() {

    local iSTEAM=0
    local iWEBHLPR=0

    if command -v ps >/dev/null; then # NOTE not needed anymore unless ps is removed while the script is running
        while IFS= read -r; do
            [[ ${REPLY,,} =~ ^.*steam$ ]] && {
                iSTEAM=1
                DebugMessage "'steam' match: \"$REPLY\""
            }
            [[ ${REPLY,,} =~ ^.*steamwebhelper.*$ ]] && {
                iWEBHLPR=1
                DebugMessage "'steamwebhelper' match: \"$REPLY\""
            }
        done < <(ps -e)
        #return $(( iSTEAM == 1 ? 0 : 1 ))

        if [[ $iSTEAM -eq 1 ]]; then
            return 0
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 1 ]]; then
            echo "Warning: at least one steamwebhelper process(es) is still running but Steam is not running"
            # TODO report their PIDs
            return 1
        elif [[ $iSTEAM -eq 0 && $iWEBHLPR -eq 0 ]]; then
            return 1
        else
            DebugMessage "Unknown error iSTEAM: \"$iSTEAM\" iWEBHLPR: \"$iWEBHLPR\" (last)REPLY: \"$REPLY\""
            return 1
        fi
    else
        # ps missing
        DebugMessage "Command 'ps' not found"
        return 1
    fi

    return 1
}

###############################################################################
# RequestURL "URL "path/file"
# If the mtime (determined by curl) is newer for remote (versus local file) download a new one
# TODO
RequestURL() {

    local sURL=$1
    local sFILE=$2
    local sRESPONSE
    local sMODIFIED_RESPONSE

    [[ -z $sURL || -z $sFILE || $# -ne 2 ]] && DebugMessage "Parameter error (NULL or not exactly two)"

    if sRESPONSE=$(curl -sz "$sFILE" \
                        -H "$sCURL_HEADER_USER_AGENT" \
                        -H "$sCURL_HEADER_CONTENT_TYPE" \
                        -H "$sCURL_HEADER_GITHUB_MEDIATYPE" \
                        -L "$sURL" \
                        -o - 2>/dev/null); then

        DebugMessage "'curl' returned success"

        if [[ -n $sRESPONSE ]]; then
            DebugMessage "sRESPONSE is not empty"
            if IsJSONminified "$sRESPONSE"; then
                DebugMessage "IsJSONminified returned success"
            else
                DebugMessage "IsJSONminified returned failure"
            fi
            [[ -f $sFILE ]] && CreateBackup "$sFILE"
            printf '%s' "$sRESPONSE" > "$sFILE"
        else
            DebugMessage "sRESPONSE is NULL"
        fi
        #printf '%s' "$sRESPONSE"
        #return 0
    else
        DebugMessage "'curl' returned failure"
        printf ''
        return 1
    fi

    # Run the minify script whether the response is minified or not
    # NOTE the current un-minify script works on both minified and unminified JSON
    # NOTE It needs to run on both to enable future support for displaying the body_text (update notes) section because
    #      it also transforms literal \n in the body_text to newlines
    if ReformatJSONUsingSed "$sFILE"; then
        DebugMessage "ReformatJSONUsingSed returned success"
        sMODIFIED_RESPONSE=$(cat "$sFILE" 2>/dev/null)
        printf '%s' "${sMODIFIED_RESPONSE%$'\n'}" # remove the newline added by cat
        return 0
    else
        DebugMessage "ReformatJSONUsingSed returned failure"
        printf ''
        return 1
    fi
}

###############################################################################
# Backup a file/path in tar.gz format supporting upto n number of backups with a
# basename suffix of _n. The newest backup is the lowest index (n) and the oldest
# backup is the highest index (n). The backups are stored in the parent path of the
# file/path to be backed up. A maximum of iMAX_NUM_BACKUPS (set below) are kept.
# TODO
CreateBackup() {

    local sBACKUP=${1-}
    local sBACKUP_BASENAME
    local sBACKUP_PATH
    local iMAX_NUM_BACKUPS=3
    local iCOUNTER=0
    local iINDEX=0
    local iRENAME_BACKUPS=0
    local iaBACKUP_FILES=()
    shopt -s nullglob dotglob

    [[ -z $sBACKUP ]] && { DebugMessage "Parameter error (NULL)"; return 1; }
    [[ ! -f $sBACKUP && ! -d $sBACKUP ]] && { DebugMessage "Parameter error (not a file or a path)"; return 1; }

    # If a relative file/path was given
    [[ ${sBACKUP:0:1} != "/" || ${sBACKUP:0:2} == "./" ]] && {
        DebugMessage "Converting relative path to absolute using realpath"
        sBACKUP=$(realpath "$sBACKUP" 2>/dev/null)
    }

    # If backup is a file, get the path to it
    if [[ -f $sBACKUP && ! -d $sBACKUP ]]; then
        DebugMessage "sBACKUP is a regular file"
        sBACKUP_PATH=${sBACKUP%/*}
    else
        DebugMessage "sBACKUP is a path"
        # get one path above the path to backup
        # BUG this may not work in all target environments
        sBACKUP_PATH=$(realpath "$(dirname "$sBACKUP")")
    fi

    sBACKUP_BASENAME=${sBACKUP##*/}
    DebugMessage "sBACKUP_BASENAME set to $sBACKUP_BASENAME"
    DebugMessage "sBACKUP_PATH is $sBACKUP_PATH"

    # determine the basename suffix to use
    for sFILE in "$sBACKUP_PATH/$sBACKUP_BASENAME"*.tar.gz; do
        DebugMessage "Testing if a backup: $sFILE"
        if [[ $sFILE =~ ^.*[^_]_[[:digit:]]{1}\.tar\.gz$ ]]; then
            DebugMessage "Passed regex test \"$sFILE\""
            iINDEX=${sFILE##*_}
            iINDEX=${iINDEX/%.tar.gz}
            DebugMessage "iINDEX is $iINDEX"
            [[ $iINDEX =~ ^[[:digit:]]+$ ]] && {
                ((iCOUNTER++))
                iaBACKUP_FILES+=("$sFILE")
                DebugMessage "Valid backup file found at \"$sFILE\""
                if [[ $iINDEX = "1" ]]; then
                    DebugMessage "iINDEX 1 found, backups need renaming to make room"
                    iRENAME_BACKUPS=1
                fi
            }
        fi
    done
    DebugMessage "Found $iCOUNTER backups"

    if [[ $iRENAME_BACKUPS -eq 1 ]]; then
        iINDEX=$iCOUNTER
        if [[ $iINDEX -ge $iMAX_NUM_BACKUPS ]]; then
            # Remove the oldest (highest index) backup until iMAX_NUM_BACKUPS is reached
            while [[ $iINDEX -ge $iMAX_NUM_BACKUPS ]]; do
                if $sCOMMAND_RM "${iaBACKUP_FILES[iINDEX-1]}"; then
                    DebugMessage "Removed highest index greater than $iMAX_NUM_BACKUPS: \"${iaBACKUP_FILES[iINDEX-1]}\""
                    iINDEX=$((iINDEX-1))
                else
                    echo "($LINENO) CreateBackup: Failed to remove backup file ${iaBACKUP_FILES[iINDEX-1]}"
                    return 1
                fi
            done
        fi

        # Rename existing backups, leaving room for a new index 1
        for ((iINDEX; iINDEX>=1; iINDEX--)); do
            DebugMessage "File: \"${iaBACKUP_FILES[iINDEX-1]}\""
            DebugMessage "Newname: \"${iaBACKUP_FILES[iINDEX-1]/${iINDEX}/$((iINDEX+1))}\""
            if mv "${iaBACKUP_FILES[iINDEX-1]}" "${iaBACKUP_FILES[iINDEX-1]/${iINDEX}/$((iINDEX+1))}"; then
                DebugMessage "${iaBACKUP_FILES[iINDEX-1]} renamed to ${iaBACKUP_FILES[iINDEX-1]/${iINDEX}/$((iINDEX+1))}"
            else
                DebugMessage "Failed to rename backup file: \"${iaBACKUP_FILES[iINDEX-1]}\""
                #return 1
            fi
        done
    else
        DebugMessage "Skipping renaming backups, index 1 not found"
    fi

    DebugMessage "sBACKUP_PATH: $sBACKUP_PATH"
    DebugMessage "sBACKUP_BASENAME: $sBACKUP_BASENAME"
    if tar -C "$sBACKUP_PATH" -czf "$sBACKUP_PATH/${sBACKUP_BASENAME}_1.tar.gz" "$sBACKUP_BASENAME"; then
        DebugMessage "Created new backup at: \"${sBACKUP}_1.tar.gz\""
        return 0
    else
        DebugMessage "Backup failed"
        return 1
    fi

    return 0
}

###############################################################################
# Given a path (filesystem) and a unit (binary prefix), use stat to calculate the
# remaining space on a filesystem by multiplying the filesystem block size by the
# number of remaining blocks and return the value in the unit requested
# NOTE bash arithmatic supports upto 1024^6 (exbibyte)
SpaceRemaining() {

    local sFILE_SYSTEM=$1
    local sBINARY_PREFIX=$2
    local iPOWEROF=0

    [[ -z $sFILE_SYSTEM || -z $sBINARY_PREFIX ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    [[ ! -d $sFILE_SYSTEM ]] && { DebugMessage "Parameter error (not a directory)"; return 1; }

    case ${sBINARY_PREFIX,,} in
        (b|byte|bytes) iPOWEROF=0 ;;
        (k|kibi|kibibyte) iPOWEROF=1 ;;
        (m|mebi|mebibyte) iPOWEROF=2 ;;
        (g|gibi|gibibyte) iPOWEROF=3 ;;
        (t|tebi|tebibyte) iPOWEROF=4 ;;
        (p|pebi|pebibyte) iPOWEROF=5 ;;
        (e|exbi|exbibyte) iPOWEROF=6 ;;
        (*) DebugMessage "Parameter error (invalid unit requested)"; return 1 ;;
    esac

    DebugMessage "Checking \"$sFILE_SYSTEM\""

    if printf '%s' "$(( ($(stat -c '%s' -f "$sFILE_SYSTEM") * $(stat -c '%a' -f "$sFILE_SYSTEM")) / ( 1024 ** iPOWEROF ) ))"; then
        return 0
    else
        return 1
    fi
}

###############################################################################
# Calculate the real remaining memory if MemAvailable isn't available from /proc/meminfo
# Supports some fairly old kernels
# NOTE This function is currently not used by this script. I created this function before
#      SpaceRemaining which is more suitable for use in this script (determining free space
#      on a file system eg. /tmp)
# NOTE 1597756 kB (1x package + 1x extracted package)
# https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0a
# https://github.com/torvalds/linux/blob/6aa303defb7454a2520c4ddcdf6b081f62a15890/mm/page_alloc.c#L4025
MemFree() {

    local iMEM_AVAILABLE=0
    local iNEED_FREE_KB=$1

    [[ -z $iNEED_FREE_KB ]] && { DebugMessage "Parameter error (NULL)"; return 1; }

    DebugMessage "Requested free: $iNEED_FREE_KB"

    # If MemAvailable is present in /proc/meminfo (kernel >= 3.14)
    while IFS= read -r; do
        [[ ${REPLY,,} == *memavailable* ]] && {
            REPLY=${REPLY%[[:blank:]]*}
            iMEM_AVAILABLE=${REPLY##*[[:blank:]]}
            [[ $iMEM_AVAILABLE =~ ^[[:digit:]]+$ ]] && {
                DebugMessage "MemAvailable found in /proc/meminfo"
                DebugMessage "MemAvailable: $iMEM_AVAILABLE"

                return $((iMEM_AVAILABLE > iNEED_FREE_KB ? 0 : 1))
            }
        }
    done < <(cat /proc/meminfo)

    # If MemAvailable is not available in /proc/meminfo - adds support for older kernel versions ( v2.6 < [uname -r] < v3.14)
    DebugMessage "MemAvailable not found, using older methods"

    local iSUM_LOW_WATERMARKS=0
    local iMEM_FREE=0
    local iTOTAL_PAGE_CACHE=0
    local iSRECLAIMABLE=0
    local iAVAILABLE=0
    local iSLAB_UNRECLAIMABLE=0

    # Get the sum of the low water marks across all zones
    while IFS= read -r; do
        [[ ${REPLY,,} == *low* ]] && {
            REPLY=${REPLY//[[:alpha:]]}
            REPLY=${REPLY//[[:blank:]]}
            iSUM_LOW_WATERMARKS=$((iSUM_LOW_WATERMARKS+REPLY))
        }
        # Get nr_slab_unreclaimable if available (v4.8+)
        [[ ${REPLY,,} == *nr_slab_unreclaimable* ]] && {
            REPLY=${REPLY##*[[:blank:]]}
            REPLY=${REPLY%[[:blank:]]*} # Not needed on my system, kept just in case
            iSLAB_UNRECLAIMABLE=$REPLY
        }
    done < <(cat /proc/zoneinfo)
    # TODO 0 could indicate a serious problem or a customization?
    #[[ $iSUM_LOW_WATERMARKS -le 0 ]] && return 1

    # Parse /proc/meminfo
    while IFS= read -r; do
        # MemFree
        [[ ${REPLY,,} == *memfree* ]] && {
            REPLY=${REPLY%[[:blank:]]*}
            iMEM_FREE=${REPLY##*[[:blank:]]}
            iAVAILABLE=$((iMEM_FREE-iSUM_LOW_WATERMARKS))
        }
        # SReclaimable
        [[ ${REPLY,,} == *sreclaimable* ]] && {
            REPLY=${REPLY%[[:blank:]]*}
            iSRECLAIMABLE=${REPLY##*[[:blank:]]}
        }
        # PageCache [ active(file) + inactive(file) ]
        if [[ ${REPLY,,} == *active\(file\)* ]] || [[ ${REPLY,,} == *inactive\(file\)* ]]; then
            REPLY=${REPLY%[[:blank:]]*}
            REPLY=${REPLY##*[[:blank:]]}
            iTOTAL_PAGE_CACHE=$((iTOTAL_PAGE_CACHE+REPLY)) # NOTE two iterations are required to add both
        fi
    done < <(cat /proc/meminfo)

    # pagecache -= min(pagecache / 2, wmark_low);
    # subtract the lower of the two (iTOTAL_PAGE_CACHE/2) vs iSUM_LOW_WATERMARKS
    if [[ $iSUM_LOW_WATERMARKS -lt $((iTOTAL_PAGE_CACHE/2)) ]]; then
        iTOTAL_PAGE_CACHE=$((iTOTAL_PAGE_CACHE - iSUM_LOW_WATERMARKS))
    elif [[ $((iTOTAL_PAGE_CACHE/2)) -lt $iSUM_LOW_WATERMARKS ]]; then
        iTOTAL_PAGE_CACHE=$((iTOTAL_PAGE_CACHE - (iTOTAL_PAGE_CACHE/2) ))
    fi

    # reclaimable
    # subtract the lower of the two (iSRECLAIMABLE/2) vs iSUM_LOW_WATERMARKS
    if [[ $iSUM_LOW_WATERMARKS -lt $((iSRECLAIMABLE/2)) ]]; then
        iSRECLAIMABLE=$((iSRECLAIMABLE - iSUM_LOW_WATERMARKS ))
    elif [[ $((iSRECLAIMABLE/2)) -lt $iSUM_LOW_WATERMARKS ]]; then
        iSRECLAIMABLE=$((iSRECLAIMABLE - (iSRECLAIMABLE/2) ))
    fi

    # Add both to iAVAILABLE for the grand total
    # NOTE nr_slab_unreclaimable may not be available on [uname -r] < 4.8
    if [[ $iSLAB_UNRECLAIMABLE -gt 0 ]]; then
        DebugMessage "Using kernel v4.8+ calculation"
        iAVAILABLE=$(( (iAVAILABLE + iTOTAL_PAGE_CACHE + iSRECLAIMABLE) - iSLAB_UNRECLAIMABLE ))
    else
        DebugMessage "Using kernel <4.8 calculation"
        iAVAILABLE=$(( (iAVAILABLE + iTOTAL_PAGE_CACHE + iSRECLAIMABLE) - (12 * iSUM_LOW_WATERMARKS) ))
    fi
    DebugMessage "Available: $iAVAILABLE"

    return $((iAVAILABLE > iNEED_FREE_KB ? 0 : 1))
}

###############################################################################
# If a sFILE_SCRIPT_CONFIG is not found, create a default there
# NOTE ${XDG_DATA_HOME:-"$HOME"/.local/share/Steam/compatibilitytools.d}
CreateDefaultConfigFile() {

    cat <<DEFAULT_CONFIG > "$sFILE_SCRIPT_CONFIG"
#
# $sSCRIPT_FULL_NAME v$sSCRIPT_VERSION Default configuration file
#
# Quick start format:
# #comment
# key=value #comment
#
# Lines begining with an octothorpe "#" are considered comment lines and are ignored.
# Anything appearing after an octothorpe "#" on a line is considered a comment and ignored.
# Empty lines and lines that begin with space/tab are ignored.
# Lines that contain one or more semi-colon(s) ";" will be ignored.
# Lines that contain potential escape codes are ignored.
# Keys with no values are ignored (eg. "key=" and "key").
#
# Paths (install, config, cache, and tmp) do not have to exist but
# the script will need write permission to create them for you.
#
# When install_path is set to the special value "auto", the script will
# attempt to auto-detect the Steam installation path.
#
# Environment variables and script global variables will be expanded.
# \$sSCRIPT_FULL_NAME is a script global variable that is always set to the basename of the script.
#
# Symlinks will not be resolved/canonicalized (they are safe to use).
#
# Do not quote variables outside parameter expansions (:+, :-, :=, or :?) unless
# you want them included in the value.
#
DEFAULT_CONFIG
    cat <<"DEFAULT_CONFIG" >> "$sFILE_SCRIPT_CONFIG"

# Default install path
install_path=auto

# Default config path
config_path=${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME

# Default cache path
cache_path=${XDG_CACHE_HOME:-"$HOME"/.cache}/$sSCRIPT_FULL_NAME

# Default command used instead of rm (for removing all but temporary files)
# NOTE: Any command and its parameters that support the last parameter being either a file or a path is supported
rm_command=trash

# Default URL used to retrieve 'latest' JSON
latest_version_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases/latest

# Default URL used to retrieve 'releases' JSON
releases_url=https://api.github.com/repos/GloriousEggroll/proton-ge-custom/releases

# Default temporary file path
tmp_path=/tmp
DEFAULT_CONFIG

    return 0
}


###############################################################################
# Parse the config file specified by sFILE_SCRIPT_CONFIG (create it if it doesn't exist)
# validating recognized keys and their values, set global variables accordingly
# NOTE: Runs DetectSteamInstallPath if install_path (in the config) is set to the special
# value "auto".
ParseConfigFile() {

    local iNUM_LINES=0
    local iCOUNTER=0
    local iFAILED=0
    local iUPDATE_GEINSTALL_PATH=0

    iNUM_LINES=$(wc -l 2>/dev/null < "$sFILE_SCRIPT_CONFIG")
    [[ -z $iNUM_LINES ]] && {
        DebugMessage "Generating a default config file at: \"$sFILE_SCRIPT_CONFIG\""
        if CreateDefaultConfigFile; then
            DebugMessage "CreateDefaultConfigFile returned success"
            echo "Default configuration created at \"$sFILE_SCRIPT_CONFIG\""
            if [[ -n ${EDITOR-} ]]; then
                DebugMessage "EDITOR is set to: \"$EDITOR\""
                while :; do
                    read -rp "Would you like to open it with ${EDITOR}? " </dev/tty
                    case ${REPLY,,} in
                        ("y"|"yes")
                            $EDITOR "$sFILE_SCRIPT_CONFIG"
                            exit 0
                        ;;
                        ("n"|"no")
                            exit 0
                        ;;
                        ("*")
                            echo "Enter (y)es or (n)o"
                        ;;
                    esac
                done
            else
                DebugMessage "\$EDITOR is empty"
                echo "EDITOR not set, default configuration created at \"$sFILE_SCRIPT_CONFIG\""
            fi
            exit 0
        else
            DebugMessage "CreateDefaultConfigFile returned failure status"
            return 1
        fi
    }
    DebugMessage "sFILE_SCRIPT_CONFIG \"$sFILE_SCRIPT_CONFIG\" contains $iNUM_LINES newlines"

    [[ -z $sFILE_SCRIPT_CONFIG || ! -f $sFILE_SCRIPT_CONFIG || ! -w $sFILE_SCRIPT_CONFIG ]] && {
        DebugMessage "sFILE_SCRIPT_CONFIG error (NULL, not a file, or not writeable)"
        return 1
    }

    while IFS= read -r; do
        ((iCOUNTER++))
        # Ignore lines that being with a #
        [[ $REPLY =~ ^#.*$ ]] && { DebugMessage "Ignoring line $iCOUNTER (begins with a \"#\")"; continue; }

        # Ignore lines that contain one or more semi-colon ";"
        [[ $REPLY =~ ^.*\;+.*$ ]] && { DebugMessage "Ignoring line $iCOUNTER (contains one or more \";\")"; continue; }

        # Lines containing potential escape codes are ignored
        [[ $REPLY =~ ^.*\\[[:digit:]]+\[.*$ ]] && { DebugMessage "Ignoring line $iCOUNTER (contains potential escape code)"; continue; }

        # Trim comments that don't appear at the begining away and then trim any remaining trailing spaces/tabs
        if [[ $REPLY =~ ^.*#.*$ ]] || [[ $REPLY =~ ^.*#$ ]]; then
            DebugMessage "Partially commented line $iCOUNTER: \"$REPLY\""
            # remove the # and everything to the right of it
            REPLY=${REPLY%%'#'*}
        fi

        # Ignore lines that are empty after stripping comments away
        [[ $REPLY =~ ^$ ]] && { DebugMessage "Ignoring line $iCOUNTER (empty)"; continue; }

        # Ignore lines that begin with one or more space/tab
        [[ $REPLY =~ ^[[:blank:]]+ ]] && { DebugMessage "Ignoring line $iCOUNTER (begins with space or tab)"; continue; }

        # Ignore lines that may contain a key and an = and the value would be nothing or have a leading space/tab
        [[ $REPLY =~ ^.*=[[:blank:]]*$|^.*=$ ]] && { DebugMessage "Ignoring line $iCOUNTER (key with no value)"; continue; }

        # Ignore lines that don't contain exactly one =
        [[ $REPLY =~ (^|[^=])=($|[^=]) ]] || { DebugMessage "Ignoring line $iCOUNTER (more than one =)"; continue; }

        # Trim lines that still have space/tab at the end
        while [[ ${REPLY:$((${#REPLY}-1)):1} = [[:blank:]] ]]; do
            DebugMessage "Trim trailing [[:blank:]] ($iCOUNTER): \"$REPLY\""
            REPLY=${REPLY:0:$((${#REPLY}-1))}
        done

        DebugMessage "Valid config ($iCOUNTER): \"$REPLY\""

        sKEY=${REPLY%%=*}
        sVALUE=${REPLY#*=}

        DebugMessage "($iCOUNTER) Key: \"$sKEY\" Value: \"$sVALUE\""

        # expand any variables in the config, additionaly supporting some basic parameter expansion
        # such as :-, :=, :?, and/or :+
        #
        # NOTE: If sVALUE contains a :+, :-, :=, or :? envsubst does not handle parameter expansion
        if [[ $sVALUE =~ ^.*:[+-=?]{1}.*$ ]]; then
            DebugMessage "Using 'eval' to expand sVALUE: \"$sVALUE\""
            sVALUE=$(eval printf '%s' "$sVALUE")
            #echo "value: $(eval echo "$sVALUE")"
            DebugMessage "sVALUE expanded to: \"$sVALUE\""
        else
            if command -v envsubst >/dev/null; then
                DebugMessage "Using 'envsubst' to expand sVALUE: \"$sVALUE\""
                sVALUE=$(envsubst <<< "$sVALUE")
                # If there is still a $ in sVALUE it contained a variable envsubst can't handle
                [[ $sVALUE =~ ^.*\$+.*$ ]] && {
                    DebugMessage "sVALUE still contains one or more $ after envsubst"
                    sVALUE=$(eval printf '%s' "$sVALUE")
                    DebugMessage "sVALUE expanded again with 'eval' to: \"$sVALUE\""
                }
                DebugMessage "sVALUE expanded to: \"$sVALUE\""
            else
                DebugMessage "Command 'envsubst' not available, using 'eval' to expand sVALUE: \"$sVALUE\""
                sVALUE=$(eval printf '%s' "$sVALUE")
                DebugMessage "sVALUE expanded to: \"$sVALUE\""
            fi
        fi

        # Validate values for recognized keys and set global variables accordingly
        case $sKEY in
            (install_path)
                # if the value for install_path is the special value "auto", attempt to auto detect the steam install path
                # NOTE if one is found/chosen the global variable sOVERRIDE_DEFAULT_INSTALL_PATH will be set accordingly
                #      a value of NULL indicates a problem, error, or user chose manual configuration
                [[ ${sVALUE,,} = "auto" ]] && {
                    DebugMessage "$sKEY is set to $sVALUE, Running DetectSteamInstallPath"
                    DetectSteamInstallPath
                    if [[ -n $sOVERRIDE_DEFAULT_INSTALL_PATH && ${sOVERRIDE_DEFAULT_INSTALL_PATH,,} != "auto" ]]; then
                        sVALUE=$sOVERRIDE_DEFAULT_INSTALL_PATH/compatibilitytools.d
                        iUPDATE_GEINSTALL_PATH=1
                    else
                        # set it back to null
                        #sVALUE=$sOVERRIDE_DEFAULT_INSTALL_PATH
                        return 1
                    fi
                }
                if [[ -d $sVALUE && -w $sVALUE ]]; then
                    DebugMessage "$sVALUE is a directory and the script has write permission to it"
                    sGE_INSTALL_PATH=$sVALUE
                    iUPDATE_GEINSTALL_PATH=1 # probably not needed, unless things change
                else
                    DebugMessage "$sVALUE is not a valid path, attempting to create it"
                    if mkdir -p "$sVALUE" 2>/dev/null; then
                        if [[ -w $sVALUE ]]; then
                            DebugMessage "script has write permission to sVALUE"
                            sGE_INSTALL_PATH=$sVALUE
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                            iFAILED=1
                            iUPDATE_GEINSTALL_PATH=0
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                        iFAILED=1
                        iUPDATE_GEINSTALL_PATH=0
                    fi
                fi
            ;;
            (config_path)
                if [[ -d $sVALUE && -w $sVALUE ]]; then
                    DebugMessage "$sVALUE is a directory and the script has write permission to it"
                    sSCRIPT_CONFIG_PATH=$sVALUE
                else
                    DebugMessage "$sVALUE is not a valid path, attempting to create it"
                    if mkdir -p "$sVALUE" 2>/dev/null; then
                        if [[ -w $sVALUE ]]; then
                            DebugMessage "script has write permission to sVALUE"
                            sSCRIPT_CONFIG_PATH=$sVALUE
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                            iFAILED=1
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                        iFAILED=1
                    fi
                fi
            ;;
            (cache_path)
                if [[ -d $sVALUE && -w $sVALUE ]]; then
                    DebugMessage "$sVALUE is a directory and the script has write permission to it"
                    sSCRIPT_CACHE_PATH=$sVALUE
                else
                    DebugMessage "$sVALUE is not a valid path, attempting to create it"
                    if mkdir -p "$sVALUE" 2>/dev/null; then
                        if [[ -w $sVALUE ]]; then
                            DebugMessage "script has write permission to sVALUE"
                            sSCRIPT_CACHE_PATH=$sVALUE
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                            iFAILED=1
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                        iFAILED=1
                    fi
                fi
            ;;
            (tmp_path) # sTMP_BASE_PATH
               if [[ -d $sVALUE && -w $sVALUE ]]; then
                    DebugMessage "$sVALUE is a directory and the script has write permission to it"
                    sTMP_BASE_PATH=$sVALUE
                else
                    DebugMessage "$sVALUE is not a valid path, attempting to create it"
                    if mkdir -p "$sVALUE" 2>/dev/null; then
                        if [[ -w $sVALUE ]]; then
                            DebugMessage "script has write permission to sVALUE"
                            sTMP_BASE_PATH=$sVALUE
                        else
                            echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                            iFAILED=1
                        fi
                    else
                        echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                        iFAILED=1
                    fi
                fi
            ;;
            (rm_command)
                if command -v "$sVALUE" >/dev/null; then
                    sCOMMAND_RM=$sVALUE
                    DebugMessage "sCOMMAND_RM set to: \"$sCOMMAND_RM\""
                else
                    DebugMessage "command -v \"$sVALUE\" failed"
                    echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                    echo "($LINENO) ParseConfigFile: If you don't want to use 'rm' then fix it"
                    sCOMMAND_RM="rm"
                fi
            ;;
            (latest_version_url)
                if curl -sLI "$sVALUE" >/dev/null; then
                    sGE_LATEST_VERSION_URL=$sVALUE
                    DebugMessage "sGE_LATEST_VERSION_URL set to: \"$sGE_LATEST_VERSION_URL\""
                else
                    echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                    iFAILED=1
                fi
            ;;
            (releases_url)
                if curl -sLI "$sVALUE" >/dev/null; then
                    sGE_RELEASES_URL=$sVALUE
                    DebugMessage "sGE_RELEASES_URL set to: \"$sGE_RELEASES_URL\""
                else
                    echo "($LINENO) ParseConfigFile: Invalid value for $sKEY at line $iCOUNTER: \"$sVALUE\""
                    iFAILED=1
                fi
            ;;
        esac
    done < "$sFILE_SCRIPT_CONFIG"

    # Update install_path in the configuration file if necessary
    [[ $iUPDATE_GEINSTALL_PATH -eq 1 ]] && {
        [[ -n $sOVERRIDE_DEFAULT_INSTALL_PATH ]] && {
            sGE_INSTALL_PATH=$sOVERRIDE_DEFAULT_INSTALL_PATH/compatibilitytools.d
            # update install_path in the config file
            sed -i.bak "s|install_path=auto|install_path=$sGE_INSTALL_PATH|" "$sFILE_SCRIPT_CONFIG"
        }
    }

    # Report
    # NOTE cp --parents requires GNU cp (not on mac by default)
    # NOTE cp -Rp
    DebugMessage "Install path set to: \"$sGE_INSTALL_PATH\""

    DebugMessage "Temp file path set to: \"$sTMP_BASE_PATH\""

    DebugMessage "Config path set to: \"$sSCRIPT_CONFIG_PATH\""
    # update global variables that depend on this one
    sFILE_SCRIPT_CONFIG=$sSCRIPT_CONFIG_PATH/$sSCRIPT_FULL_NAME.conf
    DebugMessage "sFILE_SCRIPT_CONFIG set to: \"$sFILE_SCRIPT_CONFIG\""
    sFILE_SED_UNMINIFY_SCRIPT="$sSCRIPT_CONFIG_PATH/unminify-JSON.sed"
    DebugMessage "sFILE_SED_UNMINIFY_SCRIPT set to: \"$sFILE_SED_UNMINIFY_SCRIPT\""

    DebugMessage "Cache path set to: \"$sSCRIPT_CACHE_PATH\""
    # update global variables that depend on this one
    sFILE_LATEST_JSON="$sSCRIPT_CACHE_PATH"/latest.json
    DebugMessage "sFILE_LATEST_JSON set to: \"$sFILE_LATEST_JSON\""
    sFILE_RELEASES_JSON="$sSCRIPT_CACHE_PATH"/releases.json
    DebugMessage "sFILE_RELEASES_JSON set to: \"$sFILE_RELEASES_JSON\""

    if [[ $iFAILED -eq 1 ]]; then
        DebugMessage "One or more tasks failed"
        return 1
    else
        DebugMessage "All tasks and checks passed"
        return 0
    fi
}

###############################################################################
# Support different formats for version specification
# Internally, the script uses case-sensitive "base" versions such as "5.9-GE-5-ST" but
# for parsing parameters many other variations are supported. Examples are in usage above.
# NOTE not only does this enable multiple types of input but it also enables reporting
#      with the exact input given which may or may not be helpful in case of an error/problem
# NOTE if the naming format for packages changes, this function also must be adapted
# TODO support even more variations?
CleanUpVersion() {

    local iLENGTH=0
    local sVERSION=${1-}

    [[ -z $sVERSION ]] && {
        DebugMessage "sVERSION is NULL"
        printf ''
        return 1
    }

    [[ $iDEBUG -eq 1 ]] && {
        iLENGTH=${#sVERSION}
        DebugMessage "Before: \"$sVERSION\""
    }

    # global upper case
    sVERSION=${sVERSION^^}
    # anchored left, remove a single "PROTON-" and anything to the left of it
    sVERSION=${sVERSION#*'PROTON-'}
    # anchored right, remove a single ".TAR.GZ" and anything to the right of it
    sVERSION=${sVERSION%'.TAR.GZ'*}

    [[ $iDEBUG -eq 1 ]] && {
        DebugMessage "After: \"$sVERSION\""
        [[ $iLENGTH -ne ${#sVERSION} ]] && DebugMessage "Removed $(( iLENGTH - ${#sVERSION} )) characters"
    }

    printf '%s' "$sVERSION"

    return 0
}

###############################################################################
# Bash only primitive replacement for mktemp
# Accepts no parameters, returns the tmp path/file created
MkTempFile() {

    local sTMP_FILE_CREATED

    [[ -d $sTMP_BASE_PATH && -w $sTMP_BASE_PATH ]] || { DebugMessage "sTMP_BASE_PATH is not a valid path or no write access: \"$sTMP_BASE_PATH\""; return 1; }

    sTMP_FILE_CREATED="$sTMP_BASE_PATH/${sTMP_PREFIX}$(GenerateRandomAlphaNumericString 10)"

    # Create the empty temp file
    printf '' > "$sTMP_FILE_CREATED"

    # "Return" the path and filename,
    # meant to be captured using command substitution eg. sTEMPFILE=$(MkTemp)
    printf '%s' "$sTMP_FILE_CREATED"

    return 0
}

###############################################################################
# Bash only primitive replacement for mktemp
# Accepts no parameters, returns the tmp path created
MkTempPath() {

    local sTMP_PATH_CREATED

    [[ -d $sTMP_BASE_PATH && -w $sTMP_BASE_PATH ]] || { DebugMessage "sTMP_BASE_PATH is not a valid path or no write access: \"$sTMP_BASE_PATH\""; return 1; }

    sTMP_PATH_CREATED="$sTMP_BASE_PATH/${sTMP_PREFIX}$(GenerateRandomAlphaNumericString 10)"

    # Create the path
    mkdir -p "$sTMP_PATH_CREATED" 2>dev/null

    # "Return" the path and filename,
    # meant to be captured using command substitution eg. sTEMPFILE=$(MkTemp)
    printf '%s' "$sTMP_PATH_CREATED"

    return 0
}

###############################################################################
# Generate a pseudo-random alphanumeric string using only Bash
# Accepts one optional parameter: the length of the string to generate (range 1-32767) (default: 10)
GenerateRandomAlphaNumericString() {

    local sLIST
    local iLEN=${1:-10}
    local sRESULT
    local iC=1

    sLIST=$(printf '%s' {a..z}{0..9}{A..Z})

    # If the length requested is outside sane upper and lower bounds, reset it
    [[ $iLEN -lt 1 ]] && iLEN=1
    [[ $iLEN -gt 32767 ]] && iLEN=32767

    # Loop iLEN times
    for (( iC; iC<=iLEN; iC++ )) do

        # Randomly choose one offset of length one from sLIST
        sCHAR=${sLIST:$RANDOM%${#sLIST}:1}

        # Randomly invert the case
        (( RANDOM % 2 )) && sCHAR=${sCHAR~}

        # Concatenate sRESULT and sCHAR
        sRESULT=${sRESULT}${sCHAR}

    done

    # "Return" the resulting string,
    # meant to be captured using command substitution
    # eg. sSTRING_OF_LENGTH_TEN=$(GenerateRandomAlphaNumericString 10)
    printf '%s' "$sRESULT"

    return 0
}

###############################################################################
# Attempt to auto-detect the Steam installation path and set the global variable
# sOVERRITE_DEFAULT_INSTALL_PATH accordingly. That variable is then read by
# ParseConfigFile to set install_path in the config file accordingly.
#
# NOTE ~/.steam/root/compatibilitytools.d #proton-ge-custom install notes
#      /usr/share/steam/compatibilitytools.d
#      /usr/local/share/steam/compatibilitytools.d
#      Colon-separated global paths in $STEAM_EXTRA_COMPAT_TOOLS_PATHS
#      ~/.steam/root/compatibilitytools.d (steam install folder symlink) || ~/.local/share/Steam/compatibilitytools.d
#
# flatpak
#      ~/.var/app/com.valvesoftware.Steam/data/Steam/compatibilitytools.d/ #proton-ge-custom install notes
#      ~/.var/app/com.valvesoftware.Steam/.local/share/Steam
#      ~/.var/app/com.valvesoftware.Steam/.steam
DetectSteamInstallPath () {

    sOVERRIDE_DEFAULT_INSTALL_PATH=''

    local iaVALID_PATHS=()
    local iaSEARCH_PATHS=("$HOME/.steam/root" \
                          "${XDG_DATA_HOME:-$HOME/.local/share/Steam}" \
                          "/usr/share/steam" \
                          "/usr/local/share/steam" \
                          "$HOME/.var/app/com.valvesoftware.Steam/data/Steam" \
                          "$HOME/.var/app/com.valvesoftware.Steam/.local/share/Steam" \
                          "$HOME/.var/app/com.valvesoftware.Steam/.steam")

    #sSTEAMSH=$(find / -xdev -type f -name "steam.sh" ! -path "/dev/*" ! -path "/proc/*" 2>/dev/null)
    #sSTEAMCOMPATTOOLSD=$(find / -xdev -type d -name "compatibilitytools.d" ! -path "/dev/*" ! -path "/proc/*" 2>/dev/null)

    # Report the set status of XDG vars
    # XDG_DATA_HOME
    if [[ ${XDG_DATA_HOME-unset} != "unset" ]]; then
        if [[ ${XDG_DATA_HOME-} != "$HOME/.local/share" ]]; then
            DebugMessage "XDG_DATA_HOME is not set to the default: \"$XDG_DATA_HOME\""
        else
            DebugMessage "XDG_DATA_HOME is set to: \"$XDG_DATA_HOME\""
        fi
    else
        DebugMessage "XDG_DATA_HOME is unset"
    fi

    # XDG_CONFIG_HOME
    if [[ ${XDG_CONFIG_HOME-unset} != "unset" ]]; then
        if [[ ${XDG_CONFIG_HOME-} != "$HOME/.config" ]]; then
            DebugMessage "XDG_CONFIG_HOME is not set to the default: \"$XDG_CONFIG_HOME\""
        else
            DebugMessage "XDG_CONFIG_HOME is set to: \"$XDG_CONFIG_HOME\""
        fi
    else
        DebugMessage "XDG_CONFIG_HOME is unset"
    fi

    # XDG_CACHE_HOME
    if [[ ${XDG_CACHE_HOME-unset} != "unset" ]]; then
        if [[ ${XDG_CACHE_HOME-} != "$HOME/.cache" ]]; then
            DebugMessage "XDG_CACHE_HOME is not set to the default: \"$XDG_CACHE_HOME\""
        else
            DebugMessage "XDG_CACHE_HOME is set to: \"$XDG_CACHE_HOME\""
        fi
    else
        DebugMessage "XDG_CACHE_HOME is unset"
    fi

    # Search each known possible, existing Steam install path path for steam.sh
    #
    # ~/.steam/root/compatibilitytools.d
    DebugMessage "iaSEARCH_PATHS: ${#iaSEARCH_PATHS[@]}"
    for sCHECK_PATH in "${iaSEARCH_PATHS[@]}"; do
        DebugMessage "Checking \"$sCHECK_PATH\""
        if [[ -f $sCHECK_PATH/steam.sh ]]; then
            DebugMessage "steam.sh found in $sCHECK_PATH"
            iaVALID_PATHS+=("$sCHECK_PATH")
        else
            DebugMessage "steam.sh not found in $sCHECK_PATH"
        fi
    done

    DebugMessage "#iaVALID_PATHS: ${#iaVALID_PATHS[@]}"
    DebugMessage "iaVALID_PATHS[*]: ${iaVALID_PATHS[*]}"

    if [[ ${#iaVALID_PATHS[@]} -eq 0 ]]; then
        printf '%s\n%s\n%s\n' \
               "ERROR: Unable to detect Steam installation path" \
               "You will need to configure install_path manually in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME/$sSCRIPT_FULL_NAME.conf)"
        sOVERRIDE_DEFAULT_INSTALL_PATH=""
    # Prefer to use the symlink if two paths were found and one is a link to the other
    elif [[ ${#iaVALID_PATHS[@]} -eq 1 ]] || [[ ${#iaVALID_PATHS[@]} -eq 2 && ${iaVALID_PATHS[0]} -ef ${iaVALID_PATHS[1]} ]]; then
        printf '%s\n%s\n%s\n' \
               "Steam install path detected as \"${iaVALID_PATHS[0]}\"" \
               "If that path is incorrect, manually adjust install_path in the configuration file" \
               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME/$sSCRIPT_FULL_NAME.conf)"
        sOVERRIDE_DEFAULT_INSTALL_PATH=${iaVALID_PATHS[0]}
    # Multiple paths detected and the first and second paths checked above are not linked
    elif [[ ${#iaVALID_PATHS[@]} -gt 1 ]] && [[ ${iaVALID_PATHS[0]} -ef ${iaVALID_PATHS[1]} ]]; then
        echo "Multiple Steam install paths detected:"
        for (( i=0; i < ${#iaVALID_PATHS[@]}; i++ )); do
            echo "($((i+1))) ${iaVALID_PATHS[i]}"
        done

        echo "Choose a path from above or type in exit/quit"
        while :; do
            read -rp "Enter a number from 1-${#iaVALID_PATHS[@]}: " </dev/tty
            [[ $REPLY = @(exit|quit) ]] && {
                sOVERRIDE_DEFAULT_INSTALL_PATH=""
                break
            }
            REPLY=${REPLY//[!0-9]/} # typos happen
            case $REPLY in
                (*[[:digit:]]*)
                    if [[ $REPLY -lt 1 || $REPLY -ge $(( ${#iaVALID_PATHS[@]} + 1 )) ]]; then
                        echo "Invalid choice"
                    else
                        DebugMessage "Setting sOVERRIDE_DEFAULT_INSTALL_PATH to \"${iaVALID_PATHS[$((REPLY-1))]}\""
                        sOVERRIDE_DEFAULT_INSTALL_PATH=${iaVALID_PATHS[$((REPLY-1))]}
                        printf '%s\n%s\n%s\n' \
                               "You have chosen the path \"$sOVERRIDE_DEFAULT_INSTALL_PATH\"" \
                               "If that is not correct adjust install_path in the configuration file accordingly" \
                               "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME/$sSCRIPT_FULL_NAME.conf)"
                        DebugMessage "sOVERRIDE_DEFAULT_INSTALL_PATH set to \"$sOVERRIDE_DEFAULT_INSTALL_PATH\""
                        break
                    fi
                ;;
                (*) echo "Invalid choice" ;;
            esac
        done

        [[ -z $sOVERRIDE_DEFAULT_INSTALL_PATH ]] && {
            echo "You will need to manually set install_path in the configuration file"
            echo "(default: ${XDG_CONFIG_HOME:-"$HOME"/.config}/$sSCRIPT_FULL_NAME/$sSCRIPT_FULL_NAME.conf)"
            sOVERRIDE_DEFAULT_INSTALL_PATH="auto"
        }
    fi

    return 0
}

###############################################################################
# Setup env and report
# TODO
SetupEnvironment() {

    local iFAILED=0

    # NOTE [[ $iDEBUG -eq 1 ]] && echo "($LINENO) SetupEnvironment: "

    # sGE_INSTALL_PATH
    if [[ -d $sGE_INSTALL_PATH ]]; then
        DebugMessage "Found existing sGE_INSTALL_PATH at \"$sGE_INSTALL_PATH\""
        if [[ -w $sGE_INSTALL_PATH ]]; then
            DebugMessage "Script has write access to sGE_INSTALL_PATH"
        else
            DebugMessage "Script does not have write access to sGE_INSTALL_PATH"
            echo "Invalid install path: \"$sGE_INSTALL_PATH\""
            iFAILED=1
        fi
    elif [[ ! -d $sGE_INSTALL_PATH ]]; then
        DebugMessage "sGE_INSTALL_PATH not found. Creating at \"$sGE_INSTALL_PATH\""
        if mkdir -p "$sGE_INSTALL_PATH" 2>/dev/null; then
            DebugMessage "Create install path succeeded"
        else
            DebugMessage "Create install path failed"
            echo "Invalid install path: \"$sGE_INSTALL_PATH\""
            iFAILED=1
        fi
    fi

    # sSCRIPT_CONFIG_PATH
    if [[ -d $sSCRIPT_CONFIG_PATH ]]; then
        DebugMessage "Found existing sSCRIPT_CONFIG_PATH at \"$sSCRIPT_CONFIG_PATH\""
        if [[ -w $sSCRIPT_CONFIG_PATH ]]; then
            DebugMessage "Script has write access to sSCRIPT_CONFIG_PATH"
        else
            DebugMessage "Script does not have write access to sSCRIPT_CONFIG_PATH"
            echo "Invalid config path: \"$sSCRIPT_CONFIG_PATH\""
            iFAILED=1
        fi
    elif [[ ! -d $sSCRIPT_CONFIG_PATH ]]; then
        DebugMessage "sSCRIPT_CONFIG_PATH not found. Creating at \"$sSCRIPT_CONFIG_PATH\""
        if mkdir -p "$sSCRIPT_CONFIG_PATH" 2>/dev/null; then
            DebugMessage "Create config path succeeded"
        else
            DebugMessage "Create config path failed"
            echo "Invalid config path: \"$sSCRIPT_CONFIG_PATH\""
            iFAILED=1
        fi
    fi

    # sSCRIPT_CACHE_PATH
    if [[ -d $sSCRIPT_CACHE_PATH ]]; then
        DebugMessage "Found existing sSCRIPT_CACHE_PATH at \"$sSCRIPT_CACHE_PATH\""
        if [[ -w $sSCRIPT_CACHE_PATH ]]; then
            DebugMessage "Script has write access to sSCRIPT_CACHE_PATH"
        else
            DebugMessage "Script does not have write access to sSCRIPT_CACHE_PATH"
            echo "Invalid cache path: \"$sSCRIPT_CACHE_PATH\""
            iFAILED=1
        fi
    elif [[ ! -d $sSCRIPT_CACHE_PATH ]]; then
        DebugMessage "sSCRIPT_CACHE_PATH not found. Creating at \"$sSCRIPT_CACHE_PATH\""
        if mkdir -p "$sSCRIPT_CACHE_PATH" 2>/dev/null; then
            DebugMessage "Create cache path succeeded"
        else
            DebugMessage "Create cache path failed"
            echo "Invalid cache path: \"$sSCRIPT_CACHE_PATH\""
            iFAILED=1
        fi
    fi

    # sFILE_SCRIPT_CONFIG
    if [[ -f $sFILE_SCRIPT_CONFIG ]]; then
        DebugMessage "Found existing sFILE_SCRIPT_CONFIG at \"$sFILE_SCRIPT_CONFIG\""
        if [[ -w $sFILE_SCRIPT_CONFIG ]]; then
            DebugMessage "Script has write access to sFILE_SCRIPT_CONFIG"
        else
            DebugMessage "Script does not have write access to sFILE_SCRIPT_CONFIG"
            echo "No write access to config file: \"$sFILE_SCRIPT_CONFIG\""
            iFAILED=1
        fi
        if [[ -r $sFILE_SCRIPT_CONFIG ]]; then
            DebugMessage "Script has read access to sFILE_SCRIPT_CONFIG"
        else
            DebugMessage "Script does not have read access to sFILE_SCRIPT_CONFIG"
            echo "No read access to config file: \"$sFILE_SCRIPT_CONFIG\""
            iFAILED=1
        fi
    elif [[ ! -f $sFILE_SCRIPT_CONFIG ]]; then
        DebugMessage "sFILE_SCRIPT_CONFIG not found. Creating at \"$sFILE_SCRIPT_CONFIG\""
        if printf '' > "$sFILE_SCRIPT_CONFIG"; then
            DebugMessage "Create script config file succeeded"
        else
            DebugMessage "Create script config file failed"
            echo "Failed to create config file: \"$sFILE_SCRIPT_CONFIG\""
            iFAILED=1
        fi
    fi

    # sTMP_BASE_PATH
    if [[ -d $sTMP_BASE_PATH ]]; then
        DebugMessage "Found existing sTMP_BASE_PATH at \"$sTMP_BASE_PATH\""
        if [[ -w $sTMP_BASE_PATH ]]; then
            DebugMessage "Script has write access to sTMP_BASE_PATH"
        else
            DebugMessage "Script does not have write access to sTMP_BASE_PATH"
            echo "Invalid tmp_path path: \"$sTMP_BASE_PATH\""
            iFAILED=1
        fi
    elif [[ ! -d $sTMP_BASE_PATH ]]; then
        DebugMessage "sTMP_BASE_PATH not found. Creating at \"$sTMP_BASE_PATH\""
        if mkdir -p "$sTMP_BASE_PATH" 2>/dev/null; then
            DebugMessage "Create cache path succeeded"
        else
            DebugMessage "Create cache path failed"
            echo "Invalid tmp_path path: \"$sTMP_BASE_PATH\""
            iFAILED=1
        fi
    fi

    if [[ $iFAILED -eq 0 ]]; then
        DebugMessage "All tasks succeeded"
        return 0
    elif [[ $iFAILED -eq 1 ]]; then
        DebugMessage "One or more tasks failed"
        return 1
    fi

    return 1
}

###############################################################################
# Check for required commands and report if any are missing
CheckRequirements() {

    local iFAILED=0

    # check for all required commands

    if ! command -v curl >/dev/null; then
        echo "($LINENO) CheckRequirements: Command 'curl' is required"
        iFAILED=1
    fi

    if ! command -v sed >/dev/null; then
        echo "($LINENO) CheckRequirements: Command 'sed' is required"
        iFAILED=1
    fi

    if ! command -v tar >/dev/null; then
        echo "($LINENO) CheckRequirements: Command 'tar' is required"
        iFAILED=1
    fi

    if ! command -v gzip >/dev/null; then
        echo "($LINENO) CheckRequirements: Command 'gzip' is required"
        iFAILED=1
    fi

    if ! command -v stat >/dev/null; then
        echo "($LINENO) CheckRequirements: Command 'stat' is required"
        iFAILED=1
    fi

    if ! command -v wc >/dev/null; then
        echo "($LINENO) CheckRequirements: Command 'wc' is required"
        iFAILED=1
    fi

    if [[ $iFAILED -eq 0 ]]; then
        DebugMessage "All tasks succeeded"
        return 0
    elif [[ $iFAILED -eq 1 ]]; then
        DebugMessage "One or more tasks failed"
        return 1
    fi
}

###############################################################################
# A simple helper function used only for debugging and integration testing
ShowConsoleDiff() {

    [[ $# -ne 2 ]] && { echo "It takes two to tango!"; return 1; }

    # iCOLUMNS=$(stty size)
    # iCOLUMNS=${iCOLUMNS##*[[:space:]]}
    if [[ $(shopt checkwinsize) =~ ^checkwinsize[[:blank:]]+off$ ]]; then
        shopt -s checkwinsize
        diff --color -csaW${COLUMNS} "$1" "$2"
        shopt -u checkwinsize
    else
        diff --color -csaW${COLUMNS} "$1" "$2"
    fi

    return 0
}

###############################################################################
# Output to stderr a message and also report the calling line and calling function
# Almost mimic the caller built-in but exclude the source file name and 'main'
DebugMessage() {

    # If debug mode is not active, do nothing
    [[ $iDEBUG -eq 1 ]] || return 0
    [[ -z $1 ]] && { echo "($LINENO)[DebugMessage]: Parameter error (NULL)" 1>&2; return 1; }

    local i

    # Calling line number
    printf '%s' "(${BASH_LINENO[0]})[" 1>&2
    for ((i=$((${#FUNCNAME[@]}-2));i>1;i--)); do
        # Function trace (excluding 'main')
        printf '%s' "${FUNCNAME[i]}," 1>&2
    done
    # Function trace, last one doesn't get a comma suffix
    printf '%s' "${FUNCNAME[i]}]: " 1>&2
    # Message
    printf '%s\n' "$1" 1>&2

    return 0
}

###############################################################################
# Diagnostic tool - exactly -fzZ invokes this function
ReportEnvironmentInfo() {

    # All hope abandon, ye who enter here!
    #-------------------------------------------------------------------------------------
    if [[ $iINTEGRATION_TESTING -eq 1 ]]; then
        #if MemFree "1597756"; then
        #    DebugMessage "MemFree returned success"
        #else
        #    DebugMessage "MemFree returned failure"
        #fi

        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "b") bytes remaining on $sTMP_BASE_PATH"
        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "k") kibibytes remaining on $sTMP_BASE_PATH"
        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "m") mebibytes remaining on $sTMP_BASE_PATH"
        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "g") gibibytes remaining on $sTMP_BASE_PATH"
        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "t") tebibytes remaining on $sTMP_BASE_PATH"
        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "p") pebibytes remaining on $sTMP_BASE_PATH"
        #DebugMessage "$(SpaceRemaining "$sTMP_BASE_PATH" "e") exbibytes remaining on $sTMP_BASE_PATH"

        CreateBackup "/home/toazd/.config/ge-install-manager/ge-install-manager.conf"
        CreateBackup "/home/toazd/github/personal/scripts/bash/ge-install-manager/tmp"

    fi
    ((iINTEGRATION_TESTING)) && exit
    #-------------------------------------------------------------------------------------

    echo "###############################################################################"

    if ! stty -a; then echo "stty -a failed"; fi

    echo "###############################################################################"

    if ! env -v --list-signal-handling 2>/dev/stdout; then echo "env -v --list-signal-handling failed"; fi

    echo "###############################################################################"

    # report found/not found status of commands used
    command -V du find wc curl tar gzip ps stat sed cmp sort envsubst printf

    echo "###############################################################################"

    if ! shopt -p; then echo "shopt -p failed"; fi

    echo "###############################################################################"

    echo "PWD: \"$PWD\""
    echo "SHELL: \"$SHELL\""
    echo "SHELLOPTS: \"$SHELLOPTS\""
    echo "SHLVL: \"$SHLVL\""
    echo "BASH_VERSINFO: \"${BASH_VERSINFO[*]}\""
    echo "BASH_VERSION: \"$BASH_VERSION\""
    echo "MACHTYPE: \"$MACHTYPE\""
    echo "OSTYPE: \"$OSTYPE\""
    echo "PROMPT_COMMAND: \"$PROMPT_COMMAND\""
    echo "LANG: \"$LANG\""
    echo "LC_MESSAGES: \"$LC_MESSAGES\""
    echo "LC_ALL: \"$LC_ALL\""
    echo "EUID: \"$EUID\""
    echo "GROUPS: ${GROUPS[*]}"

    echo "###############################################################################"

    exit 0
}

###############################################################################
# Remove any temporary files/paths created by the script if debug mode is not enabled
CleanUp() {

    for sNODE in "$sTMP_BASE_PATH/$sTMP_PREFIX"*; do
        # paths
        [[ -d $sNODE ]] && {
            DebugMessage "Temporary path found at \"$sNODE\""
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "Debug enabled. Temporary path not removed."
            else
                if rm -rf "$sNODE"; then
                    DebugMessage "Temporary path removed"
                else
                    DebugMessage "Failed to remove temporary path"
                fi
            fi
        }

        # files
        [[ -f $sNODE ]] && {
            DebugMessage "Tmp file found at \"$sNODE\""
            if [[ $iDEBUG -eq 1 ]]; then
                DebugMessage "Debug enabled. Temporary file not removed."
            else
                if rm -rf "$sNODE"; then
                    DebugMessage "Temporary file removed"
                else
                    DebugMessage "Failed to remove temporary file"
                fi
            fi
        }
    done

    return 0
}

###############################################################################
# Parse command line parameters and set global variables according to what was
# requested. Order of operations for invocations that involve multiple parameters
# are listed at the end of the usage section.
# TODO write something that doesn't use getopts so multiple identical parameters
#      can be used in one invocation.
ParseParameters() {
    while getopts 'zZThHflSs:i:d:R:r:NuUXv:V' sOPT; do
        case "$sOPT" in
            (h) iSHOW_HELP=1 ;;
            (H) iSHOW_USAGE=1 ;;
            (f) iFORCE=1 ;;
            (T) iINTEGRATION_TESTING=1 ;; # -fTzZ (undocumented, used for integration testing new features)
            (z) iDEBUG=1 ;;
            (Z)
                if [[ $iFORCE -eq 1 ]] && [[ $iDEBUG -eq 1 ]]; then
                    ReportEnvironmentInfo # exactly -fzZ (undocumented diagnostic tool)
                fi
            ;;
            (u) iCHECK_UPDATE=1 ;;
            (X) iREMOVE_INSTALL_PATH=1 ;;
            (N) iREMOVE_ALL_SAVED_PACKAGES=1 ;;
            (R)
                iREMOVE_INSTALLED_VERSION=1
                sREMOVE_INSTALLED_VERSION=$OPTARG
            ;;
            (r)
                iREMOVE_SAVED_PACKAGE=1
                sREMOVE_SAVED_VERSION=$OPTARG
            ;;
            (l) iLIST_INSTALLED_GE_VERSIONS=1 ;;
            (s)
                iREPORT_VERSION_USAGE=1
                sREPORT_VERSION=$OPTARG
            ;;
            (S) iREPORT_INSTALL_PATH_USAGE=1 ;;
            (d)
                iDOWNLOAD=1
                sDOWNLOAD_VERSION=$OPTARG
            ;;
            (i)
                iINSTALL=1
                sINSTALL_VERSION=$OPTARG
            ;;
            (U) iUPDATE=1 ;;
            (V) iVERIFY=1 ;;
            (v)
                iVERIFY=1
                sVERIFY_VERSION=$OPTARG
            ;;
            (":"|"?")
                return 1
            ;;
        esac
    done

    return 0
}

###############################################################################

Main() {

    # Parse script parameters and arguments, set global variables
    ParseParameters "$@" || exit 1

    # Report if debug mode is enabled
    DebugMessage "Debug mode enabled"

    # If no parameters were supplied, show help
    # NOTE ignore iFORCE and iDEBUG flags
    if [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && \
       [[ $iREMOVE_ALL_SAVED_PACKAGES -eq 0 ]] && \
       [[ $iREMOVE_INSTALLED_VERSION -eq 0 ]] && \
       [[ $iREMOVE_SAVED_PACKAGE -eq 0 ]] && \
       [[ $iLIST_INSTALLED_GE_VERSIONS -eq 0 ]] && \
       [[ $iREPORT_VERSION_USAGE -eq 0 ]] && \
       [[ $iREPORT_INSTALL_PATH_USAGE -eq 0 ]] && \
       [[ $iDOWNLOAD -eq 0 ]] && \
       [[ $iINSTALL -eq 0 ]] && \
       [[ $iCHECK_UPDATE -eq 0 ]] && \
       [[ $iVERIFY -eq 0 ]] && \
       [[ $iSHOW_HELP -eq 0 ]] && \
       [[ $iSHOW_USAGE -eq 0 ]] && \
       [[ $iUPDATE -eq 0 ]]; then

        [[ $iDEBUG -eq 1 ]] && {
            if IsSteamRunning; then
                DebugMessage "Steam is running"
            else
                DebugMessage "Steam is not running"
            fi
            DebugMessage "Nothing to do, showing help"
        }

        # report latest version installed status
        #if GetLatestGEVersion; then
        #    if IsInstalled "$sGE_LATEST_VERSION"; then
        #        echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
        #    else
        #        echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
        #    fi
        #else
        #    echo "An error occured while checking for the latest release"
        #fi
        ShowHelp
        exit 0
    fi

    # show help and/or usage
    if [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 0 ]]; then
        ShowHelp
        exit 0
    elif [[ $iSHOW_HELP -eq 1 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowHelp
        ShowUsage
        exit 0
    elif [[ $iSHOW_HELP -eq 0 ]] && [[ $iSHOW_USAGE -eq 1 ]]; then
        ShowUsage
        exit 0
    fi

    # TODO
    if ParseConfigFile; then
        DebugMessage "ParseConfigFile returned success"
        if CheckRequirements; then
            DebugMessage "CheckRequirements returned success"
            if SetupEnvironment; then
                DebugMessage "SetupEnvironment returned success"
            else
                DebugMessage "SetupEnvironment returned failure"
                exit 1
            fi
        else
            DebugMessage "CheckRequirements returned failure"
        fi
    else
        DebugMessage "ParseConfigFile returned failure"
        exit 1
    fi

    #TODO
    CreateSedUnminifyJSONscript

    # checkupdate
    if [[ $iCHECK_UPDATE -eq 1 && $iUPDATE -eq 0 ]]; then
        if GetLatestGEVersion; then
            if IsInstalled "$sGE_LATEST_VERSION"; then
                echo "The latest version \"$sGE_LATEST_VERSION\" is installed"
            else
                echo "The latest version \"$sGE_LATEST_VERSION\" is not installed"
            fi
        fi
    fi

    # remove install path
    if [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 1 ]]; then
        if IsSteamRunning; then
            echo "Please close Steam before removing the install path"
        else
            RemoveGEInstallPath
        fi
    elif [[ $iREMOVE_INSTALL_PATH -eq 1 ]] && [[ $iFORCE -eq 0 ]]; then
        echo "-X must be combined with -f to confirm that you are sure"
    fi

    # remove saved packages
    if [[ $iREMOVE_ALL_SAVED_PACKAGES -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]]; then
        RemoveAllSavedPackages # TODO -f required?
    fi

    # Remove an installed version
    if [[ $iREMOVE_INSTALLED_VERSION -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && [[ $iREMOVE_ALL_SAVED_PACKAGES -eq 0 ]]; then
        RemoveGEVersion "$sREMOVE_INSTALLED_VERSION" # NOTE sREMOVE_VERSION is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif [[ $iREMOVE_INSTALLED_VERSION -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Remove a saved package
    if [[ $iREMOVE_SAVED_PACKAGE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 0 ]] && [[ $iREMOVE_ALL_SAVED_PACKAGES -eq 0 ]]; then
        RemoveSavedPackage "$sREMOVE_SAVED_VERSION" # NOTE sREMOVE_VERSION is set in getops
    # If remove install path was requested in the same invocation, skip removing version/package
    elif [[ $iREMOVE_SAVED_PACKAGE -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -eq 1 ]]; then
        echo "Skipping remove version/package because remove install path was also requested"
    fi

    # Download a package
    ((iDOWNLOAD)) && {
        DownloadGEPackage "$sDOWNLOAD_VERSION" # NOTE sDOWNLOAD_VERSION is set in getops
    }

    # Check for new version and if it is not installed install it
    if [[ $iUPDATE -eq 1 ]]; then
        if UpdateSavedGELatestRelease; then
            if GetLatestGEVersion; then # set sGE_LATEST_VERSION
                if IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 1 ]]; then # Latest version is installed and -f is suppled
                    if RemoveGEVersion "$sGE_LATEST_VERSION"; then
                        if InstallGEVersion; then # InstallGEVersion checks iUPDATE then sINSTALL_VERSION and/or sGE_LATEST_VERSION
                            echo "Update succeeded"
                        else
                            echo "Update failed"
                        fi
                    fi
                elif IsInstalled "$sGE_LATEST_VERSION" && [[ $iFORCE -eq 0 ]]; then # Latest version is installed and -f was not supplied
                    #[[ $iDEBUG -eq 1 ]] && printf '%s' "($LINENO) Main: Update: " 1>&2
                    echo "Latest version is already installed ($sGE_LATEST_VERSION)"
                elif ! IsInstalled "$sGE_LATEST_VERSION"; then # Latest version is not installed
                    #[[ $iDEBUG -eq 1 ]] && printf '%s' "($LINENO) Main: Update: " 1>&2
                    echo "Latest version is not installed"
                    if InstallGEVersion; then
                        #[[ $iDEBUG -eq 1 ]] && printf '%s' "($LINENO) Main: Update: " 1>&2
                        echo "Update succeeded"
                        if IsSteamRunning; then
                            echo "Restart Steam to use the new version"
                        fi
                    else
                        #[[ $iDEBUG -eq 1 ]] && printf '%s' "($LINENO) Main: Update: " 1>&2
                        echo "Update failed"
                    fi
                fi
            else
                DebugMessage "Update: GetLatestGEVersion returned failure status"
            fi
        else
            # GetLatestGEVersionInfo failed
            DebugMessage "Update: GetLatestGEVersionInfo returned failure status"
            echo "Update failed"
        fi
        # Like purchasing a tribble, this is probably a bad idea
        [[ $iINSTALL -eq 1 ]] && iUPDATE=0 # Reset iUPDATE to 0 so update and install can run in the same invocation
    fi

    # Install a package
    if [[ $iINSTALL -eq 1 ]] && [[ $iUPDATE -eq 0 ]]; then
        # NOTE sINSTALL_VERSION is set in getops
        InstallGEVersion "$sINSTALL_VERSION"
    fi

    # List installed versions
    [[ $iLIST_INSTALLED_GE_VERSIONS -eq 1 ]] && ListInstalledGEVersions

    # Report entire install path disk usage and file count
    [[ $iREPORT_INSTALL_PATH_USAGE -eq 1 ]] && ReportGEDiskUsage

    # Report disk usage and file count for a specific version
    [[ $iREPORT_VERSION_USAGE -eq 1 ]] && ReportGEDiskUsage "$sREPORT_VERSION"

    # Run verify if remove install path and remove saved packages wasn't requested
    # TODO add support to verify even if remove saved packages and/or remove install path was invoked
    # so long as some sort of install was also requested. Additionally, maybe support installing a version
    # that is not installed when verify is called and force mode is active.
    if [[ $iVERIFY -eq 1 ]] && [[ $iREMOVE_INSTALL_PATH -ne 1 && $iREMOVE_ALL_SAVED_PACKAGES -ne 1 ]]; then
        VerifyGEInstall "$sVERIFY_VERSION"
    fi

    return 0
}

###############################################################################
# EXIT INT trap
# NOTE This only shows information when debug mode is enable
trap 'iREAL_EXIT_STATUS=$?; DebugMessage "Exit status (before CleanUp): $iREAL_EXIT_STATUS"; CleanUp; DebugMessage "Exit status (after CleanUp): $?"; exit $iREAL_EXIT_STATUS' EXIT INT

###############################################################################
# Invokes the function "Main" passing it the positional parameters from the command line

Main "$@"

